#version 450 corelayout(location = 0) in vec4 in_frag_color;layout(location = 1) in vec3 in_tex_coord;layout(location = 2) in float mix_value;layout(location = 0) out vec4 fragColor;layout(set = 1, binding = 0) uniform sampler2DArray texSampler;layout(push_constant) uniform quad_index{	mat4 model;	vec4 parameters1;	vec4 parameters2;	vec4 parameters3;	vec4 camera;} pc;#define QUALITY 10.0#define SCALE 0.5#define ZOOM 1.0/* Hash by David_Hoskins */#define UI0 1597334673U#define UI1 3812015801U#define UI2 uvec2(UI0, UI1)#define UI3 uvec3(UI0, UI1, 2798796415U)#define UIF (1.0 / float(0xffffffffU))vec3 hash33(vec3 p){	uvec3 q = uvec3(ivec3(p)) * UI3;	q = (q.x ^ q.y ^ q.z)*UI3;	return -1. + 2. * vec3(q) * UIF;}float remap(float x, float a, float b, float c, float d){    return (((x - a) / (b - a)) * (d - c)) + c;}/* Gradient noise by iq (modified to be tileable) */float gradientNoise(vec3 x, float freq){    /* grid */    vec3 p = floor(x);    vec3 w = fract(x);        /* quintic interpolant */    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);        /* gradients */    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));        /* projections */    float va = dot(ga, w - vec3(0., 0., 0.));    float vb = dot(gb, w - vec3(1., 0., 0.));    float vc = dot(gc, w - vec3(0., 1., 0.));    float vd = dot(gd, w - vec3(1., 1., 0.));    float ve = dot(ge, w - vec3(0., 0., 1.));    float vf = dot(gf, w - vec3(1., 0., 1.));    float vg = dot(gg, w - vec3(0., 1., 1.));    float vh = dot(gh, w - vec3(1., 1., 1.));	    /* interpolation */    return va +            u.x * (vb - va) +            u.y * (vc - va) +            u.z * (ve - va) +            u.x * u.y * (va - vb - vc + vd) +            u.y * u.z * (va - vc - ve + vg) +            u.z * u.x * (va - vb - ve + vf) +            u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);}/* Tileable 3D worley noise */float worleyNoise(vec3 uv, float freq){        vec3 id = floor(uv);    vec3 p = fract(uv);        float minDist = 10000.;    for (float x = -1.; x <= 1.; ++x)    {        for(float y = -1.; y <= 1.; ++y)        {            for(float z = -1.; z <= 1.; ++z)            {                vec3 offset = vec3(x, y, z);            	vec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;    			h += offset;            	vec3 d = p - h;           		minDist = min(minDist, dot(d, d));            }        }    }        /* inverted worley noise */    return 1. - minDist;}/* Fbm for Perlin noise based on iq's blog */float perlinfbm(vec3 p, float freq, int octaves){    float G = exp2(-.85);    float amp = 1.;    float noise = 0.;    for (int i = 0; i < octaves; ++i)    {        noise += amp * gradientNoise(p * freq, freq);        freq *= 2.;        amp *= G;    }        return noise;}/* Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes *//* chapter in GPU Pro 7. */float worleyFbm(vec3 p, float freq){    return worleyNoise(p*freq, freq) * .625 +        	 worleyNoise(p*freq*2., freq*2.) * .25 +        	 worleyNoise(p*freq*4., freq*4.) * .125;}float radialFalloff(vec2 uv, float radius) {    vec2 center = vec2(.25, .25);    float dist = length(center - uv);    vec2 m = vec2(pc.parameters2.y * .1);        float slices = 256.;     float freq = 8;        float pfbm= mix(1., perlinfbm(vec3(uv, floor(m.y*slices)/slices), 4., 7), .5);    pfbm = abs(pfbm * 2. - 1.);    float noise = worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq);    noise = remap(pfbm, 0., 1., noise, 1.) * .1;    dist += noise;    return 1 - smoothstep(0.0, radius, dist);}vec3 hash34(vec3 p3){    p3 = fract(p3 * vec3(.1031, .1030, .0973));    p3 += dot(p3, p3.yxz+33.33);    return fract((p3.xxy + p3.yxx)*p3.zyx);}float worleynoise(vec3 p){    vec3 n = floor( p );    vec3 f = fract( p );    float dis = 1.;    for( int k=-1; k<=1; k++ )    for( int j=-1; j<=1; j++ )    for( int i=-1; i<=1; i++ )    {           vec3  g = vec3(i,j,k);        vec3  o = hash34( n + g );        vec3  delta = g+o-f;        float d = length(delta);        dis = min(dis,d);    }    return dis;}/*float radialFalloff(vec2 uv, float radius) {    float dist = length(uv - .25);        float scale = 8.;    vec3 noiseInput = vec3(uv.x * scale, pc.parameters2.y * 1, uv.y * scale);     float noise = worleynoise(noiseInput) * 0.1;      dist += noise;        return 1.0 - smoothstep(0.0, radius, dist);}*/float enhanceContrast(float col) {    col = smoothstep(0., 1, col);        col = 1.0 / (1.0 + exp(-8.0 * (col - 0.5)));        return col;}float random(vec2 n){    return fract(cos(dot(fract(n/142.0),vec2(36.26,73.12)))*354.63);}float simple_noise(vec2 n){    vec2 fn = floor(n);    vec2 sn = smoothstep(vec2(0),vec2(1),fract(n));        float h1 = mix(random(fn),random(fn+vec2(1,0)),sn.x);    float h2 = mix(random(fn+vec2(0,1)),random(fn+vec2(1)),sn.x);    return mix(h1,h2,sn.y);}float fractal(vec3 n){	    float total = 0.5;    for(float i = 0.0;i<QUALITY;i++)    {        total = mix(simple_noise(n.xy/exp2(i-fract(n.z))+i+floor(n.z)),                    total,pow((i-fract(n.z))/(QUALITY-1.0),2.0));    } 	return total;}void main(){    vec2 iResolution = vec2(pc.parameters1.x, pc.parameters1.y);    vec2 fragCoord = in_tex_coord.xy * iResolution;    vec2 sp = (fragCoord * 2.-iResolution.xy) / iResolution.y;    vec2 center = vec2(0.25, 0.25);    vec2 uv = in_tex_coord.xy;	float iTime = pc.parameters2.y;	vec2 m = vec2(pc.parameters2.y * .1);        float slices = 256.;     float freq = 4;    float pfbm= mix(1., perlinfbm(vec3(uv, floor(m.y*slices)/slices), 4., 7), .5);    pfbm = abs(pfbm * 2. - 1.);    float noise = worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq);    float falloff = radialFalloff(uv, .25);    noise = (enhanceContrast( remap(pfbm, 0., 1., noise, 1.)));    noise *= pow(noise, 10);    /* Toon shading */    float levels = 4.0; /* Number of color bands*/    float toon = floor(noise * levels) / levels;        /* Edge detection */    float edge = length(fwidth(noise) * 2.);    float outline = smoothstep(0.0, .1, edge);        vec3 color = mix(vec3(toon), vec3(0.0), outline);    fragColor = vec4(pow(vec3(color), vec3(1 / 2.2)), 0.0);}