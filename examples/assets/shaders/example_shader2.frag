#version 450 corelayout(location = 0) in vec4 in_frag_color;layout(location = 1) in vec3 in_tex_coord;layout(location = 2) in float mix_value;layout(location = 0) out vec4 fragColor;layout(set = 1, binding = 0) uniform sampler2DArray texSampler;layout(push_constant) uniform quad_index{	mat4 model;	vec4 parameters1;	vec4 parameters2;	vec4 parameters3;	vec4 camera;} pc;float field(in vec3 p, float iTime) {	float strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));	float accum = 0.;	float prev = 0.;	float tw = 0.;	for (int i = 0; i < 32; ++i) {		float mag = dot(p, p);		p = abs(p) / mag + vec3(-.5, -.4, -1.5);		float w = exp(-float(i) / 7.);		accum += w * exp(-strength * pow(abs(mag - prev), 2.3));		tw += w;		prev = mag;	}	return max(0., 5. * accum / tw - .7);}#define NUM_LAYERS 10.#define ITER 30vec4 tex(vec3 p){	float iTime = pc.parameters2.y;    float t = iTime+78.;    vec4 o = vec4(p.xyz,3.*sin(t*.1));    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);    return o;}vec3 hash34(vec3 p3){    p3 = fract(p3 * vec3(.1031, .1030, .0973));    p3 += dot(p3, p3.yxz+33.33);    return fract((p3.xxy + p3.yxx)*p3.zyx);}float worleynoise(vec3 p){    vec3 n = floor( p );    vec3 f = fract( p );    float dis = 1.;    for( int k=-1; k<=1; k++ )    for( int j=-1; j<=1; j++ )    for( int i=-1; i<=1; i++ )    {           vec3  g = vec3(i,j,k);        vec3  o = hash34( n + g );        vec3  delta = g+o-f;        float d = length(delta);        dis = min(dis,d);    }    return dis;}float radialFalloff(vec2 uv, float radius) {    float dist = length(uv - .25);        float scale = 8.;    vec3 noiseInput = vec3(uv.x * scale, pc.parameters2.y * 0.5, uv.y * scale);     float noise = worleynoise(noiseInput) * 0.1;      dist += noise;        return 1.0 - smoothstep(0.0, radius, dist);}void main( ) {    vec2 iResolution = vec2(pc.parameters1.x, pc.parameters1.y);    vec2 fragCoord = in_tex_coord.xy * iResolution;    vec2 center = vec2(0.25, 0.25);	float iTime = pc.parameters2.y;    vec2 pos = 256.0*fragCoord.xy/iResolution.x;    vec2 uv = (fragCoord-iResolution.xy*.25)/iResolution.y;    vec3 col = vec3(0);       float t= iTime* .3;    	for(float i=0.; i<=1.; i+=1./NUM_LAYERS)    {        float d = fract(i+t); /* depth */        float s = mix(25.,.25,d); /* scale */        float f = d * smoothstep(1.,.9,d); /*fade */        col+= tex(vec3(uv*s,i*4.)).xyz*f;    }        col/=NUM_LAYERS;    col*=vec3(2,1.,2.);   	col=pow(col,vec3(.5 ));      float falloff = radialFalloff(in_tex_coord.xy, 0.25);    fragColor = vec4((col *2) * falloff, .0);}