#version 450
#define group_size 128

struct ribbon_segments {
    vec4 position_and_width;  // xyz = position, w = width                
    vec4 parameters;
};

struct vertex {
    vec4 position;                    
    vec4 uv;
};

layout(push_constant) uniform camera_push
{
    vec4 position;
    float uv_scale;
    float uv_offset;
    float width_scale_multiplier;
    uint segment_count;
} camera;

layout (local_size_x = group_size) in;

layout (std430, binding = 0) readonly buffer InRibbons {
    ribbon_segments ribbon_data[];
};

layout (std430, binding = 1) buffer OutVertices {
    vertex vertex_data[];
};

void main() {    
    uint global_index = gl_GlobalInvocationID.x;
    if (global_index >= camera.segment_count) return;
    
    vec3 current_pos = ribbon_data[global_index].position_and_width.xyz;
    float width = ribbon_data[global_index].position_and_width.w;
    
    vec3 to_camera = normalize(camera.position.xyz - current_pos.xyz);
    
    vec3 forward = (global_index < camera.segment_count - 1) 
        ? normalize(ribbon_data[global_index + 1].position_and_width.xyz - current_pos)
        : normalize(current_pos - ribbon_data[global_index - 1].position_and_width.xyz);

	float view_alignment = abs(dot(forward, to_camera));
	float threshold = camera.width_scale_multiplier; // Adjust threshold as needed

	// Only blend when we exceed the threshold
    float blended = 2.0;
    vec3 right;
	if (view_alignment > threshold) {
		vec3 perpendicular = normalize(cross(forward, vec3(0, -1, 0)));
		float blend = (view_alignment - threshold) / (threshold);
		to_camera = normalize(mix(to_camera, perpendicular, blend));
		right = normalize(cross(forward, to_camera));
    } else {
		right = normalize(cross(-forward, -to_camera));
	}
    
    
    float v = float(global_index) / float(camera.segment_count);
    float u_scaled = v * camera.uv_scale;
    
    uint vertex_index = global_index * 2;
    vertex_data[vertex_index].position = vec4(current_pos - right * (width * 0.5), 1.0);
    vertex_data[vertex_index].uv.xyz = vec3(0.0, u_scaled + camera.uv_offset, 0);
    
    vertex_data[vertex_index + 1].position = vec4(current_pos + right * (width * 0.5), 1.0);
    vertex_data[vertex_index + 1].uv = vec4(1.0, u_scaled + camera.uv_offset, 0., float(global_index) / float(camera.segment_count) * blended);
}