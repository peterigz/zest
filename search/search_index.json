{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Zest","text":"<p>A lightweight single-header rendering library</p> <p>Zest is a C11-compatible rendering library with a clean, modern API designed for multiple graphics backends. It provides a frame graph execution model, bindless descriptors, and automatic resource management - all in a single header file. Currently Vulkan is the primary backend, with DirectX, Metal, and WebGPU planned for the future.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Single Header - Just <code>#include &lt;zest.h&gt;</code> and you're ready to go</li> <li>Frame Graph System - Declarative rendering with automatic barrier insertion, pass culling, and resource management</li> <li>Bindless Descriptors - Global descriptor set with indexed access to all textures and buffers</li> <li>TLSF Memory Allocator - Efficient GPU memory management with minimal fragmentation</li> <li>Dynamic Rendering - No pre-baked render pass objects needed; render passes are configured at draw time</li> <li>Layer System - Built-in support for instanced sprites, meshes and static meshes</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>GPU with bindless descriptor support</li> <li>SDL2 for windowing (or any other windowing library of your choice)</li> <li>C11 compiler (also compiles as C++)</li> </ul> <p>Vulkan backend: Requires Vulkan 1.2+ capable GPU</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;zest.h&gt;\n\nint main() {\n    // Create window and device (one per application)\n    zest_window_data_t window = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\n    zest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window, false);\n\n    // Create context\n    zest_create_context_info_t info = zest_CreateContextInfo();\n    zest_context context = zest_CreateContext(device, &amp;window, &amp;info);\n\n    // Main loop with frame graph...\n}\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li> <p>:material-rocket-launch: Getting Started</p> <p>Installation, first application, and architecture overview</p> <p>:octicons-arrow-right-24: Get started</p> </li> <li> <p>:material-book-open-variant: Concepts</p> <p>Deep dives into Device, Context, Frame Graph, Pipelines, and more</p> <p>:octicons-arrow-right-24: Learn concepts</p> </li> <li> <p>:material-school: Tutorials</p> <p>Step-by-step guides from basic setup to advanced rendering</p> <p>:octicons-arrow-right-24: Follow tutorials</p> </li> <li> <p>:material-api: API Reference</p> <p>Complete reference for all 500+ Zest functions</p> <p>:octicons-arrow-right-24: Browse API</p> </li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Zest includes 16 working examples demonstrating various features:</p> Example Description zest-minimal-template Bare minimum Zest application zest-imgui-template ImGui integration with docking zest-compute-example Compute shader particle simulation zest-instancing GPU instancing with multi-mesh layers zest-pbr-forward Physical-based rendering zest-shadow-mapping Shadow mapping techniques <p>View all examples :octicons-arrow-right-24:</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete reference for Zest's public functions organized by category. Zest provides a lightweight C API for GPU rendering with automatic resource management, frame graph compilation, and bindless descriptor support. The core API is graphics-API agnostic, with platform layers providing the backend implementation (currently Vulkan, with DirectX/Metal/WebGPU possible in the future).</p>"},{"location":"api-reference/#api-conventions","title":"API Conventions","text":""},{"location":"api-reference/#naming-patterns","title":"Naming Patterns","text":"<p>Zest uses consistent naming conventions to make the API predictable and discoverable:</p> Pattern Meaning Example <code>zest_Create*</code> Create and return a new resource <code>zest_CreateBuffer</code>, <code>zest_CreateImage</code> <code>zest_Get*</code> Retrieve an existing resource or property <code>zest_GetImage</code>, <code>zest_GetShader</code> <code>zest_Set*</code> Configure a property on a resource <code>zest_SetPipelineBlend</code>, <code>zest_SetPipelineTopology</code> <code>zest_Free*</code> Release a resource and its memory <code>zest_FreeBuffer</code>, <code>zest_FreeShader</code> <code>zest_Begin*</code> Start a scope, pass, or builder pattern <code>zest_BeginFrameGraph</code>, <code>zest_BeginRenderPass</code> <code>zest_End*</code> End a scope, pass, or builder pattern <code>zest_EndFrameGraph</code>, <code>zest_EndPass</code> <code>zest_cmd_*</code> Command recorded into frame graph <code>zest_cmd_Draw</code>, <code>zest_cmd_BindPipeline</code> <code>zest_imm_*</code> Immediate/one-off command (outside frame graph) <code>zest_imm_CopyBuffer</code> <code>zest_impl*_</code> Platform-specific implementation <code>zest_implsdl2_CreateVulkanDevice</code>"},{"location":"api-reference/#function-markers","title":"Function Markers","text":"<p>Functions in the header are marked with visibility indicators:</p> <ul> <li><code>ZEST_API</code> - Public API function, safe to use in your application</li> <li><code>ZEST_PRIVATE</code> - Internal function, may change without notice (prefixed with <code>zest__</code>)</li> </ul>"},{"location":"api-reference/#handle-vs-object","title":"Handle vs Object","text":"<p>Many resources use a two-tier system for safe resource management:</p> <pre><code>// Handles are lightweight identifiers (safe to copy, store, pass around)\nzest_image_handle handle = zest_CreateImage(device, &amp;info);\n\n// Objects are pointers to the actual data which you can use to pass in to various functions that use the pointers.\nzest_image image = zest_GetImage(handle);\n</code></pre> <p>The reason why you have to get the object pointer to pass in to functions is just to reduce the overhead of having to fetch the resource from the store. Whilst it's still quick to do so there is still some overhead of verifying the validity of the resource, so instead you can get the point and then use that. Typically you want the pointer lifetime to be just the current scope of where you're using it.</p> <p>Handles provide an extra layer of indirection that allows Zest to manage resource lifetimes, detect stale references, and support hot-reloading.</p> <p>The object pointers are opaque and just designed to work with functions to make specific changes in a safe way. It also means that changes can be made to the underlying struct and not break code that may have accessed struct members directly.</p>"},{"location":"api-reference/#type-conventions","title":"Type Conventions","text":"Suffix Meaning Example <code>_t</code> Struct type <code>zest_timer_t</code>, <code>zest_buffer_info_t</code> <code>_handle</code> Opaque handle type <code>zest_image_handle</code>, <code>zest_shader_handle</code> (none) Pointer to struct <code>zest_image</code>, <code>zest_buffer</code>"},{"location":"api-reference/#categories","title":"Categories","text":""},{"location":"api-reference/#core","title":"Core","text":"<p>These APIs form the foundation of every Zest application:</p> Category Description Device API Device creation, configuration, and lifecycle. The device manages GPU resources, shader library, and pipeline templates. Context API Window/swapchain management. Each context represents a render target (window or offscreen) with its own frame resources. Frame Graph API Declarative render pass building and automatic execution. The frame graph compiler handles barriers, synchronization, and resource transitions."},{"location":"api-reference/#resources","title":"Resources","text":"<p>APIs for creating and managing GPU resources:</p> Category Description Buffer API Vertex buffers, index buffers, uniform buffers, and storage buffers. Includes staging and upload utilities. Image API Textures, render targets, depth buffers, and samplers. Supports mipmapping, cubemaps, and array textures. Pipeline API Pipeline templates for graphics and compute. Configure shaders, vertex input, rasterization, depth testing, and blending."},{"location":"api-reference/#rendering","title":"Rendering","text":"<p>APIs for recording draw commands and managing render state:</p> Category Description Layer API High-level rendering abstraction for instanced sprites, meshes, and text. Automatic batching and buffer management. Compute API Compute shader dispatch and synchronization. Command API Low-level <code>zest_cmd_*</code> functions for recording draw calls, binding resources, and setting state within frame graph passes. Immediate API <code>zest_imm_*</code> functions for one-off operations outside the frame graph (uploads, copies, etc.)."},{"location":"api-reference/#utilities","title":"Utilities","text":"<p>Helper APIs for common tasks that you can take or leave, these are added to help with example writing but you can make use of them as well.</p> Category Description Math API Vector and matrix operations, interpolation, packing functions, and angle conversion. Camera API First-person and orbit camera utilities with view/projection matrix generation. Timer API Fixed timestep game loop utilities with accumulator-based timing and interpolation support."},{"location":"api-reference/#quick-reference","title":"Quick Reference","text":""},{"location":"api-reference/#application-setup","title":"Application Setup","text":"<pre><code>// Create window and device using SDL2 (initializes graphics backend, creates logical device)\nzest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, ZEST_FALSE);  // ZEST_TRUE for validation\n\n// Create context (swapchain and frame resources)\nzest_create_context_info_t context_info = zest_CreateContextInfo();\nzest_context context = zest_CreateContext(device, &amp;window_data, &amp;context_info);\n</code></pre>"},{"location":"api-reference/#main-loop","title":"Main Loop","text":"<pre><code>while (running) {\n    // Poll events, update input, etc.\n\n    // Update device (handles window resize, resource cleanup)\n    zest_UpdateDevice(device);\n\n    // Begin frame (acquires swapchain image)\n    if (zest_BeginFrame(context)) {\n        // Build or retrieve frame graph\n        zest_BeginFrameGraph(context, \"main\", NULL);\n        // ... define passes ...\n        zest_frame_graph graph = zest_EndFrameGraph();\n\n        // Queue for execution\n        zest_QueueFrameGraphForExecution(context, graph);\n\n        // End frame (submits commands, presents)\n        zest_EndFrame(context);\n    }\n}\n\n// Cleanup\nzest_DestroyDevice(device);\n</code></pre>"},{"location":"api-reference/#common-render-commands","title":"Common Render Commands","text":"<p>These commands are used inside frame graph pass callbacks:</p> <pre><code>void my_render_callback(zest_command_list cmd, void *user_data) {\n    // Bind pipeline\n    zest_pipeline pipeline = zest_GetPipeline(my_pipeline_template, cmd);\n    zest_cmd_BindPipeline(cmd, pipeline);\n\n    // Set viewport (screen-sized with default depth range)\n    zest_cmd_SetScreenSizedViewport(cmd, 0.0f, 1.0f);\n\n    // Bind vertex/index buffers\n    zest_cmd_BindVertexBuffer(cmd, 0, 1, vertex_buffer);  // binding 0, count 1\n    zest_cmd_BindIndexBuffer(cmd, index_buffer);\n\n    // Send push constants\n    zest_cmd_SendPushConstants(cmd, &amp;push_data, sizeof(push_data));\n\n    // Draw\n    zest_cmd_Draw(cmd, vertex_count, instance_count, first_vertex, first_instance);\n    zest_cmd_DrawIndexed(cmd, index_count, instance_count, first_index, vertex_offset, first_instance);\n}\n</code></pre>"},{"location":"api-reference/#resource-creation","title":"Resource Creation","text":"<pre><code>// Buffer\nzest_buffer_info_t buf_info = zest_CreateBufferInfo(zest_buffer_type_vertex, zest_memory_usage_gpu);\nzest_buffer buffer = zest_CreateBuffer(device, size, &amp;buf_info);\n\n// Image (texture with mipmaps)\nzest_image_info_t img_info = zest_CreateImageInfo(width, height);\nimg_info.flags = zest_image_preset_texture_mipmaps;\nzest_image_handle image = zest_CreateImage(device, &amp;img_info);\n\n// Pipeline\nzest_pipeline_template pipeline = zest_CreatePipelineTemplate(device, \"my_pipeline\");\nzest_SetPipelineShaders(pipeline, vert_shader, frag_shader);\nzest_SetPipelineTopology(pipeline, zest_topology_triangle_list);\nzest_SetPipelineCullMode(pipeline, zest_cull_mode_back);\nzest_SetPipelineDepthTest(pipeline, ZEST_TRUE, ZEST_TRUE);\nzest_SetPipelineBlend(pipeline, zest_BlendStateNone());\n</code></pre>"},{"location":"api-reference/#image-presets","title":"Image Presets","text":"<p>Common image flag combinations for typical use cases:</p> Preset Use Case <code>zest_image_preset_texture</code> Basic sampled texture <code>zest_image_preset_texture_mipmaps</code> Texture with auto-generated mipmaps <code>zest_image_preset_color_attachment</code> Render target (color) <code>zest_image_preset_depth_attachment</code> Render target (depth/stencil) <code>zest_image_preset_storage</code> Compute shader read/write <code>zest_image_preset_storage_cubemap</code> Cubemap for compute"},{"location":"api-reference/#source-files","title":"Source Files","text":"<p>The API is defined across these header files:</p> File Contents <code>zest.h</code> Main API - device, context, frame graph, resources, commands, math, timer <code>zest_vulkan.h</code> Vulkan platform layer (current default backend) <code>zest_utilities.h</code> Optional helpers - image loading (stb, ktx), font loading with msdf generator, model loading with gltf <p>Future platform layers (e.g., <code>zest_dx12.h</code>, <code>zest_metal.h</code>) would follow the same pattern.</p>"},{"location":"api-reference/#include-pattern","title":"Include Pattern","text":"<p>Copy zest.h and zest_vulkan.h (in future other platforms you want to support), and if you want to use it zest_utilities.h into your project include folder.</p> <pre><code>// In exactly ONE .cpp file:\n#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;zest.h&gt;\n\n// In other files, just include the header:\n#include &lt;zest.h&gt;\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>Zest uses a combination of return values and assertions:</p> <ul> <li>Functions that can fail return <code>zest_bool</code> or a handle (check for <code>handle.value == 0</code> for null handle return)</li> <li>Debug builds include assertions for invalid parameters</li> <li>Enable validation/debug layers during development: <code>zest_implsdl2_CreateVulkanDevice(&amp;window_data, ZEST_TRUE)</code></li> </ul> <pre><code>zest_image_handle image = zest_CreateImage(device, &amp;info);\nif (image.value == 0) {\n    // Handle creation failure\n}\n</code></pre>"},{"location":"api-reference/#thread-safety","title":"Thread Safety","text":"<p>Still largely untested but:</p> <ul> <li>Device creation/destruction: Main thread only</li> <li>Resource creation: Generally main thread, some resources support background loading</li> <li>Frame graph building: Single thread per context</li> <li>Command recording: Thread-safe within a pass (different command lists)</li> </ul> <p>For multi-threaded rendering, use separate command lists and synchronize at pass boundaries.</p>"},{"location":"api-reference/buffer/","title":"Buffer API","text":"<p>Functions for buffer creation and management.</p>"},{"location":"api-reference/buffer/#creation","title":"Creation","text":""},{"location":"api-reference/buffer/#zest_createbufferinfo","title":"zest_CreateBufferInfo","text":"<p>Create buffer configuration.</p> <pre><code>zest_buffer_info_t zest_CreateBufferInfo(\n    zest_buffer_type type,\n    zest_memory_usage memory_usage\n);\n</code></pre> <p>Types:</p> Buffer Type Usage zest_buffer_type_staging Used to upload data from CPU side to GPU zest_buffer_type_vertex Any kind of data for storing vertices used in vertex shaders zest_buffer_type_index Index data for use in vertex shaders zest_buffer_type_uniform Small buffers for uploading data to the GPU every frame zest_buffer_type_storage General purpose storage buffers mainly for compute but any other shader type can access too zest_buffer_type_vertex_storage Vertex data that can also be accessed/written to by the GPU zest_buffer_type_index_storage Index data that can also be accessed/written to by the GPU <p>Memory: <code>zest_memory_usage_gpu_only</code>, <code>zest_memory_usage_cpu_to_gpu</code>, <code>zest_memory_usage_gpu_to_cpu</code></p> Memory Usage Usage zest_memory_usage_gpu_only Any memory that is stored locally on the GPU only zest_memory_usage_cpu_to_gpu Used for staging and uniform buffers that exist in host memory and can be transferred to GPU only memory zest_memory_usage_gpu_to_cpu GPU local memory that can be used to transfer data back to the host for debugging or other purposes"},{"location":"api-reference/buffer/#zest_createbuffer","title":"zest_CreateBuffer","text":"<p>Buffers can be used for wide variety of data storage depending on what you need. </p> <pre><code>zest_buffer zest_CreateBuffer(\n    zest_device device,\n    zest_size size,\n    zest_buffer_info_t *info\n);\n</code></pre> <p>Some typical examples:</p> <p>For particle data processed in a compute shader <pre><code>zest_buffer_info_t particle_vertex_buffer_info = zest_CreateBufferInfo(zest_buffer_type_vertex_storage, zest_memory_usage_gpu_only);\napp-&gt;particle_buffer = zest_CreateBuffer(app-&gt;device, storage_buffer_size, &amp;particle_vertex_buffer_info);\n</code></pre></p> <p>For mesh data processed in a vertex shader <pre><code>zest_buffer_info_t index_info = zest_CreateBufferInfo(zest_buffer_type_index, zest_memory_usage_gpu_only);\nzest_buffer_info_t vertex_info = zest_CreateBufferInfo(zest_buffer_type_vertex, zest_memory_usage_gpu_only);\napp-&gt;planet_mesh.index_buffer = zest_CreateBuffer(app-&gt;device, planet_index_capacity, &amp;index_info);\napp-&gt;planet_mesh.vertex_buffer = zest_CreateBuffer(app-&gt;device, planet_vertex_capacity, &amp;vertex_info);\n</code></pre></p>"},{"location":"api-reference/buffer/#zest_createstagingbuffer","title":"zest_CreateStagingBuffer","text":"<p>Create staging buffer with initial data. This will prepare the appropriate buffer info for a staging buffer configuration and you can pass in a pointer to any data that you want copied to the staging buffer so that it can then be immediately used to upload the data to the GPU.</p> <pre><code>zest_buffer zest_CreateStagingBuffer(\n    zest_device device,\n    zest_size size,\n    void *data\n);\n</code></pre>"},{"location":"api-reference/buffer/#management","title":"Management","text":""},{"location":"api-reference/buffer/#zest_growbuffer","title":"zest_GrowBuffer","text":"<p>A convenience function you can use to grow a buffer. It will grow the buffer to at least <code>minimum_bytes</code>, growing by <code>unit_size</code> increments. Returns true if the buffer was reallocated. Note: If the buffer is memory that is GPU only then the existing data is not kept, otherwise for host memory the data is kept. You could use this function if you are incrementally writing data to a staging buffer and planning to upload to a device buffer at some point. If the buffer runs out of space you can call this to grow the memory.</p> <pre><code>zest_bool zest_GrowBuffer(zest_buffer *buffer, zest_size unit_size, zest_size minimum_bytes);\n</code></pre>"},{"location":"api-reference/buffer/#zest_resizebuffer","title":"zest_ResizeBuffer","text":"<p>Resize buffer (may reallocate). Resizes to the exact size that you pass in to the function. Returns true if the buffer was reallocated. Note: If the buffer is memory that is GPU only then the existing data is not kept, otherwise for host memory the data is kept.</p> <pre><code>zest_bool zest_ResizeBuffer(zest_buffer *buffer, zest_size new_size);\n</code></pre>"},{"location":"api-reference/buffer/#zest_getbuffersize","title":"zest_GetBufferSize","text":"<pre><code>zest_size zest_GetBufferSize(zest_buffer buffer);\n</code></pre>"},{"location":"api-reference/buffer/#zest_freebuffer","title":"zest_FreeBuffer","text":"<p>Frees the buffer and makes the space used immediately available for reuse.</p> <pre><code>void zest_FreeBuffer(zest_buffer buffer);\n</code></pre>"},{"location":"api-reference/buffer/#uniform-buffers","title":"Uniform Buffers","text":""},{"location":"api-reference/buffer/#zest_createuniformbuffer","title":"zest_CreateUniformBuffer","text":"<p>Create per-frame uniform buffer. Internally this creates a buffer for each frame in flight (typically 2).</p> <p>Having a buffer for each frame in flight means you can safely write to each buffer whilst the other from the previous frame may still be accessed on the GPU.</p> <pre><code>zest_uniform_buffer_handle zest_CreateUniformBuffer(\n    zest_context context,\n    const char *name,\n    zest_size size\n);\n</code></pre>"},{"location":"api-reference/buffer/#zest_getuniformbufferdata","title":"zest_GetUniformBufferData","text":"<p>Get pointer to the mapped memory for the uniform buffer for the current frame in flight.</p> <pre><code>void* zest_GetUniformBufferData(zest_uniform_buffer ubo);\n</code></pre>"},{"location":"api-reference/buffer/#zest_getuniformbufferdescriptorindex","title":"zest_GetUniformBufferDescriptorIndex","text":"<p>Get the bindless index for the uniform buffer that you can pass onto your shaders for access there. It's important that you do this each frame as each frame in flight uniform buffer will have its own index that was acquired when the buffer was created.</p> <pre><code>zest_uint zest_GetUniformBufferDescriptorIndex(zest_uniform_buffer ubo);\n</code></pre>"},{"location":"api-reference/buffer/#data-access","title":"Data Access","text":""},{"location":"api-reference/buffer/#zest_bufferdata-zest_bufferdataend","title":"zest_BufferData / zest_BufferDataEnd","text":"<p>Map CPU-visible buffer. Gets the pointer to a mapped memory range in a CPU-visible buffer.</p> <pre><code>void* zest_BufferData(zest_buffer buffer);\nvoid* zest_BufferDataEnd(zest_buffer buffer);\n</code></pre>"},{"location":"api-reference/buffer/#see-also","title":"See Also","text":"<ul> <li>Buffers Concept</li> <li>Memory Concept</li> </ul>"},{"location":"api-reference/camera/","title":"Camera API","text":"<p>Zest provides some simple camera utilities and frustum culling. You can use these or create your own with your own libraries.</p>"},{"location":"api-reference/camera/#camera-creation","title":"Camera Creation","text":""},{"location":"api-reference/camera/#zest_createcamera","title":"zest_CreateCamera","text":"<pre><code>zest_camera_t zest_CreateCamera(void);\n</code></pre>"},{"location":"api-reference/camera/#camera-movement","title":"Camera Movement","text":"<p>Moves the camera in a specific direction based on the speed value you pass in to the function.</p>"},{"location":"api-reference/camera/#zest_cameramoveforward-zest_cameramovebackward","title":"zest_CameraMoveForward / zest_CameraMoveBackward","text":"<pre><code>void zest_CameraMoveForward(zest_camera_t *camera, float speed);\nvoid zest_CameraMoveBackward(zest_camera_t *camera, float speed);\n</code></pre>"},{"location":"api-reference/camera/#zest_cameramoveup-zest_cameramovedown","title":"zest_CameraMoveUp / zest_CameraMoveDown","text":"<pre><code>void zest_CameraMoveUp(zest_camera_t *camera, float speed);\nvoid zest_CameraMoveDown(zest_camera_t *camera, float speed);\n</code></pre>"},{"location":"api-reference/camera/#zest_camerastrafleft-zest_camerastrafright","title":"zest_CameraStrafLeft / zest_CameraStrafRight","text":"<pre><code>void zest_CameraStrafLeft(zest_camera_t *camera, float speed);\nvoid zest_CameraStrafRight(zest_camera_t *camera, float speed);\n</code></pre>"},{"location":"api-reference/camera/#camera-rotation","title":"Camera Rotation","text":""},{"location":"api-reference/camera/#zest_turncamera","title":"zest_TurnCamera","text":"<p>Turn the camera by a given amount of degrees (gets converted to radians internally) scaled by the sensitivity that you pass into the function.</p> <pre><code>void zest_TurnCamera(zest_camera_t *camera, float turn_x, float turn_y, float sensitivity);\n</code></pre>"},{"location":"api-reference/camera/#zest_cameraupdatefront","title":"zest_CameraUpdateFront","text":"<p>Recalculate front vector from yaw/pitch.</p> <pre><code>void zest_CameraUpdateFront(zest_camera_t *camera);\n</code></pre>"},{"location":"api-reference/camera/#camera-setup","title":"Camera Setup","text":""},{"location":"api-reference/camera/#zest_cameraposition","title":"zest_CameraPosition","text":"<p>Position the camera by passing in a float array of 3 elements.</p> <pre><code>void zest_CameraPosition(zest_camera_t *camera, float position[3]);\n</code></pre>"},{"location":"api-reference/camera/#zest_camerasetfov","title":"zest_CameraSetFoV","text":"<p>Sets the Field of View for the camera in degrees.</p> <pre><code>void zest_CameraSetFoV(zest_camera_t *camera, float fov);\n</code></pre>"},{"location":"api-reference/camera/#zest_camerasetpitch-zest_camerasetyaw","title":"zest_CameraSetPitch / zest_CameraSetYaw","text":"<p>Set the pitch and yaw of the camera in degrees.</p> <pre><code>void zest_CameraSetPitch(zest_camera_t *camera, float pitch);\nvoid zest_CameraSetYaw(zest_camera_t *camera, float yaw);\n</code></pre>"},{"location":"api-reference/camera/#screenworld-conversion","title":"Screen/World Conversion","text":""},{"location":"api-reference/camera/#zest_screenray","title":"zest_ScreenRay","text":"<p>Get ray from screen position. You pass in the screen pixel coordinates (xpos and ypos), the size of the screen and the view and projection matrices which you will often have stored in a uniform buffer.</p> <pre><code>zest_vec3 zest_ScreenRay(\n    float xpos, \n    float ypos, \n    float view_width, \n    float view_height, \n    zest_matrix4 *projection, \n    zest_matrix4 *view\n);\n</code></pre> <p>A typical usage might be something like:</p> <pre><code>zest_uniform_buffer uniform_buffer = zest_GetUniformBuffer(buffer_handle);\nuniform_buffer_data_t *data = (uniform_buffer_data_t *)zest_GetUniformBufferData(uniform_buffer);\nzest_vec3 camera_last_ray = zest_ScreenRay(x, y, zest_ScreenWidthf(context), zest_ScreenHeightf(context), &amp;data-&gt;proj, &amp;data-&gt;view);\n</code></pre>"},{"location":"api-reference/camera/#zest_worldtoscreen","title":"zest_WorldToScreen","text":"<pre><code>zest_vec2 zest_WorldToScreen(\n    const float point[3], \n    float view_width, \n    float view_height, \n    zest_matrix4* projection, \n    zest_matrix4* view\n);\n</code></pre>"},{"location":"api-reference/camera/#zest_worldtoscreenortho","title":"zest_WorldToScreenOrtho","text":"<p>Convert a 3D world position to 2D screen coordinates using an orthographic projection. Useful for 2D games or isometric views where perspective distortion is not desired.</p> <pre><code>zest_vec2 zest_WorldToScreenOrtho(\n    const float point[3], \n    float view_width, \n    float view_height, \n    zest_matrix4* projection, \n    zest_matrix4* view\n);\n</code></pre>"},{"location":"api-reference/camera/#frustum-culling","title":"Frustum Culling","text":""},{"location":"api-reference/camera/#zest_calculatefrustumplanes","title":"zest_CalculateFrustumPlanes","text":"<pre><code>void zest_CalculateFrustumPlanes(\n    zest_matrix4 *view_matrix, \n    zest_matrix4 *proj_matrix, \n    zest_vec4 planes[6]);\n</code></pre>"},{"location":"api-reference/camera/#zest_ispointinfrustum","title":"zest_IsPointInFrustum","text":"<pre><code>zest_bool zest_IsPointInFrustum(const zest_vec4 planes[6], const float point[3]);\n</code></pre>"},{"location":"api-reference/camera/#zest_issphereinfrustum","title":"zest_IsSphereInFrustum","text":"<pre><code>zest_bool zest_IsSphereInFrustum(const zest_vec4 planes[6], const float point[3], float radius);\n</code></pre>"},{"location":"api-reference/camera/#zest_rayintersectplane","title":"zest_RayIntersectPlane","text":"<pre><code>zest_bool zest_RayIntersectPlane(\n    zest_vec3 ray_origin, \n    zest_vec3 ray_direction, \n    zest_vec3 plane, \n    zest_vec3 plane_normal, \n    float *distance, \n    zest_vec3 *intersection\n);\n</code></pre>"},{"location":"api-reference/camera/#see-also","title":"See Also","text":"<ul> <li>Math API</li> </ul>"},{"location":"api-reference/commands/","title":"Command API","text":"<p>Frame graph render commands (<code>zest_cmd_*</code> functions). These functions are called within frame graph pass callbacks to record rendering commands that are executed on the GPU.</p>"},{"location":"api-reference/commands/#pipeline-binding","title":"Pipeline Binding","text":""},{"location":"api-reference/commands/#zest_cmd_bindpipeline","title":"zest_cmd_BindPipeline","text":"<p>Bind a graphics pipeline for subsequent draw calls.</p> <pre><code>void zest_cmd_BindPipeline(\n    const zest_command_list command_list,\n    zest_pipeline pipeline\n);\n</code></pre> <p>Description: Binds a pre-built graphics pipeline to the command list. All draw commands after this call will use the specified pipeline's shader programs, render states, and vertex input configuration.</p> <p>Typical Usage: Called at the start of a render pass before issuing draw commands, or when switching between different materials/shaders.</p> <pre><code>void my_render_callback(zest_command_list cmd, void *user_data) {\n    MyApp *app = (MyApp*)user_data;\n    zest_pipeline my_pipeline = zest_GetPipeline(app-&gt;my_pipeline_template, cmd);\n    zest_cmd_BindPipeline(cmd, my_pipeline);\n    zest_cmd_SetScreenSizedViewport(cmd, 0.0f, 1.0f);\n    // ... draw commands\n}\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_bindcomputepipeline","title":"zest_cmd_BindComputePipeline","text":"<p>Bind a compute pipeline for compute dispatch calls.</p> <pre><code>void zest_cmd_BindComputePipeline(\n    const zest_command_list command_list,\n    zest_compute compute\n);\n</code></pre> <p>Description: Binds a compute pipeline to the command list. All subsequent <code>zest_cmd_DispatchCompute</code> calls will use this pipeline's compute shader.</p> <p>Typical Usage: Called before dispatching compute work, such as particle simulation or image processing.</p> <pre><code>void my_compute_callback(zest_command_list cmd, void *user_data) {\n    zest_cmd_BindComputePipeline(cmd, particle_compute);\n    zest_cmd_DispatchCompute(cmd, particle_count / 256, 1, 1);\n}\n</code></pre>"},{"location":"api-reference/commands/#viewport-and-scissor","title":"Viewport and Scissor","text":""},{"location":"api-reference/commands/#zest_cmd_setscreensizedviewport","title":"zest_cmd_SetScreenSizedViewport","text":"<p>Set viewport and scissor to match the swapchain dimensions.</p> <pre><code>void zest_cmd_SetScreenSizedViewport(\n    const zest_command_list command_list,\n    float min_depth,\n    float max_depth\n);\n</code></pre> <p>Description: Convenience function that sets both the viewport and scissor rectangle to cover the entire swapchain. The depth range is specified by <code>min_depth</code> and <code>max_depth</code> (typically 0.0 to 1.0).</p> <p>Typical Usage: Most common viewport setup for full-screen rendering passes.</p> <pre><code>void render_scene(zest_command_list cmd, void *user_data) {\n    ...\n    zest_cmd_BindPipeline(cmd, scene_pipeline);\n    zest_cmd_SetScreenSizedViewport(cmd, 0.0f, 1.0f);\n    // Draw scene geometry...\n}\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_viewport","title":"zest_cmd_ViewPort","text":"<p>Set a custom viewport.</p> <pre><code>void zest_cmd_ViewPort(\n    const zest_command_list command_list,\n    zest_viewport_t *viewport\n);\n</code></pre> <p>Description: Sets the viewport transformation that maps normalized device coordinates to framebuffer coordinates. Use <code>zest_CreateViewport()</code> to create the viewport struct.</p> <p>Typical Usage: Split-screen rendering, picture-in-picture views, or rendering to a sub-region of the framebuffer.</p> <pre><code>zest_viewport_t viewport = zest_CreateViewport(0, 0, 800, 600, 0.0f, 1.0f);\nzest_cmd_ViewPort(cmd, &amp;viewport);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_scissor","title":"zest_cmd_Scissor","text":"<p>Set the scissor rectangle for pixel clipping.</p> <pre><code>void zest_cmd_Scissor(\n    const zest_command_list command_list,\n    zest_scissor_rect_t *scissor\n);\n</code></pre> <p>Description: Defines the rectangular region where pixels can be written. Pixels outside the scissor rectangle are discarded. Use <code>zest_CreateRect2D()</code> to create the scissor struct.</p> <p>Typical Usage: UI clipping, rendering within masked regions, or optimizing rendering to visible areas only.</p> <pre><code>zest_scissor_rect_t scissor = zest_CreateRect2D(400, 300, 100, 50);\nzest_cmd_Scissor(cmd, &amp;scissor);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_layerviewport","title":"zest_cmd_LayerViewport","text":"<p>Set viewport and scissor from a layer's configuration.</p> <pre><code>void zest_cmd_LayerViewport(\n    const zest_command_list command_list,\n    zest_layer layer\n);\n</code></pre> <p>Description: Convenience function that sets both viewport and scissor from the layer's stored viewport and scissor settings. Useful when rendering layer content with custom viewports.</p> <p>Typical Usage: Rendering layers with specific viewport configurations, such as UI panels or sub-windows.</p>"},{"location":"api-reference/commands/#zest_cmd_clip","title":"zest_cmd_Clip","text":"<p>Set viewport and scissor in a single call with explicit parameters.</p> <pre><code>void zest_cmd_Clip(\n    const zest_command_list command_list,\n    float x,\n    float y,\n    float width,\n    float height,\n    float minDepth,\n    float maxDepth\n);\n</code></pre> <p>Description: Combined viewport and scissor command using explicit float parameters. Sets both the viewport transformation and scissor clipping to the same rectangular region.</p> <p>Typical Usage: Quick setup for rendering to a specific screen region without creating separate viewport/scissor structs.</p> <pre><code>// Render to the bottom-right quadrant\nzest_cmd_Clip(cmd, 400, 300, 400, 300, 0.0f, 1.0f);\n</code></pre>"},{"location":"api-reference/commands/#descriptor-sets","title":"Descriptor Sets","text":""},{"location":"api-reference/commands/#zest_cmd_binddescriptorsets","title":"zest_cmd_BindDescriptorSets","text":"<p>Bind descriptor sets for shader resource access.</p> <pre><code>void zest_cmd_BindDescriptorSets(\n    const zest_command_list command_list,\n    zest_pipeline_bind_point bind_point,\n    zest_pipeline_layout layout,\n    zest_descriptor_set *sets,\n    zest_uint set_count,\n    zest_uint first_set\n);\n</code></pre> <p>Description: Binds descriptor sets containing shader resources (textures, buffers, samplers). The global bindless descriptor set is bound automatically at the start of each command buffer and so you don't need to use this command; at some point there maybe the feature for custom descriptor sets but the global set should cover most things.</p> <p>Parameters: - <code>bind_point</code>: <code>zest_bind_point_graphics</code> or <code>zest_bind_point_compute</code> - <code>layout</code>: The pipeline layout that matches the descriptor set layout - <code>sets</code>: Array of descriptor sets to bind - <code>set_count</code>: Number of sets in the array - <code>first_set</code>: Starting set index in the pipeline layout</p> <p>Typical Usage: Binding uniform buffer descriptor sets for per-object or per-frame data.</p>"},{"location":"api-reference/commands/#buffer-binding","title":"Buffer Binding","text":""},{"location":"api-reference/commands/#zest_cmd_bindvertexbuffer","title":"zest_cmd_BindVertexBuffer","text":"<p>Bind a vertex buffer for drawing.</p> <pre><code>void zest_cmd_BindVertexBuffer(\n    const zest_command_list command_list,\n    zest_uint first_binding,\n    zest_uint binding_count,\n    zest_buffer buffer\n);\n</code></pre> <p>Description: Binds a vertex buffer to one or more binding points for subsequent draw calls. The vertex data format is determined by the bound pipeline's vertex input description.</p> <p>Parameters: - <code>first_binding</code>: The first vertex input binding to update - <code>binding_count</code>: Number of consecutive bindings to update - <code>buffer</code>: The vertex buffer containing vertex data</p> <p>Typical Usage: Binding custom vertex data for mesh rendering.</p> <pre><code>zest_cmd_BindPipeline(cmd, my_pipeline);\nzest_cmd_BindVertexBuffer(cmd, 0, 1, my_vertex_buffer);\nzest_cmd_Draw(cmd, vertex_count, 1, 0, 0);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_bindindexbuffer","title":"zest_cmd_BindIndexBuffer","text":"<p>Bind an index buffer for indexed drawing.</p> <pre><code>void zest_cmd_BindIndexBuffer(\n    const zest_command_list command_list,\n    zest_buffer buffer\n);\n</code></pre> <p>Description: Binds an index buffer for subsequent indexed draw calls. The buffer should contain 32-bit unsigned integer indices.</p> <p>Typical Usage: Binding custom index data for indexed mesh rendering.</p> <pre><code>zest_cmd_BindVertexBuffer(cmd, 0, 1, my_vertex_buffer);\nzest_cmd_BindIndexBuffer(cmd, my_index_buffer);\nzest_cmd_DrawIndexed(cmd, index_count, 1, 0, 0, 0);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_bindmeshvertexbuffer","title":"zest_cmd_BindMeshVertexBuffer","text":"<p>Bind a layer's vertex buffer for mesh drawing.</p> <pre><code>void zest_cmd_BindMeshVertexBuffer(\n    const zest_command_list command_list,\n    zest_layer layer\n);\n</code></pre> <p>Description: Binds the vertex buffer associated with a layer. Used internally by the layer system and for custom layer rendering.</p>"},{"location":"api-reference/commands/#zest_cmd_bindmeshindexbuffer","title":"zest_cmd_BindMeshIndexBuffer","text":"<p>Bind a layer's index buffer for mesh drawing.</p> <pre><code>void zest_cmd_BindMeshIndexBuffer(\n    const zest_command_list command_list,\n    zest_layer layer\n);\n</code></pre> <p>Description: Binds the index buffer associated with a layer. Used internally by the layer system and for custom layer rendering.</p>"},{"location":"api-reference/commands/#drawing","title":"Drawing","text":""},{"location":"api-reference/commands/#zest_cmd_draw","title":"zest_cmd_Draw","text":"<p>Issue a non-indexed draw call.</p> <pre><code>void zest_cmd_Draw(\n    const zest_command_list command_list,\n    zest_uint vertex_count,\n    zest_uint instance_count,\n    zest_uint first_vertex,\n    zest_uint first_instance\n);\n</code></pre> <p>Description: Records a non-indexed draw command. Draws <code>vertex_count</code> vertices starting from <code>first_vertex</code>, repeated <code>instance_count</code> times for instanced rendering.</p> <p>Parameters: - <code>vertex_count</code>: Number of vertices to draw - <code>instance_count</code>: Number of instances to draw (1 for non-instanced) - <code>first_vertex</code>: Offset to the first vertex in the vertex buffer - <code>first_instance</code>: Instance ID of the first instance (for <code>gl_InstanceIndex</code>)</p> <p>Typical Usage: Drawing simple geometry without index buffers, such as full-screen triangles or particle quads.</p> <pre><code>// Draw a full-screen triangle (3 vertices, generated in shader)\nzest_cmd_BindPipeline(cmd, fullscreen_pipeline);\nzest_cmd_Draw(cmd, 3, 1, 0, 0);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_drawindexed","title":"zest_cmd_DrawIndexed","text":"<p>Issue an indexed draw call.</p> <pre><code>void zest_cmd_DrawIndexed(\n    const zest_command_list command_list,\n    zest_uint index_count,\n    zest_uint instance_count,\n    zest_uint first_index,\n    int32_t vertex_offset,\n    zest_uint first_instance\n);\n</code></pre> <p>Description: Records an indexed draw command. Reads <code>index_count</code> indices from the bound index buffer, using them to fetch vertices from the vertex buffer. Supports instancing and vertex offset.</p> <p>Parameters: - <code>index_count</code>: Number of indices to read - <code>instance_count</code>: Number of instances to draw - <code>first_index</code>: Offset into the index buffer - <code>vertex_offset</code>: Value added to each index before fetching the vertex - <code>first_instance</code>: Instance ID of the first instance</p> <p>Typical Usage: Drawing meshes with shared vertices, such as 3D models or UI quads.</p> <pre><code>zest_cmd_BindVertexBuffer(cmd, 0, 1, mesh_vertices);\nzest_cmd_BindIndexBuffer(cmd, mesh_indices);\nzest_cmd_DrawIndexed(cmd, mesh-&gt;index_count, 1, 0, 0, 0);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_drawlayerinstruction","title":"zest_cmd_DrawLayerInstruction","text":"<p>Draw using a layer instruction struct.</p> <pre><code>void zest_cmd_DrawLayerInstruction(\n    const zest_command_list command_list,\n    zest_uint vertex_count,\n    zest_layer_instruction_t *instruction\n);\n</code></pre> <p>Description: Specialized draw command that uses a <code>zest_layer_instruction_t</code> to configure the draw call. Used internally by the layer system for batched rendering.</p> <p>Typical Usage: Used by Zest's internal layer rendering system; rarely called directly.</p>"},{"location":"api-reference/commands/#push-constants","title":"Push Constants","text":""},{"location":"api-reference/commands/#zest_cmd_sendpushconstants","title":"zest_cmd_SendPushConstants","text":"<p>Send push constant data to shaders.</p> <pre><code>void zest_cmd_SendPushConstants(\n    const zest_command_list command_list,\n    void *data,\n    zest_uint size\n);\n</code></pre> <p>Description: Uploads push constant data to the currently bound pipeline. Push constants provide fast, small data updates without descriptor sets\u2014ideal for per-draw data like bindless descriptor array indexes.</p> <p>Parameters: - <code>data</code>: Pointer to the push constant data (must match pipeline's push constant layout) - <code>size</code>: Size of the data in bytes</p> <p>Typical Usage: Sending per-object transform matrices or material IDs.</p> <pre><code>struct PushConstants {\n    float model_matrix[16];\n    uint32_t texture_index;\n};\n\nPushConstants pc = { /* ... */ };\nzest_cmd_SendPushConstants(cmd, &amp;pc, sizeof(pc));\nzest_cmd_Draw(cmd, vertex_count, 1, 0, 0);\n</code></pre>"},{"location":"api-reference/commands/#depth-bias","title":"Depth Bias","text":""},{"location":"api-reference/commands/#zest_cmd_setdepthbias","title":"zest_cmd_SetDepthBias","text":"<p>Set depth bias parameters for subsequent draw calls.</p> <pre><code>void zest_cmd_SetDepthBias(\n    const zest_command_list command_list,\n    float factor,\n    float clamp,\n    float slope\n);\n</code></pre> <p>Description: Sets dynamic depth bias parameters when depth bias is enabled in the pipeline. Depth bias offsets the depth value to prevent z-fighting in techniques like shadow mapping or decals.</p> <p>Parameters: - <code>factor</code>: Constant depth offset value - <code>clamp</code>: Maximum (or minimum) depth bias value - <code>slope</code>: Slope-scaled depth bias factor</p> <p>Typical Usage: Shadow map rendering to prevent shadow acne.</p> <pre><code>zest_cmd_BindPipeline(cmd, shadow_pipeline);\nzest_cmd_SetDepthBias(cmd, 1.0f, 0.0f, 1.5f);\n// Draw shadow casters...\n</code></pre>"},{"location":"api-reference/commands/#compute","title":"Compute","text":""},{"location":"api-reference/commands/#zest_cmd_dispatchcompute","title":"zest_cmd_DispatchCompute","text":"<p>Dispatch compute shader work groups.</p> <pre><code>void zest_cmd_DispatchCompute(\n    const zest_command_list command_list,\n    zest_uint group_count_x,\n    zest_uint group_count_y,\n    zest_uint group_count_z\n);\n</code></pre> <p>Description: Dispatches compute work with the specified number of work groups in each dimension. The total number of shader invocations is <code>group_count * local_size</code> (where <code>local_size</code> is defined in the compute shader).</p> <p>Typical Usage: GPU-based particle simulation, image processing, or physics calculations.</p> <pre><code>void compute_particles(zest_command_list cmd, void *user_data) {\n    zest_cmd_BindComputePipeline(cmd, particle_update);\n    // Dispatch one group per 256 particles (assuming local_size_x = 256)\n    zest_uint groups = (particle_count + 255) / 256;\n    zest_cmd_DispatchCompute(cmd, groups, 1, 1);\n}\n</code></pre>"},{"location":"api-reference/commands/#buffer-operations","title":"Buffer Operations","text":""},{"location":"api-reference/commands/#zest_cmd_copybuffer","title":"zest_cmd_CopyBuffer","text":"<p>Copy data between buffers.</p> <pre><code>void zest_cmd_CopyBuffer(\n    const zest_command_list command_list,\n    zest_buffer src_buffer,\n    zest_buffer dst_buffer,\n    zest_size size\n);\n</code></pre> <p>Description: Records a GPU-side buffer copy command. Copies <code>size</code> bytes from the source buffer to the destination buffer. Both buffers must have appropriate usage flags for transfer operations.</p> <p>Typical Usage: Copying staging buffer data to device-local buffers, or copying between GPU buffers. Generally done during a frame graph transfer pass.</p> <pre><code>zest_cmd_CopyBuffer(cmd, staging_buffer, device_buffer, data_size);\n</code></pre>"},{"location":"api-reference/commands/#zest_cmd_uploadbuffer","title":"zest_cmd_UploadBuffer","text":"<p>Upload multiple buffer regions using an uploader struct.</p> <pre><code>zest_bool zest_cmd_UploadBuffer(\n    const zest_command_list command_list,\n    zest_buffer_uploader_t *uploader\n);\n</code></pre> <p>Description: Records buffer copy commands for all regions registered with the uploader. Returns <code>ZEST_TRUE</code> if copies were recorded, <code>ZEST_FALSE</code> if the uploader had no pending copies. Use <code>zest_AddCopyCommand()</code> to add copy regions to the uploader.</p> <p>Typical Usage: Batching multiple buffer uploads in a single command, used internally by the layer system for vertex/index data uploads.</p> <pre><code>zest_buffer_uploader_t uploader = {0};\nzest_AddCopyCommand(context, &amp;uploader, staging, device, size1);\nzest_AddCopyCommand(context, &amp;uploader, staging, device, size2);\nzest_cmd_UploadBuffer(cmd, &amp;uploader);\n</code></pre>"},{"location":"api-reference/commands/#image-operations","title":"Image Operations","text":""},{"location":"api-reference/commands/#zest_cmd_imageclear","title":"zest_cmd_ImageClear","text":"<p>Clear an image to its default clear color.</p> <pre><code>zest_bool zest_cmd_ImageClear(\n    const zest_command_list command_list,\n    zest_image image\n);\n</code></pre> <p>Description: Clears the specified image using the clear color stored in the image's configuration. Returns <code>ZEST_TRUE</code> on success.</p> <p>Typical Usage: Clearing render targets or storage images before use.</p>"},{"location":"api-reference/commands/#zest_cmd_blitimagemip","title":"zest_cmd_BlitImageMip","text":"<p>Blit (copy with scaling/filtering) between mip levels of frame graph images.</p> <pre><code>void zest_cmd_BlitImageMip(\n    const zest_command_list command_list,\n    zest_resource_node src,\n    zest_resource_node dst,\n    zest_uint mip_to_blit,\n    zest_pipeline_stage_flags pipeline_stage\n);\n</code></pre> <p>Description: Blits a mip level from the source image resource to the same mip level in the destination image. Both images must have the same dimensions and mip count. The source image is sampled with linear filtering to produce the destination.</p> <p>Parameters: - <code>src</code>: Source image resource node from the frame graph - <code>dst</code>: Destination image resource node from the frame graph - <code>mip_to_blit</code>: The mip level index to blit - <code>pipeline_stage</code>: Pipeline stage for synchronization</p> <p>Typical Usage: Generating mipmaps, downsampling for bloom, or copying between render targets.</p>"},{"location":"api-reference/commands/#zest_cmd_copyimagemip","title":"zest_cmd_CopyImageMip","text":"<p>Copy a mip level between frame graph images (no filtering).</p> <pre><code>void zest_cmd_CopyImageMip(\n    const zest_command_list command_list,\n    zest_resource_node src,\n    zest_resource_node dst,\n    zest_uint mip_to_copy,\n    zest_pipeline_stage_flags pipeline_stage\n);\n</code></pre> <p>Description: Copies a mip level from the source image to the destination image without any filtering or scaling. Both images must have identical dimensions, formats, and mip counts. Source must have <code>zest_image_flag_transfer_src</code>, destination must have <code>zest_image_flag_transfer_dst</code>.</p> <p>Parameters: - <code>src</code>: Source image resource node - <code>dst</code>: Destination image resource node - <code>mip_to_copy</code>: The mip level index to copy - <code>pipeline_stage</code>: Pipeline stage for synchronization</p> <p>Typical Usage: Copying render results between images, or backing up image contents.</p>"},{"location":"api-reference/commands/#barriers","title":"Barriers","text":""},{"location":"api-reference/commands/#zest_cmd_insertcomputeimagebarrier","title":"zest_cmd_InsertComputeImageBarrier","text":"<p>Insert a memory barrier for compute shader image access.</p> <pre><code>void zest_cmd_InsertComputeImageBarrier(\n    const zest_command_list command_list,\n    zest_resource_node resource,\n    zest_uint base_mip\n);\n</code></pre> <p>Description: Inserts a pipeline barrier to synchronize compute shader writes to an image with subsequent reads. Use this when a compute shader writes to an image that will be read later in the same pass.</p> <p>Parameters: - <code>resource</code>: The image resource node requiring synchronization - <code>base_mip</code>: The base mip level for the barrier</p> <p>Typical Usage: Synchronizing between compute passes that read/write the same image.</p> <pre><code>// First compute pass writes to image\nzest_cmd_BindComputePipeline(cmd, write_shader);\nzest_cmd_DispatchCompute(cmd, groups_x, groups_y, 1);\n\n// Barrier to ensure writes complete before reads\nzest_cmd_InsertComputeImageBarrier(cmd, my_image_resource, 0);\n\n// Second compute pass reads from image\nzest_cmd_BindComputePipeline(cmd, read_shader);\nzest_cmd_DispatchCompute(cmd, groups_x, groups_y, 1);\n</code></pre>"},{"location":"api-reference/commands/#see-also","title":"See Also","text":"<ul> <li>Immediate API - One-off commands</li> <li>Frame Graph Concept</li> <li>Buffer Management - Creating and managing buffers</li> <li>Pipeline API - Creating graphics and compute pipelines</li> </ul>"},{"location":"api-reference/compute/","title":"Compute API","text":"<p>Functions for creating, managing, and executing compute shaders. Compute shaders run on the GPU and are ideal for parallel data processing tasks like particle simulations, image processing, physics calculations, and general-purpose GPU (GPGPU) workloads.</p>"},{"location":"api-reference/compute/#creation","title":"Creation","text":""},{"location":"api-reference/compute/#zest_createcompute","title":"zest_CreateCompute","text":"<p>Creates a compute pipeline from a compiled compute shader. The returned handle is used to reference the compute object when building frame graphs and executing dispatches.</p> <pre><code>zest_compute_handle zest_CreateCompute(\n    zest_device device,\n    const char *name,\n    zest_shader_handle shader\n);\n</code></pre> <p>Parameters: - <code>device</code> - The Zest device that will own the compute pipeline - <code>name</code> - A debug name for identifying the compute object - <code>shader</code> - Handle to a compiled compute shader (created via shader compilation)</p> <p>Returns: A handle to the created compute pipeline.</p> <p>Example: <pre><code>// Load and create a compute shader\nzest_shader_handle comp_shader = zest_slang_CreateShader(\n    device, \"shaders/particles.slang\", \"particles.spv\",\n    \"computeMain\", zest_compute_shader, true\n);\n\n// Create the compute pipeline\nzest_compute_handle compute = zest_CreateCompute(\n    device, \"Particle Simulation\", comp_shader\n);\n</code></pre></p>"},{"location":"api-reference/compute/#zest_getcompute","title":"zest_GetCompute","text":"<p>Retrieves the compute pointer from a handle. Use this to pass the compute object into command recording functions. The returned pointer is only valid while the compute resource has not been freed.</p> <pre><code>zest_compute zest_GetCompute(zest_compute_handle compute_handle);\n</code></pre> <p>Parameters: - <code>compute_handle</code> - Handle obtained from <code>zest_CreateCompute</code></p> <p>Returns: Pointer to the compute object.</p> <p>Example: <pre><code>// Get the compute pointer for binding during command recording\nzest_compute compute = zest_GetCompute(app-&gt;compute_handle);\nzest_cmd_BindComputePipeline(command_list, compute);\n</code></pre></p>"},{"location":"api-reference/compute/#zest_freecompute","title":"zest_FreeCompute","text":"<p>Frees a compute pipeline and all associated resources. The free operation is deferred until the GPU is no longer using the resource.</p> <pre><code>void zest_FreeCompute(zest_compute_handle compute_handle);\n</code></pre> <p>Parameters: - <code>compute_handle</code> - Handle to the compute pipeline to free</p> <p>Example: <pre><code>// Clean up compute resources on shutdown\nzest_FreeCompute(app-&gt;compute_handle);\n</code></pre></p>"},{"location":"api-reference/compute/#usage-in-frame-graph","title":"Usage in Frame Graph","text":"<p>Compute passes are added to a frame graph using <code>zest_BeginComputePass</code>. The frame graph compiler automatically handles synchronization barriers between compute and graphics passes.</p> <pre><code>zest_compute compute = zest_GetCompute(compute_handle);\nzest_BeginComputePass(compute, \"Particle Update\"); {\n    // Connect buffer as both input and output (read-modify-write)\n    zest_ConnectInput(particle_buffer);\n    zest_ConnectOutput(particle_buffer);\n    zest_SetPassTask(ComputeCallback, user_data);\n    zest_EndPass();\n}\n</code></pre> <p>Frame graph functions: - <code>zest_BeginComputePass(compute, name)</code> - Starts a compute pass definition - <code>zest_ConnectInput(resource)</code> - Declares a resource as read input - <code>zest_ConnectOutput(resource)</code> - Declares a resource as write output - <code>zest_SetPassTask(callback, user_data)</code> - Sets the execution callback - <code>zest_EndPass()</code> - Ends the pass definition</p>"},{"location":"api-reference/compute/#compute-commands","title":"Compute Commands","text":""},{"location":"api-reference/compute/#zest_cmd_bindcomputepipeline","title":"zest_cmd_BindComputePipeline","text":"<p>Binds a compute pipeline for subsequent dispatch commands. Must be called within a compute pass callback before dispatching.</p> <pre><code>void zest_cmd_BindComputePipeline(\n    const zest_command_list command_list,\n    zest_compute compute\n);\n</code></pre> <p>Parameters: - <code>command_list</code> - The command list from the execution callback - <code>compute</code> - Compute object obtained from <code>zest_GetCompute</code></p> <p>Example: <pre><code>void MyComputeCallback(zest_command_list command_list, void *user_data) {\n    app_t *app = (app_t*)user_data;\n    zest_compute compute = zest_GetCompute(app-&gt;compute_handle);\n    zest_cmd_BindComputePipeline(command_list, compute);\n    // ... dispatch commands follow\n}\n</code></pre></p>"},{"location":"api-reference/compute/#zest_cmd_dispatchcompute","title":"zest_cmd_DispatchCompute","text":"<p>Dispatches compute work groups for execution. The total number of shader invocations equals <code>group_count_x * group_count_y * group_count_z * local_size</code> (where local_size is defined in the shader).</p> <pre><code>void zest_cmd_DispatchCompute(\n    const zest_command_list command_list,\n    zest_uint group_count_x,\n    zest_uint group_count_y,\n    zest_uint group_count_z\n);\n</code></pre> <p>Parameters: - <code>command_list</code> - The command list from the execution callback - <code>group_count_x</code> - Number of work groups in the X dimension - <code>group_count_y</code> - Number of work groups in the Y dimension - <code>group_count_z</code> - Number of work groups in the Z dimension</p> <p>Example: <pre><code>// Dispatch enough groups to cover all particles\n// Shader uses local_size of 256, so divide particle count by 256\nzest_uint particle_count = 256 * 1024;\nzest_cmd_DispatchCompute(command_list, particle_count / 256, 1, 1);\n\n// For a 2D image processing shader with 16x16 local size\nzest_uint image_width = 1920;\nzest_uint image_height = 1080;\nzest_cmd_DispatchCompute(\n    command_list,\n    (image_width + 15) / 16,   // Round up to cover all pixels\n    (image_height + 15) / 16,\n    1\n);\n</code></pre></p>"},{"location":"api-reference/compute/#complete-example","title":"Complete Example","text":"<p>A typical compute shader workflow for a particle simulation:</p> <pre><code>// 1. Create the compute pipeline (during initialization)\nzest_shader_handle shader = zest_slang_CreateShader(\n    device, \"shaders/particle.slang\", \"particle_comp.spv\",\n    \"computeMain\", zest_compute_shader, true\n);\napp-&gt;compute = zest_CreateCompute(device, \"Particles\", shader, app);\n\n// 2. Create a storage buffer for particle data\nzest_buffer_info_t buffer_info = zest_CreateBufferInfo(\n    zest_buffer_type_vertex_storage, zest_memory_usage_gpu_only\n);\napp-&gt;particle_buffer = zest_CreateBuffer(device, buffer_size, &amp;buffer_info);\napp-&gt;particle_buffer_index = zest_AcquireStorageBufferIndex(\n    device, app-&gt;particle_buffer\n);\n\n// 3. Define the frame graph with compute and render passes\nif (zest_BeginFrameGraph(context, \"Particle Demo\", &amp;cache_key)) {\n    zest_resource_node particles = zest_ImportBufferResource(\n        \"particles\", app-&gt;particle_buffer, 0\n    );\n    zest_resource_node swapchain = zest_ImportSwapchainResource();\n\n    // Compute pass updates particle positions\n    zest_compute compute = zest_GetCompute(app-&gt;compute);\n    zest_BeginComputePass(compute, \"Update Particles\"); {\n        zest_ConnectInput(particles);\n        zest_ConnectOutput(particles);\n        zest_SetPassTask(UpdateParticlesCallback, app);\n        zest_EndPass();\n    }\n\n    // Render pass draws particles as point sprites\n    zest_BeginRenderPass(\"Draw Particles\"); {\n        zest_ConnectInput(particles);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(DrawParticlesCallback, app);\n        zest_EndPass();\n    }\n\n    frame_graph = zest_EndFrameGraph();\n}\n\n// 4. Compute callback records dispatch commands\nvoid UpdateParticlesCallback(zest_command_list command_list, void *user_data) {\n    app_t *app = (app_t*)user_data;\n\n    zest_compute compute = zest_GetCompute(app-&gt;compute);\n    zest_cmd_BindComputePipeline(command_list, compute);\n\n    // Send buffer index and simulation parameters via push constants\n    push_constants_t push = {\n        .buffer_index = app-&gt;particle_buffer_index,\n        .delta_time = app-&gt;frame_time\n    };\n    zest_cmd_SendPushConstants(command_list, &amp;push, sizeof(push));\n\n    // Dispatch: 256K particles with 256 threads per group\n    zest_cmd_DispatchCompute(command_list, (256 * 1024) / 256, 1, 1);\n}\n</code></pre>"},{"location":"api-reference/compute/#see-also","title":"See Also","text":"<ul> <li>Compute Tutorial</li> <li>Frame Graph Concept</li> </ul>"},{"location":"api-reference/context/","title":"Context API","text":"<p>Functions for context (window/swapchain) management. A context represents a single window and its associated swapchain, frame resources, and linear allocators. One device can serve multiple contexts for multi-window applications.</p> <p>Generally speaking, if you're creating a game or app that opens a single window then you'll only ever use a single context, but there is scope for having multiple contexts such as using Dear ImGui and being able to drag imgui windows outside of the main window. This will create a new context to draw just that window.</p>"},{"location":"api-reference/context/#creation","title":"Creation","text":""},{"location":"api-reference/context/#zest_createcontextinfo","title":"zest_CreateContextInfo","text":"<p>Creates a default context configuration struct with sensible defaults.</p> <pre><code>zest_create_context_info_t zest_CreateContextInfo();\n</code></pre> <p>Use this to get a pre-configured struct, then modify specific fields as needed before passing to <code>zest_CreateContext</code>. The struct contains settings for window title, dimensions, vsync, frame allocator sizes, and more.</p> <p>Example: <pre><code>zest_create_context_info_t create_info = zest_CreateContextInfo();\nZEST__FLAG(create_info.flags, zest_context_init_flag_enable_vsync);  // Enable vsync\ncreate_info.screen_width = 1920;\ncreate_info.screen_height = 1080;\n</code></pre></p>"},{"location":"api-reference/context/#zest_createcontext","title":"zest_CreateContext","text":"<p>Creates a context for a window, initializing the swapchain and frame resources.</p> <pre><code>zest_context zest_CreateContext(\n    zest_device device,\n    zest_window_data_t *window_data,\n    zest_create_context_info_t *info\n);\n</code></pre> <p>Call this after creating a device and window. The window data is typically obtained from helper functions like <code>zest_implsdl2_CreateWindow</code> or <code>zest_implglfw_CreateWindow</code> but you can also create your own window data if you're using any other library or native OS commands to open a window.</p> <p>Example: <pre><code>zest_window_data_t window = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window, false);\nzest_create_context_info_t info = zest_CreateContextInfo();\nzest_context context = zest_CreateContext(device, &amp;window, &amp;info);\n</code></pre></p>"},{"location":"api-reference/context/#frame-management","title":"Frame Management","text":""},{"location":"api-reference/context/#zest_beginframe","title":"zest_BeginFrame","text":"<p>Begins a new frame by acquiring a swapchain image.</p> <pre><code>zest_bool zest_BeginFrame(zest_context context);\n</code></pre> <p>Returns <code>ZEST_FALSE</code> if the window is minimized or the swapchain image couldn't be acquired (in which case you should skip rendering). Always pair with <code>zest_EndFrame</code> when this returns true.</p> <p>This function handles frame synchronization by waiting on the semaphore for the oldest frame in flight (based on <code>ZEST_MAX_FIF</code>) before proceeding. It also advances the current frame-in-flight index, which determines which set of per-frame resources (uniform buffers, command buffers, etc.) are used.</p> <p>Important: Any operations that depend on the current frame-in-flight index must be called between <code>zest_BeginFrame</code> and <code>zest_EndFrame</code>. This includes: - Updating uniform buffers - Updating layers and mesh layers - Recording command buffers - Any per-frame resource updates</p> <p>Calling these functions outside of a begin/end frame pair will use an incorrect frame index and lead to synchronization issues or other strange behaviour like shaders reading from and incorrect buffer.</p> <p>Example: <pre><code>if (zest_BeginFrame(context)) {\n    // Safe to update per-frame resources here\n    UpdateUniformBuffer(my_uniform_buffer);\n    zest_UpdateLayer(my_layer);\n\n    // Build and execute frame graph\n    zest_QueueFrameGraphForExecution(context, frame_graph);\n    zest_EndFrame(context);\n}\n</code></pre></p>"},{"location":"api-reference/context/#zest_endframe","title":"zest_EndFrame","text":"<p>Ends the frame, submits queued command buffers, and presents to the window.</p> <pre><code>void zest_EndFrame(zest_context context);\n</code></pre> <p>Executes any queued frame graphs and presents the rendered image to the screen. Must be called after <code>zest_BeginFrame</code> returns true.</p> <p>Example: <pre><code>if (zest_BeginFrame(context)) {\n    zest_QueueFrameGraphForExecution(context, frame_graph);\n    zest_EndFrame(context);\n}\n</code></pre></p>"},{"location":"api-reference/context/#window-queries","title":"Window Queries","text":""},{"location":"api-reference/context/#zest_screenwidth-zest_screenheight","title":"zest_ScreenWidth / zest_ScreenHeight","text":"<p>Gets the current window/swapchain dimensions in pixels.</p> <pre><code>zest_uint zest_ScreenWidth(zest_context context);\nzest_uint zest_ScreenHeight(zest_context context);\nfloat zest_ScreenWidthf(zest_context context);\nfloat zest_ScreenHeightf(zest_context context);\n</code></pre> <p>The <code>f</code> variants return floats, useful for viewport calculations and shader uniforms where float arithmetic is needed.</p> <p>Example: <pre><code>// Set up orthographic projection for 2D rendering\nfloat proj_x = 2.0f / zest_ScreenWidthf(context);\nfloat proj_y = 2.0f / zest_ScreenHeightf(context);\n\n// Calculate aspect ratio\nfloat aspect = zest_ScreenWidthf(context) / zest_ScreenHeightf(context);\n</code></pre></p>"},{"location":"api-reference/context/#zest_window","title":"zest_Window","text":"<p>Gets the native window handle (SDL2, GLFW, etc.).</p> <pre><code>void* zest_Window(zest_context context);\n</code></pre> <p>Cast the result to your windowing library's handle type. Useful for input handling, window state queries, or platform-specific operations.</p> <p>Example: <pre><code>// With SDL2\nSDL_Window *window = (SDL_Window*)zest_Window(context);\n</code></pre></p>"},{"location":"api-reference/context/#zest_dpiscale","title":"zest_DPIScale","text":"<p>Gets the DPI scale factor for the context's window.</p> <pre><code>float zest_DPIScale(zest_context context);\n</code></pre> <p>Returns the ratio of physical pixels to logical pixels. Use this to scale UI elements appropriately on high-DPI displays (Retina, 4K monitors, etc.).</p> <p>Example: <pre><code>float scale = zest_DPIScale(context);\nfloat font_size = 16.0f * scale;  // Scale font for high-DPI\n</code></pre></p>"},{"location":"api-reference/context/#swapchain","title":"Swapchain","text":""},{"location":"api-reference/context/#zest_getswapchain","title":"zest_GetSwapchain","text":"<p>Gets the swapchain handle for advanced operations.</p> <pre><code>zest_swapchain zest_GetSwapchain(zest_context context);\n</code></pre> <p>Returns the underlying swapchain object. Useful when you need to query swapchain properties like format or create compatible render targets.</p> <p>Example: <pre><code>zest_swapchain swapchain = zest_GetSwapchain(context);\nzest_format format = zest_GetSwapchainFormat(swapchain);\n</code></pre></p>"},{"location":"api-reference/context/#zest_setswapchainclearcolor","title":"zest_SetSwapchainClearColor","text":"<p>Sets the clear color used when the swapchain is cleared.</p> <pre><code>void zest_SetSwapchainClearColor(zest_context context, float red, float green, float blue, float alpha);\n</code></pre> <p>The color is used as the background when rendering to the swapchain. Components are in the range 0.0 to 1.0.</p> <p>Example: <pre><code>// Dark gray background\nzest_SetSwapchainClearColor(context, 0.1f, 0.1f, 0.1f, 1.0f);\n\n// Cornflower blue (classic game background)\nzest_SetSwapchainClearColor(context, 0.39f, 0.58f, 0.93f, 1.0f);\n</code></pre></p>"},{"location":"api-reference/context/#zest_swapchainwasrecreated","title":"zest_SwapchainWasRecreated","text":"<p>Checks if the swapchain was recreated this frame (due to window resize).</p> <pre><code>zest_bool zest_SwapchainWasRecreated(zest_context context);\n</code></pre> <p>Returns <code>ZEST_TRUE</code> if the swapchain was recreated. Use this to invalidate cached frame graphs or recreate screen-sized resources.</p> <p>Example: <pre><code>if (zest_SwapchainWasRecreated(context)) {\n    // Flush cached frame graphs that may reference old screen-size resources\n    zest_FlushCachedFrameGraphs(context);\n    RecreateScreenSizeBuffers();\n}\n</code></pre></p>"},{"location":"api-reference/context/#vsync","title":"VSync","text":""},{"location":"api-reference/context/#zest_enablevsync-zest_disablevsync","title":"zest_EnableVSync / zest_DisableVSync","text":"<p>Controls vertical synchronization for the context.</p> <pre><code>void zest_EnableVSync(zest_context context);\nvoid zest_DisableVSync(zest_context context);\n</code></pre> <p>VSync limits the frame rate to the display's refresh rate, eliminating screen tearing but potentially adding input latency. These functions trigger a swapchain recreation.</p> <p>Example: <pre><code>// Toggle vsync based on user preference\nif (user_wants_vsync) {\n    zest_EnableVSync(context);\n} else {\n    zest_DisableVSync(context);\n}\n</code></pre></p>"},{"location":"api-reference/context/#see-also","title":"See Also","text":"<ul> <li>Device API</li> <li>Device &amp; Context Concept</li> </ul>"},{"location":"api-reference/device/","title":"Device API","text":"<p>Functions for device creation, configuration, and management. The device is the central object that manages the graphics backend, GPU selection, shader library, pipeline templates, bindless descriptor sets, and all GPU memory allocators. Typically you create one device per application, which can then serve one or more contexts (windows).</p>"},{"location":"api-reference/device/#creation","title":"Creation","text":""},{"location":"api-reference/device/#zest_implsdl2_createvulkandevice","title":"zest_implsdl2_CreateVulkanDevice","text":"<p>Creates a Zest device with SDL2 window support.</p> <pre><code>zest_device zest_implsdl2_CreateVulkanDevice(zest_window_data_t *window_data, zest_bool enable_validation);\n</code></pre> <p>This is a convenience function that handles graphics backend initialization, GPU selection, and command queue setup for SDL2-based applications. The window must be created first with <code>zest_implsdl2_CreateWindow</code> so that the required Vulkan extensions can be queried. Use validation layers during development to catch API misuse and bugs.</p> <p>Parameters:</p> <ul> <li><code>window_data</code> - Pointer to window data returned by <code>zest_implsdl2_CreateWindow</code></li> <li><code>enable_validation</code> - Enable validation layers (<code>ZEST_TRUE</code> for development, <code>ZEST_FALSE</code> for release)</li> </ul> <p>Returns: Device handle</p> <p>Example:</p> <pre><code>zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\n\n// Development build with validation\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, true);\n\n// Release build without validation overhead\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, false);\n</code></pre>"},{"location":"api-reference/device/#zest_destroydevice","title":"zest_DestroyDevice","text":"<p>Destroys the device and frees all associated resources.</p> <pre><code>void zest_DestroyDevice(zest_device device);\n</code></pre> <p>Call this at application shutdown. This will free all GPU memory pools, shut down the graphics backend, and release all CPU allocations including any contexts. The function will warn if any memory leaks are detected.</p> <p>Example:</p> <pre><code>// At application shutdown\nzest_DestroyDevice(device);\n</code></pre>"},{"location":"api-reference/device/#configuration","title":"Configuration","text":"<p>Most of the following configuration functions are for more advanced use when you want to fine tune your use of the API. Memory allocations and pool creation happens automatically internally.</p>"},{"location":"api-reference/device/#zest_setdevicepoolsize","title":"zest_SetDevicePoolSize","text":"<p>Sets the pool size for a specific type of buffer allocation.</p> <pre><code>void zest_SetDevicePoolSize(\n    zest_device device,\n    const char *name,\n    zest_buffer_usage_t usage,\n    zest_size minimum_allocation_size,\n    zest_size pool_size\n);\n</code></pre> <p>Configures the memory pool for buffers matching the given usage flags. Call this after device creation but before creating contexts or resources. Pool sizes must be powers of 2.</p> <p>Note if the device runs out of memory it will create and add a new pool of memory to use.</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>name</code> - A descriptive name for debugging/logging</li> <li><code>usage</code> - Buffer usage and memory property flags</li> <li><code>minimum_allocation_size</code> - Smallest allocation unit (may be overridden by alignment requirements)</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul>"},{"location":"api-reference/device/#zest_setgpubufferpoolsize","title":"zest_SetGPUBufferPoolSize","text":"<p>Sets the default pool size for GPU-local buffer allocations.</p> <pre><code>void zest_SetGPUBufferPoolSize(\n    zest_device device,\n    zest_size minimum_size,\n    zest_size pool_size\n);\n</code></pre> <p>Configures the memory pool used for GPU-only buffers (vertex buffers, index buffers, etc.). Call after device creation but before creating contexts. Useful when you know your application will need more GPU memory than the default.</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>minimum_size</code> - Minimum allocation granularity</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul> <p>Example:</p> <pre><code>zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, ZEST_FALSE);\n\n// Increase GPU buffer pool for a mesh-heavy application\nzest_SetGPUBufferPoolSize(device, zloc__KILOBYTE(64), zloc__MEGABYTE(256));\n\nzest_context context = zest_CreateContext(device, &amp;window, &amp;info);\n</code></pre>"},{"location":"api-reference/device/#zest_setstagingbufferpoolsize","title":"zest_SetStagingBufferPoolSize","text":"<p>Sets the pool size for staging buffer allocations.</p> <pre><code>void zest_SetStagingBufferPoolSize(\n    zest_device device,\n    zest_size minimum_size,\n    zest_size pool_size\n);\n</code></pre> <p>Staging buffers are CPU-visible memory used to upload data to the GPU (textures, mesh data, etc.). Increase this if you're loading many large assets or streaming data frequently.</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>minimum_size</code> - Minimum allocation granularity</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul> <p>Example:</p> <pre><code>zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, ZEST_FALSE);\n\n// Larger staging pool for texture-heavy applications\nzest_SetStagingBufferPoolSize(device, zloc__KILOBYTE(256), zloc__MEGABYTE(128));\n\nzest_context context = zest_CreateContext(device, &amp;window, &amp;info);\n</code></pre>"},{"location":"api-reference/device/#zest_setgpusmallbufferpoolsize","title":"zest_SetGPUSmallBufferPoolSize","text":"<p>Sets the pool size for small GPU-local buffer allocations.</p> <pre><code>void zest_SetGPUSmallBufferPoolSize(\n    zest_device device,\n    zest_size minimum_size,\n    zest_size pool_size\n);\n</code></pre> <p>Configures the memory pool for small GPU-only buffers. This is a separate pool from the main GPU buffer pool, optimized for many small allocations with less fragmentation. Useful when your application creates numerous small buffers (e.g., per-object uniform buffers).</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>minimum_size</code> - Minimum allocation granularity</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul>"},{"location":"api-reference/device/#zest_setgputransientbufferpoolsize","title":"zest_SetGPUTransientBufferPoolSize","text":"<p>Sets the pool size for transient GPU buffer allocations.</p> <pre><code>void zest_SetGPUTransientBufferPoolSize(\n    zest_device device,\n    zest_size minimum_size,\n    zest_size pool_size\n);\n</code></pre> <p>Configures the memory pool for transient GPU buffers\u2014temporary buffers that are allocated and freed frequently within a frame or across frames. These are GPU-local buffers optimized for short-lived allocations.</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>minimum_size</code> - Minimum allocation granularity</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul>"},{"location":"api-reference/device/#zest_setgpusmalltransientbufferpoolsize","title":"zest_SetGPUSmallTransientBufferPoolSize","text":"<p>Sets the pool size for small transient GPU buffer allocations.</p> <pre><code>void zest_SetGPUSmallTransientBufferPoolSize(\n    zest_device device,\n    zest_size minimum_size,\n    zest_size pool_size\n);\n</code></pre> <p>Configures the memory pool for small transient GPU buffers, combining the characteristics of both small and transient pools. Ideal for applications that frequently allocate and free many small temporary buffers.</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>minimum_size</code> - Minimum allocation granularity</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul>"},{"location":"api-reference/device/#zest_setsmallhostbufferpoolsize","title":"zest_SetSmallHostBufferPoolSize","text":"<p>Sets the pool size for small host-visible buffer allocations.</p> <pre><code>void zest_SetSmallHostBufferPoolSize(\n    zest_device device,\n    zest_size minimum_size,\n    zest_size pool_size\n);\n</code></pre> <p>Configures the memory pool for small CPU-accessible buffers. These buffers are host-visible and coherent, meaning the CPU can read/write them directly without explicit flushing. Useful for many small uniform buffers or other frequently-updated data.</p> <p>Parameters:</p> <ul> <li><code>device</code> - The device handle</li> <li><code>minimum_size</code> - Minimum allocation granularity</li> <li><code>pool_size</code> - Total pool size (must be power of 2)</li> </ul>"},{"location":"api-reference/device/#per-frame","title":"Per-Frame","text":""},{"location":"api-reference/device/#zest_updatedevice","title":"zest_UpdateDevice","text":"<p>Updates device state each frame. Must be called once per frame before any <code>zest_BeginFrame</code> calls.</p> <pre><code>int zest_UpdateDevice(zest_device device);\n</code></pre> <p>Performs maintenance tasks including: - Frees deferred resources that are no longer in use by the GPU - Releases staging buffers that have finished uploading - Increments the internal frame counter for the device</p> <p>Returns: Number of resources freed this frame (useful for debugging memory issues)</p> <p>Example:</p> <pre><code>while (running) {\n    while (SDL_PollEvent(&amp;event)) {\n        if (event.type == SDL_QUIT) running = 0;\n    }\n    zest_UpdateDevice(device);  // Must come before BeginFrame\n\n    if (zest_BeginFrame(context)) {\n        // ... render ...\n        zest_EndFrame(context);\n    }\n}\n</code></pre>"},{"location":"api-reference/device/#zest_waitforidledevice","title":"zest_WaitForIdleDevice","text":"<p>Blocks until all GPU work is complete.</p> <pre><code>void zest_WaitForIdleDevice(zest_device device);\n</code></pre> <p>Waits for all queues to drain and the GPU to become idle. Use this before destroying resources that might still be in use, or when you need to guarantee all pending work is finished (e.g., before taking a screenshot of completed rendering).</p> <p>This is a heavy function that should not be used frequently, only when you absolutely must ensure that the GPU has finished all work.</p> <p>Example:</p> <pre><code>// Ensure GPU is done before destroying resources\nzest_WaitForIdleDevice(device);\nzest_FreeTextureNow(my_texture);\n</code></pre>"},{"location":"api-reference/device/#queries","title":"Queries","text":""},{"location":"api-reference/device/#zest_getdevicepoolsize","title":"zest_GetDevicePoolSize","text":"<p>Gets the configured pool size for a specific memory type.</p> <pre><code>zest_buffer_pool_size_t zest_GetDevicePoolSize(\n    zest_device device,\n    zest_memory_property_flags property_flags\n);\n</code></pre> <p>Returns information about the pool configuration for buffers with the given memory properties.</p> <p>Returns: A struct containing the pool name, size, and minimum allocation size</p>"},{"location":"api-reference/device/#zest_getdevicememorystats","title":"zest_GetDeviceMemoryStats","text":"<p>Gets current memory allocation statistics for the device.</p> <pre><code>zloc_allocation_stats_t zest_GetDeviceMemoryStats(zest_device device);\n</code></pre> <p>Returns statistics from the TLSF allocator managing device memory, useful for debugging memory usage and detecting leaks.</p> <p>Returns: Statistics including capacity, free space, blocks in use, and free block count</p> <p>Example:</p> <pre><code>zloc_allocation_stats_t stats = zest_GetDeviceMemoryStats(device);\nprintf(\"Device memory: %zu / %zu bytes used (%d blocks)\\n\",\n    stats.capacity - stats.free, stats.capacity, stats.blocks_in_use);\n</code></pre>"},{"location":"api-reference/device/#see-also","title":"See Also","text":"<ul> <li>Context API</li> <li>Device Concept</li> </ul>"},{"location":"api-reference/frame-graph/","title":"Frame Graph API","text":"<p>Functions for building and executing frame graphs. The frame graph is the core execution model in Zest - it automatically handles resource barriers, synchronization, pass culling, and memory management.</p>"},{"location":"api-reference/frame-graph/#graph-building","title":"Graph Building","text":""},{"location":"api-reference/frame-graph/#zest_beginframegraph","title":"zest_BeginFrameGraph","text":"<p>Start building a new frame graph. This begins the recording phase where you define passes and their resource dependencies by connecting resources as inputs and outputs.</p> <pre><code>zest_bool zest_BeginFrameGraph(\n    zest_context context,\n    const char *name,\n    zest_frame_graph_cache_key_t *cache_key\n);\n</code></pre> Parameter Description <code>context</code> The context to build for <code>name</code> Debug name for the graph (shown in profilers/debuggers) <code>cache_key</code> Optional cache key (pass <code>NULL</code> or <code>0</code> to disable caching) <p>Returns <code>ZEST_TRUE</code> if building should proceed, <code>ZEST_FALSE</code> if a cached graph was found.</p> <p>Typical usage: Called at the start of each frame to begin defining your render pipeline. When using caching, check if a cached graph exists first to avoid redundant compilation.</p> <pre><code>zest_frame_graph_cache_key_t cache_key = zest_InitialiseCacheKey(context, 0, 0);\nzest_frame_graph frame_graph = zest_GetCachedFrameGraph(context, &amp;cache_key);\nif (!frame_graph) {\n    if (zest_BeginFrameGraph(context, \"Main Render\", &amp;cache_key)) {\n        // Define passes and resources here...\n        frame_graph = zest_EndFrameGraph();\n    }\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_endframegraph","title":"zest_EndFrameGraph","text":"<p>Compile and finalize the frame graph. The compiler analyzes dependencies, culls unused passes/resources, determines execution order, and generates synchronization barriers.</p> <pre><code>zest_frame_graph zest_EndFrameGraph();\n</code></pre> <p>Returns the compiled frame graph ready for execution.</p> <p>Typical usage: Called after all passes and resources have been defined. The returned graph can be cached and re-executed across multiple frames.</p> <pre><code>if (zest_BeginFrameGraph(context, \"My Graph\", &amp;cache_key)) {\n    // ... define passes ...\n    zest_frame_graph graph = zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_endframegraphandexecute","title":"zest_EndFrameGraphAndExecute","text":"<p>Compile and immediately submit the frame graph for GPU execution. Combines <code>zest_EndFrameGraph()</code> and execution into a single call.</p> <pre><code>zest_frame_graph zest_EndFrameGraphAndExecute();\n</code></pre> <p>Returns the compiled frame graph.</p> <p>Typical usage: Useful for off-screen rendering or compute work that doesn't need to be presented to a swapchain. Often paired with <code>zest_WaitForSignal()</code> to synchronize results.</p> <pre><code>zest_execution_timeline timeline = zest_CreateExecutionTimeline(device);\nif (zest_BeginFrameGraph(context, \"Compute Work\", 0)) {\n    // Define compute passes...\n    zest_SignalTimeline(timeline);\n    zest_frame_graph graph = zest_EndFrameGraphAndExecute();\n    zest_WaitForSignal(timeline, ZEST_SECONDS_IN_MICROSECONDS(1));\n    // Results are now available\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#caching","title":"Caching","text":""},{"location":"api-reference/frame-graph/#zest_initialisecachekey","title":"zest_InitialiseCacheKey","text":"<p>Create a cache key that uniquely identifies a frame graph configuration. The key incorporates swapchain state (dimensions, format) plus optional user-defined state.</p> <pre><code>zest_frame_graph_cache_key_t zest_InitialiseCacheKey(\n    zest_context context,\n    const void *user_state,\n    zest_size user_state_size\n);\n</code></pre> Parameter Description <code>context</code> The context (incorporates swapchain state) <code>user_state</code> Optional custom data to include in key (e.g., render settings) <code>user_state_size</code> Size of custom data in bytes <p>Typical usage: Use custom state when your frame graph structure changes based on runtime settings (e.g., enabling/disabling post-processing effects).</p> <pre><code>// Simple key based only on swapchain state\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, 0, 0);\n\n// Key with custom state\nstruct RenderSettings { int quality_level; bool enable_shadows; };\nRenderSettings settings = {2, true};\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, &amp;settings, sizeof(settings));\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getcachedframegraph","title":"zest_GetCachedFrameGraph","text":"<p>Retrieve a previously compiled frame graph from the cache. Returns the cached graph if found, allowing you to skip the compilation step.</p> <pre><code>zest_frame_graph zest_GetCachedFrameGraph(\n    zest_context context,\n    zest_frame_graph_cache_key_t *cache_key\n);\n</code></pre> <p>Returns the cached frame graph or <code>NULL</code> if not found.</p> <p>Typical usage: Check for a cached graph before beginning a new one. Although most frame graphs compile very quickly this still helps reduce CPU overhead and is highly recommended.</p> <pre><code>zest_frame_graph_cache_key_t cache_key = zest_InitialiseCacheKey(context, 0, 0);\nzest_frame_graph frame_graph = zest_GetCachedFrameGraph(context, &amp;cache_key);\nif (!frame_graph) {\n    // No cache hit - build the graph\n    if (zest_BeginFrameGraph(context, \"Render\", &amp;cache_key)) {\n        // ... define passes ...\n        frame_graph = zest_EndFrameGraph(); // &lt;-- Frame graph get's cached here for the next frame(s)\n    }\n}\n// Frame graph is automatically executed during zest_EndFrame()\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_flushcachedframegraphs","title":"zest_FlushCachedFrameGraphs","text":"<p>Clear all cached frame graphs for a context. Call this when major state changes require rebuilding all graphs (e.g., window resize, quality preset change etc.).</p> <pre><code>void zest_FlushCachedFrameGraphs(zest_context context);\n</code></pre> <p>Typical usage: Called in response to events that invalidate all cached graphs.</p>"},{"location":"api-reference/frame-graph/#passes","title":"Passes","text":""},{"location":"api-reference/frame-graph/#zest_beginrenderpass","title":"zest_BeginRenderPass","text":"<p>Start defining a render pass for graphics operations (drawing geometry, clearing render targets). </p> <pre><code>zest_pass_node zest_BeginRenderPass(const char *name);\n</code></pre> <p>Returns a pass node handle that can be used for debugging or advanced queries.</p> <p>Typical usage: Use for any pass that draws geometry or clears color/depth attachments.</p> <pre><code>zest_BeginRenderPass(\"Shadow Map\");\nzest_ConnectOutput(shadow_depth_resource);\nzest_SetPassTask(RenderShadowMap, &amp;shadow_data);\nzest_EndPass();\n\nzest_BeginRenderPass(\"Main Scene\");\nzest_ConnectInput(shadow_depth_resource);\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(RenderMainScene, &amp;scene_data);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_begincomputepass","title":"zest_BeginComputePass","text":"<p>Start defining a compute pass for GPU compute shader dispatch.</p> <pre><code>zest_pass_node zest_BeginComputePass(zest_compute compute, const char *name);\n</code></pre> Parameter Description <code>compute</code> The compute object containing the compute pipeline <code>name</code> Debug name for the pass <p>Typical usage: Use for image processing, particle simulation, physics, or any parallel GPU work.</p> <pre><code>// Blur pass using compute shader\nzest_compute blur_compute = zest_GetCompute(blur_compute_handle);\nzest_BeginComputePass(blur_compute, \"Gaussian Blur\");\nzest_ConnectInput(input_image);\nzest_ConnectOutput(blurred_image);\nzest_SetPassTask(DispatchBlurShader, &amp;blur_params);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_begintransferpass","title":"zest_BeginTransferPass","text":"<p>Start defining a transfer pass for data uploads, downloads, and copy operations.</p> <pre><code>zest_pass_node zest_BeginTransferPass(const char *name);\n</code></pre> <p>Typical usage: Use for staging buffer uploads, buffer-to-buffer copies, or readback operations.</p> <pre><code>zest_BeginTransferPass(\"Upload Vertex Data\");\nzest_ConnectOutput(vertex_buffer_resource);\nzest_SetPassTask(UploadVertexData, vertex_data);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_endpass","title":"zest_EndPass","text":"<p>Finalize the current pass definition. Must be called after each <code>zest_BeginRenderPass</code>, <code>zest_BeginComputePass</code>, or <code>zest_BeginTransferPass</code>.</p> <pre><code>void zest_EndPass();\n</code></pre> <p>Typical usage: Always pair with a corresponding <code>zest_Begin*Pass()</code> call.</p> <pre><code>zest_BeginRenderPass(\"My Pass\");\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(MyRenderCallback, user_data);\nzest_EndPass();  // Don't forget this!\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_setpasstask","title":"zest_SetPassTask","text":"<p>Set the callback function that will be executed when this pass runs. The callback records GPU commands for the pass.</p> <pre><code>void zest_SetPassTask(zest_fg_execution_callback callback, void *user_data);\n</code></pre> Parameter Description <code>callback</code> Function pointer with signature <code>void (*)(const zest_command_list, void*)</code> <code>user_data</code> User data passed to callback during execution <p>The user data must have the appropriate lifetime. Don't use a local variable or it will be out of scope by the time the callback is called.</p> <p>Typical usage: Set a callback that records draw calls, compute dispatches, or transfer commands.</p> <pre><code>void DrawScene(const zest_command_list cmd_list, void *user_data) {\n    SceneData *scene = (SceneData*)user_data;\n    zest_pipeline pipeline = zest_GetPipeline(scene-&gt;pipeline_template, cmd_list);\n    zest_cmd_BindPipeline(cmd_list, pipeline);\n    zest_cmd_DrawIndexed(cmd_list, scene-&gt;index_count, 1, 0, 0, 0);\n}\n\nzest_BeginRenderPass(\"Scene\");\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(DrawScene, &amp;scene_data);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_emptyrenderpass","title":"zest_EmptyRenderPass","text":"<p>Built-in callback that records no commands. Useful for passes that only need to clear attachments.</p> <pre><code>void zest_EmptyRenderPass(const zest_command_list command_list, void *user_data);\n</code></pre> <p>Typical usage: Use for clear-only passes or placeholder passes during development.</p> <pre><code>// Pass that only clears the swapchain to a color\nzest_BeginRenderPass(\"Clear Background\");\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(zest_EmptyRenderPass, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#resource-connections","title":"Resource Connections","text":""},{"location":"api-reference/frame-graph/#zest_connectinput","title":"zest_ConnectInput","text":"<p>Declare that the current pass reads from a resource. This establishes a dependency - the pass will wait for any previous writes to complete.</p> <pre><code>void zest_ConnectInput(zest_resource_node resource);\n</code></pre> <p>Typical usage: Connect textures, buffers, or images that your pass will sample or read from.</p> <pre><code>zest_resource_node shadow_map = zest_AddTransientImageResource(\"Shadow Map\", &amp;depth_info);\n\n// First pass writes the shadow map\nzest_BeginRenderPass(\"Shadow Pass\");\nzest_ConnectOutput(shadow_map);\nzest_SetPassTask(RenderShadows, NULL);\nzest_EndPass();\n\n// Second pass reads the shadow map\nzest_BeginRenderPass(\"Lighting Pass\");\nzest_ConnectInput(shadow_map);  // Creates dependency on Shadow Pass\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(RenderLighting, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_connectoutput","title":"zest_ConnectOutput","text":"<p>Declare that the current pass writes to a resource. The resource will be used as a render target or storage target.</p> <pre><code>void zest_ConnectOutput(zest_resource_node resource);\n</code></pre> <p>Typical usage: Connect render targets for graphics passes or output buffers for compute passes.</p> <pre><code>zest_resource_node gbuffer_albedo = zest_AddTransientImageResource(\"GBuffer Albedo\", &amp;color_info);\nzest_resource_node gbuffer_normal = zest_AddTransientImageResource(\"GBuffer Normal\", &amp;normal_info);\n\nzest_BeginRenderPass(\"GBuffer Pass\");\nzest_ConnectOutput(gbuffer_albedo);\nzest_ConnectOutput(gbuffer_normal);\nzest_SetPassTask(RenderGBuffer, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_connectswapchainoutput","title":"zest_ConnectSwapChainOutput","text":"<p>Declare that the current pass writes to the swapchain (the window surface). This marks the pass as essential and ensures the swapchain image is acquired.</p> <pre><code>void zest_ConnectSwapChainOutput();\n</code></pre> <p>Typical usage: Use for the final pass(es) in your frame graph that produce visible output.</p> <pre><code>zest_BeginRenderPass(\"Final Composite\");\nzest_ConnectInput(post_processed_image);\nzest_ConnectSwapChainOutput();  // Output goes to screen\nzest_SetPassTask(BlitToScreen, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_connectinputgroup","title":"zest_ConnectInputGroup","text":"<p>Connect multiple resources as inputs using a resource group. Convenience function for passes that read from many resources.</p> <pre><code>void zest_ConnectInputGroup(zest_resource_group group);\n</code></pre> <p>Typical usage: Use when a pass needs to read from a collection of related resources.</p> <pre><code>zest_resource_group gbuffer = zest_CreateResourceGroup();\nzest_AddResourceToGroup(gbuffer, albedo);\nzest_AddResourceToGroup(gbuffer, normal);\nzest_AddResourceToGroup(gbuffer, depth);\n\nzest_BeginRenderPass(\"Deferred Lighting\");\nzest_ConnectInputGroup(gbuffer);  // Reads all G-buffer textures\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(DeferredLighting, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_connectoutputgroup","title":"zest_ConnectOutputGroup","text":"<p>Connect multiple resources as outputs using a resource group. Convenience function for MRT (multiple render target) rendering.</p> <pre><code>void zest_ConnectOutputGroup(zest_resource_group group);\n</code></pre> <p>Typical usage: Use when a pass writes to multiple render targets simultaneously.</p> <pre><code>zest_resource_group gbuffer = zest_CreateResourceGroup();\nzest_AddResourceToGroup(gbuffer, albedo);\nzest_AddResourceToGroup(gbuffer, normal);\nzest_AddResourceToGroup(gbuffer, material);\n\nzest_BeginRenderPass(\"GBuffer Fill\");\nzest_ConnectOutputGroup(gbuffer);  // Writes to all G-buffer targets\nzest_SetPassTask(RenderGBuffer, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#resource-import","title":"Resource Import","text":""},{"location":"api-reference/frame-graph/#zest_importswapchainresource","title":"zest_ImportSwapchainResource","text":"<p>Import the swapchain as a resource in the frame graph. Required for any graph that presents to the screen.</p> <pre><code>zest_resource_node zest_ImportSwapchainResource();\n</code></pre> <p>Returns a resource node representing the swapchain.</p> <p>Typical usage: Call once at the start of frame graph definition, before any passes that output to the swapchain.</p> <pre><code>if (zest_BeginFrameGraph(context, \"Main\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();  // Always import first\n\n    zest_BeginRenderPass(\"Draw\");\n    zest_ConnectSwapChainOutput();\n    zest_SetPassTask(DrawCallback, NULL);\n    zest_EndPass();\n\n    frame_graph = zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_importimageresource","title":"zest_ImportImageResource","text":"<p>Import an existing image (texture, render target) into the frame graph. Use this for persistent resources that outlive a single frame.</p> <p>Important Note: You don't have to import all the images that you want to use in a frame graph. You only need to import images that you're going to write and read from to create dependency chains and therefore require synconization and layout changes that the frame graph will take care of. Otherwise it's a waste of CPU time, you can just simply pass around the descriptor indexes inside the render/compute pass callbacks to use them in your shaders.</p> <pre><code>zest_resource_node zest_ImportImageResource(\n    const char *name,\n    zest_image image,\n    zest_resource_image_provider provider\n);\n</code></pre> Parameter Description <code>name</code> Debug name for the resource <code>image</code> The image to import <code>provider</code> A zest_resource_image_provider callback function (optional) <p>Typical usage: Import persistent textures, pre-loaded assets, or images from previous frames.</p> <p>The image provider callback is used to fetch the correct image view of the image in some circumstances. For example the swapchain has a built in provider to get the correct view of the currently acquired swapchain image. This is needed for when the swapchain is cached and the original image that was imported is now stale.</p> <pre><code>// Import a persistent texture for sampling\nzest_image diffuse_tex = zest_GetImage(my_texture_handle);\nzest_resource_node diffuse = zest_ImportImageResource(\"Diffuse\", diffuse_tex, zest_texture_2d_binding);\n\nzest_BeginRenderPass(\"Draw Textured\");\nzest_ConnectInput(diffuse);\nzest_ConnectSwapChainOutput();\nzest_SetPassTask(DrawTextured, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_importbufferresource","title":"zest_ImportBufferResource","text":"<p>Import an existing buffer into the frame graph. Use for persistent buffers or CPU-accessible readback buffers.</p> <p>Important Note: You don't have to import all the buffers that you want to use in a frame graph. You only need to import buffers that you're going to write and read from to create dependency chains and therefore require synconization that the frame graph will take care of. Otherwise it's a waste of CPU time, you can just simply pass around the descriptor indexes for the buffers inside the render/compute pass callbacks to use them in your shaders.</p> <pre><code>zest_resource_node zest_ImportBufferResource(\n    const char *name,\n    zest_buffer buffer,\n    zest_resource_buffer_provider provider\n);\n</code></pre> Parameter Description <code>name</code> Debug name for the resource <code>buffer</code> The buffer to import <code>provider</code> A zest_resource_buffer_provider callback (optional) <p>Typical usage: Import vertex buffers, index buffers, or GPU-to-CPU readback buffers.</p> <pre><code>// Import a buffer for compute results that can be read back\nzest_buffer results_buffer = zest_CreateBuffer(device, size, &amp;readback_info);\nzest_resource_node results = zest_ImportBufferResource(\"Results\", results_buffer, 0);\n\nzest_BeginComputePass(compute, \"Process\");\nzest_ConnectOutput(results);\nzest_SetPassTask(ProcessData, NULL);\nzest_EndPass();\n\n// After execution, read from results_buffer\n</code></pre>"},{"location":"api-reference/frame-graph/#transient-resources","title":"Transient Resources","text":""},{"location":"api-reference/frame-graph/#zest_addtransientimageresource","title":"zest_AddTransientImageResource","text":"<p>Create an image resource with frame-lifetime. The memory is automatically allocated when needed and can be aliased with other transient resources to reduce memory usage.</p> <pre><code>zest_resource_node zest_AddTransientImageResource(\n    const char *name,\n    zest_image_resource_info_t *info\n);\n</code></pre> <p>Typical usage: Use for intermediate render targets, G-buffer textures, post-processing buffers, and any image that doesn't need to persist across frames.</p> <pre><code>zest_image_resource_info_t color_info = {zest_format_r8g8b8a8_unorm};\nzest_image_resource_info_t depth_info = {zest_format_depth};\n\nzest_resource_node color_buffer = zest_AddTransientImageResource(\"Color\", &amp;color_info);\nzest_resource_node depth_buffer = zest_AddTransientImageResource(\"Depth\", &amp;depth_info);\n\nzest_BeginRenderPass(\"Offscreen Render\");\nzest_ConnectOutput(color_buffer);\nzest_ConnectOutput(depth_buffer);\nzest_SetPassTask(RenderScene, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_addtransientbufferresource","title":"zest_AddTransientBufferResource","text":"<p>Create a buffer resource with frame-lifetime. Memory is automatically managed and can be aliased with other transient resources.</p> <pre><code>zest_resource_node zest_AddTransientBufferResource(\n    const char *name,\n    const zest_buffer_resource_info_t *info\n);\n</code></pre> <p>Typical usage: Use for temporary compute buffers, staging data, or any buffer that doesn't persist across frames.</p> <pre><code>zest_buffer_resource_info_t buffer_info = {};\nbuffer_info.size = sizeof(ParticleData) * particle_count;\n\nzest_resource_node particle_buffer = zest_AddTransientBufferResource(\"Particles\", &amp;buffer_info);\n\nzest_BeginComputePass(compute, \"Simulate Particles\");\nzest_ConnectOutput(particle_buffer);\nzest_SetPassTask(SimulateParticles, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_addtransientlayerresource","title":"zest_AddTransientLayerResource","text":"<p>Create a transient resource from a layer's buffer. Layers manage instanced/mesh rendering and this allows their buffers to participate in the frame graph.</p> <pre><code>zest_resource_node zest_AddTransientLayerResource(\n    const char *name,\n    const zest_layer layer,\n    zest_bool prev_fif\n);\n</code></pre> Parameter Description <code>name</code> Debug name for the resource <code>layer</code> The layer to use <code>prev_fif</code> If <code>ZEST_TRUE</code>, use previous frame-in-flight's buffer (for temporal effects) <p>Typical usage: Use when compute shaders need to process or generate layer data.</p> <pre><code>zest_resource_node sprite_buffer = zest_AddTransientLayerResource(\"Sprites\", sprite_layer, ZEST_FALSE);\n\nzest_BeginComputePass(compute, \"Update Sprites\");\nzest_ConnectOutput(sprite_buffer);\nzest_SetPassTask(UpdateSpritePositions, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#resource-properties","title":"Resource Properties","text":""},{"location":"api-reference/frame-graph/#zest_getresourcewidth","title":"zest_GetResourceWidth","text":"<p>Get the width in pixels of an image resource.</p> <pre><code>zest_uint zest_GetResourceWidth(zest_resource_node resource);\n</code></pre> <p>Typical usage: Query resource dimensions for dispatch calculations or viewport setup.</p> <pre><code>void BlurCallback(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node target = zest_GetPassOutputResource(cmd_list, \"Target\");\n    zest_uint width = zest_GetResourceWidth(target);\n    zest_uint height = zest_GetResourceHeight(target);\n    zest_cmd_DispatchCompute(cmd_list, (width + 7) / 8, (height + 7) / 8, 1);\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getresourceheight","title":"zest_GetResourceHeight","text":"<p>Get the height in pixels of an image resource.</p> <pre><code>zest_uint zest_GetResourceHeight(zest_resource_node resource);\n</code></pre> <p>Typical usage: Used alongside <code>zest_GetResourceWidth()</code> for computing dispatch sizes or viewports.</p>"},{"location":"api-reference/frame-graph/#zest_getresourcemiplevels","title":"zest_GetResourceMipLevels","text":"<p>Get the number of mip levels in an image resource.</p> <pre><code>zest_uint zest_GetResourceMipLevels(zest_resource_node resource);\n</code></pre> <p>Typical usage: Use when generating mipmaps or accessing specific mip levels in compute shaders.</p> <pre><code>zest_uint mip_count = zest_GetResourceMipLevels(hdr_texture);\nfor (zest_uint mip = 1; mip &lt; mip_count; mip++) {\n    // Process each mip level\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getresourcetype","title":"zest_GetResourceType","text":"<p>Get the type of a resource (image, buffer, etc.).</p> <pre><code>zest_resource_type zest_GetResourceType(zest_resource_node resource_node);\n</code></pre> <p>Typical usage: Use for generic code that handles different resource types.</p>"},{"location":"api-reference/frame-graph/#zest_getresourceimage","title":"zest_GetResourceImage","text":"<p>Get the underlying <code>zest_image</code> from an image resource node. Useful when you need access to the actual image pointer.</p> <pre><code>zest_image zest_GetResourceImage(zest_resource_node resource_node);\n</code></pre> <p>Typical usage: Access the image for operations that require the image pointer directly.</p>"},{"location":"api-reference/frame-graph/#zest_getresourceimagedescription","title":"zest_GetResourceImageDescription","text":"<p>Get the full image description including format, extent, mip levels, and other properties.</p> <pre><code>zest_image_info_t zest_GetResourceImageDescription(zest_resource_node resource_node);\n</code></pre> <p>Typical usage: Query detailed image properties for configuring compute dispatches or rendering.</p> <pre><code>void ComputeCallback(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node output = zest_GetPassOutputResource(cmd_list, \"Output\");\n    zest_image_info_t desc = zest_GetResourceImageDescription(output);\n    zest_cmd_DispatchCompute(cmd_list,\n        (desc.extent.width + 7) / 8,\n        (desc.extent.height + 7) / 8,\n        1);\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_setresourcebuffersize","title":"zest_SetResourceBufferSize","text":"<p>Set or update the size of a buffer resource. Typically you set the size of a transient resource buffer using the info struct you pass into zest_AddTransientBufferResource but you could use this inside a resource provider callback function if you don't know the size of the buffer until execution time.</p> <pre><code>void zest_SetResourceBufferSize(zest_resource_node resource, zest_size size);\n</code></pre> <p>Typical usage: Dynamically size buffers based on runtime requirements.</p> <pre><code>zest_SetResourceBufferSize(particles, sizeof(Particle) * active_particle_count);\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_setresourceclearcolor","title":"zest_SetResourceClearColor","text":"<p>Set the clear color for a render target resource. This color is used when the attachment is cleared at pass start.</p> <pre><code>void zest_SetResourceClearColor(\n    zest_resource_node resource,\n    float red, float green, float blue, float alpha\n);\n</code></pre> <p>Typical usage: Set clear colors for intermediate render targets.</p> <pre><code>zest_resource_node hdr_buffer = zest_AddTransientImageResource(\"HDR\", &amp;hdr_info);\nzest_SetResourceClearColor(hdr_buffer, 0.0f, 0.0f, 0.0f, 1.0f);\n\nzest_BeginRenderPass(\"HDR Scene\");\nzest_ConnectOutput(hdr_buffer);\nzest_SetPassTask(RenderHDR, NULL);  // Starts with black clear\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getresourceuserdata","title":"zest_GetResourceUserData","text":"<p>Get custom user data attached to a resource.</p> <pre><code>void *zest_GetResourceUserData(zest_resource_node resource_node);\n</code></pre> <p>Typical usage: Retrieve context-specific data associated with resources.</p>"},{"location":"api-reference/frame-graph/#zest_setresourceuserdata","title":"zest_SetResourceUserData","text":"<p>Attach custom user data to a resource. Useful for associating application-specific metadata with resources.</p> <pre><code>void zest_SetResourceUserData(zest_resource_node resource_node, void *user_data);\n</code></pre> <p>Typical usage: Store per-resource metadata like debug info or application context.</p>"},{"location":"api-reference/frame-graph/#zest_setresourcebufferprovider","title":"zest_SetResourceBufferProvider","text":"<p>Allows you to set a resource provider callback to a transient resource if you need to make changes to a buffer at execution time.</p> <pre><code>void zest_SetResourceBufferProvider(\n    zest_resource_node resource_node,\n    zest_resource_buffer_provider buffer_provider\n);\n</code></pre> <p>Typical usage: Change buffer size when the graph is executed but before the transient resource is created.</p>"},{"location":"api-reference/frame-graph/#zest_setresourceimageprovider","title":"zest_SetResourceImageProvider","text":"<p>Allows you to set a resource provider callback to a transient resource if you need to make changes to an image at execution time.</p> <pre><code>void zest_SetResourceImageProvider(\n    zest_resource_node resource_node,\n    zest_resource_image_provider image_provider\n);\n</code></pre> <p>Typical usage: Change image size when the graph is executed but before the transient resource is created.</p>"},{"location":"api-reference/frame-graph/#pass-resource-access","title":"Pass Resource Access","text":""},{"location":"api-reference/frame-graph/#zest_getpassinputresource","title":"zest_GetPassInputResource","text":"<p>Get an input resource by name within a pass callback. Use this to access resources you connected with <code>zest_ConnectInput()</code>.</p> <pre><code>zest_resource_node zest_GetPassInputResource(\n    const zest_command_list command_list,\n    const char *name\n);\n</code></pre> <p>Typical usage: Retrieve resources in your pass callback to get their bindless indices or properties.</p> <pre><code>void LightingPass(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node shadow_map = zest_GetPassInputResource(cmd_list, \"Shadow Map\");\n    zest_uint shadow_index = zest_GetTransientSampledImageBindlessIndex(\n        cmd_list, shadow_map, zest_texture_2d_binding);\n    // Use shadow_index in push constants\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getpassoutputresource","title":"zest_GetPassOutputResource","text":"<p>Get an output resource by name within a pass callback. Use this to access resources you connected with <code>zest_ConnectOutput()</code>.</p> <pre><code>zest_resource_node zest_GetPassOutputResource(\n    const zest_command_list command_list,\n    const char *name\n);\n</code></pre> <p>Typical usage: Access output resources to get their bindless indices for compute shader writes.</p> <pre><code>void ComputePass(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node output = zest_GetPassOutputResource(cmd_list, \"Output Buffer\");\n    zest_uint output_index = zest_GetTransientBufferBindlessIndex(cmd_list, output);\n    // Use output_index in push constants for compute shader\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getpassinputbuffer","title":"zest_GetPassInputBuffer","text":"<p>Get an input buffer by name within a pass callback. Convenience function that returns the buffer directly.</p> <pre><code>zest_buffer zest_GetPassInputBuffer(\n    const zest_command_list command_list,\n    const char *name\n);\n</code></pre> <p>Typical usage: Access input buffers when you need the buffer handle directly.</p>"},{"location":"api-reference/frame-graph/#zest_getpassoutputbuffer","title":"zest_GetPassOutputBuffer","text":"<p>Get an output buffer by name within a pass callback. Convenience function that returns the buffer directly.</p> <pre><code>zest_buffer zest_GetPassOutputBuffer(\n    const zest_command_list command_list,\n    const char *name\n);\n</code></pre> <p>Typical usage: Access output buffers for copy operations or direct access.</p>"},{"location":"api-reference/frame-graph/#bindless-descriptor-helpers","title":"Bindless Descriptor Helpers","text":"<p>These functions will either acquire an index or get the index that was already acquired for the transient resource which might be the case if you're using the resource again in another pass.</p> <p>Bindless indexes that are acquired for transient resources are automatically released in the next frame after they're done with.</p>"},{"location":"api-reference/frame-graph/#zest_gettransientsampledimagebindlessindex","title":"zest_GetTransientSampledImageBindlessIndex","text":"<p>Get the bindless descriptor array index for a transient sampled image. Use this index in shaders to access the texture.</p> <pre><code>zest_uint zest_GetTransientSampledImageBindlessIndex(\n    const zest_command_list command_list,\n    zest_resource_node resource,\n    zest_binding_number_type binding_number\n);\n</code></pre> <p>Typical usage: Get the bindless index for passing to shaders via push constants.</p> <pre><code>void RenderPass(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node albedo = zest_GetPassInputResource(cmd_list, \"Albedo\");\n\n    MyPushConstants push;\n    push.albedo_index = zest_GetTransientSampledImageBindlessIndex(\n        cmd_list, albedo, zest_texture_2d_binding);\n    zest_cmd_SendPushConstants(cmd_list, &amp;push, sizeof(push));\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_gettransientsampledmipbindlessindexes","title":"zest_GetTransientSampledMipBindlessIndexes","text":"<p>Get bindless indices for all mip levels of a transient image. Returns an array with one index per mip level.</p> <pre><code>zest_uint *zest_GetTransientSampledMipBindlessIndexes(\n    const zest_command_list command_list,\n    zest_resource_node resource,\n    zest_binding_number_type binding_number\n);\n</code></pre> <p>Returns array of indices, one per mip level.</p> <p>Typical usage: Access specific mip levels in compute shaders for downsampling or mipmap generation.</p> <pre><code>void GenerateMipmaps(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node image = zest_GetPassOutputResource(cmd_list, \"Image\");\n    zest_uint *mip_indices = zest_GetTransientSampledMipBindlessIndexes(\n        cmd_list, image, zest_storage_image_binding);\n    zest_uint mip_count = zest_GetResourceMipLevels(image);\n\n    for (zest_uint i = 1; i &lt; mip_count; i++) {\n        // Dispatch downsample from mip_indices[i-1] to mip_indices[i]\n    }\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_gettransientbufferbindlessindex","title":"zest_GetTransientBufferBindlessIndex","text":"<p>Get the bindless descriptor array index for a transient buffer.</p> <pre><code>zest_uint zest_GetTransientBufferBindlessIndex(\n    const zest_command_list command_list,\n    zest_resource_node resource\n);\n</code></pre> <p>Typical usage: Get the bindless index for buffers accessed in compute shaders.</p> <pre><code>void ComputePass(const zest_command_list cmd_list, void *user_data) {\n    zest_resource_node input = zest_GetPassInputResource(cmd_list, \"Input Buffer\");\n    zest_resource_node output = zest_GetPassOutputResource(cmd_list, \"Output Buffer\");\n\n    MyPushConstants push;\n    push.input_buffer = zest_GetTransientBufferBindlessIndex(cmd_list, input);\n    push.output_buffer = zest_GetTransientBufferBindlessIndex(cmd_list, output);\n    zest_cmd_SendPushConstants(cmd_list, &amp;push, sizeof(push));\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#resource-groups","title":"Resource Groups","text":""},{"location":"api-reference/frame-graph/#zest_createresourcegroup","title":"zest_CreateResourceGroup","text":"<p>Create an empty resource group for batching multiple resources together.</p> <pre><code>zest_resource_group zest_CreateResourceGroup();\n</code></pre> <p>Typical usage: Create groups for G-buffers, multiple render targets, or related texture sets.</p> <pre><code>zest_resource_group gbuffer = zest_CreateResourceGroup();\nzest_AddResourceToGroup(gbuffer, albedo);\nzest_AddResourceToGroup(gbuffer, normal);\nzest_AddResourceToGroup(gbuffer, material);\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_addresourcetogroup","title":"zest_AddResourceToGroup","text":"<p>Add a resource to a resource group.</p> <pre><code>void zest_AddResourceToGroup(zest_resource_group group, zest_resource_node image);\n</code></pre> <p>Typical usage: Build up a group of related resources for batch connection.</p> <pre><code>zest_resource_group attachments = zest_CreateResourceGroup();\nzest_AddResourceToGroup(attachments, color_target);\nzest_AddResourceToGroup(attachments, depth_target);\n\nzest_BeginRenderPass(\"Main Render\");\nzest_ConnectOutputGroup(attachments);\nzest_SetPassTask(RenderScene, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_addswapchaintogroup","title":"zest_AddSwapchainToGroup","text":"<p>Add the swapchain to a resource group.</p> <pre><code>void zest_AddSwapchainToGroup(zest_resource_group group);\n</code></pre> <p>Typical usage: Include the swapchain in a group when combining it with other outputs.</p> <pre><code>zest_resource_group outputs = zest_CreateResourceGroup();\nzest_AddSwapchainToGroup(outputs);\nzest_AddResourceToGroup(outputs, ui_overlay);\n</code></pre>"},{"location":"api-reference/frame-graph/#special-flags","title":"Special Flags","text":""},{"location":"api-reference/frame-graph/#zest_flagresourceasessential","title":"zest_FlagResourceAsEssential","text":"<p>Mark a resource to prevent it and its dependent passes from being culled, even if the resource isn't used as a final output.</p> <pre><code>void zest_FlagResourceAsEssential(zest_resource_node resource);\n</code></pre> <p>Typical usage: Keep side-effect resources like depth buffers that don't directly connect to final output.</p> <pre><code>zest_resource_node depth = zest_AddTransientImageResource(\"Depth\", &amp;depth_info);\nzest_FlagResourceAsEssential(depth);  // Prevent culling\n\nzest_BeginRenderPass(\"3D Scene\");\nzest_ConnectSwapChainOutput();\nzest_ConnectOutput(depth);  // Depth needed for rendering but not as input elsewhere\nzest_SetPassTask(Render3D, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_donotcull","title":"zest_DoNotCull","text":"<p>Prevent the current pass from being culled during compilation, regardless of whether its outputs are used.</p> <pre><code>void zest_DoNotCull();\n</code></pre> <p>Typical usage: Keep passes with important side effects that don't produce visible resource outputs.</p> <pre><code>zest_BeginComputePass(compute, \"Update Simulation\");\nzest_DoNotCull();  // Keep even if outputs aren't connected\nzest_SetPassTask(UpdateSimulation, NULL);\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/frame-graph/#execution","title":"Execution","text":""},{"location":"api-reference/frame-graph/#zest_waitforsignal","title":"zest_WaitForSignal","text":"<p>Wait for a timeline semaphore signal, blocking until the GPU work completes or timeout occurs.</p> <pre><code>zest_semaphore_status zest_WaitForSignal(\n    zest_execution_timeline timeline,\n    zest_microsecs timeout\n);\n</code></pre> Parameter Description <code>timeline</code> The execution timeline to wait on <code>timeout</code> Timeout in microseconds <p>Returns <code>zest_semaphore_status_success</code>, <code>zest_semaphore_status_timeout</code>, or <code>zest_semaphore_status_error</code>.</p> <p>Typical usage: Synchronize with GPU work for readback or when results are needed immediately.</p> <pre><code>zest_execution_timeline timeline = zest_CreateExecutionTimeline(device);\n\nif (zest_BeginFrameGraph(context, \"Compute Work\", 0)) {\n    // ... define compute passes ...\n    zest_SignalTimeline(timeline);\n    zest_EndFrameGraphAndExecute();\n}\n\nzest_semaphore_status status = zest_WaitForSignal(timeline, ZEST_SECONDS_IN_MICROSECONDS(1));\nif (status == zest_semaphore_status_success) {\n    // GPU work complete, safe to read results\n    void *data = zest_BufferData(result_buffer);\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#debugging","title":"Debugging","text":""},{"location":"api-reference/frame-graph/#zest_printcompiledframegraph","title":"zest_PrintCompiledFrameGraph","text":"<p>Print the compiled frame graph structure to the console. Shows passes, resources, dependencies, and barriers for debugging.</p> <p>Note You must <code>#define ZEST_TEST_MODE</code> before including <code>zest.h</code> in order to print frame graphs.</p> <pre><code>void zest_PrintCompiledFrameGraph(zest_frame_graph frame_graph);\n</code></pre> <p>Typical usage: Debug frame graph compilation issues or understand the execution order.</p> <pre><code>zest_frame_graph graph = zest_EndFrameGraph();\n#ifdef _DEBUG\nzest_PrintCompiledFrameGraph(graph);  // Print in debug builds\n#endif\n// Graph is automatically executed during zest_EndFrame()\n</code></pre>"},{"location":"api-reference/frame-graph/#zest_getframegraphresult","title":"zest_GetFrameGraphResult","text":"<p>Get the compilation result status of a frame graph. Use to check for errors after compilation.</p> <pre><code>zest_frame_graph_result zest_GetFrameGraphResult(zest_frame_graph frame_graph);\n</code></pre> <p>Typical usage: Validate that frame graph compilation succeeded.</p> <pre><code>zest_frame_graph graph = zest_EndFrameGraph();\nzest_frame_graph_result result = zest_GetFrameGraphResult(graph);\nif (result != 0) {\n    // Handle compilation error\n    zest_PrintCompiledFrameGraph(graph);\n}\n</code></pre>"},{"location":"api-reference/frame-graph/#see-also","title":"See Also","text":"<ul> <li>Frame Graph Concepts</li> <li>Passes</li> <li>Resources</li> <li>Execution</li> <li>Debugging</li> <li>Multi-Pass Tutorial</li> </ul>"},{"location":"api-reference/image/","title":"Image API","text":"<p>Functions for image, image view, and sampler management.</p>"},{"location":"api-reference/image/#image-creation","title":"Image Creation","text":""},{"location":"api-reference/image/#zest_createimageinfo","title":"zest_CreateImageInfo","text":"<p>Creates a default image configuration struct with the specified dimensions.</p> <pre><code>zest_image_info_t zest_CreateImageInfo(zest_uint width, zest_uint height);\n</code></pre> <p>Set <code>info.flags</code> to a preset for common use cases: - <code>zest_image_preset_texture</code> - Standard texture loaded from CPU - <code>zest_image_preset_texture_mipmaps</code> - Texture with automatic mipmap generation - <code>zest_image_preset_color_attachment</code> - Render target that can be sampled (post-processing) - <code>zest_image_preset_depth_attachment</code> - Depth buffer that can be sampled (shadow mapping, SSAO) - <code>zest_image_preset_storage</code> - Compute shader read/write with sampling support - <code>zest_image_preset_storage_cubemap</code> - Cubemap for compute shader processing - <code>zest_image_preset_storage_mipped_cubemap</code> - Mipped cubemap for PBR lighting preparation</p> <p>Example: <pre><code>// Create a texture with mipmaps\nzest_image_info_t info = zest_CreateImageInfo(512, 512);\ninfo.flags = zest_image_preset_texture_mipmaps;\ninfo.format = zest_format_r8g8b8a8_unorm;\n</code></pre></p>"},{"location":"api-reference/image/#zest_createimage","title":"zest_CreateImage","text":"<p>Creates an empty GPU image with the specified configuration.</p> <pre><code>zest_image_handle zest_CreateImage(zest_device device, zest_image_info_t *create_info);\n</code></pre> <p>Use this for images that will be written to by the GPU (render targets, compute output).</p> <p>Example: <pre><code>// Create a render target\nzest_image_info_t info = zest_CreateImageInfo(1920, 1080);\ninfo.flags = zest_image_preset_color_attachment;\ninfo.format = zest_format_r8g8b8a8_unorm;\nzest_image_handle render_target = zest_CreateImage(device, &amp;info);\n</code></pre></p>"},{"location":"api-reference/image/#zest_createimagewithpixels","title":"zest_CreateImageWithPixels","text":"<p>Creates a GPU image and uploads pixel data from CPU memory.</p> <pre><code>zest_image_handle zest_CreateImageWithPixels(\n    zest_device device,\n    void *pixels,\n    zest_size size,\n    zest_image_info_t *create_info\n);\n</code></pre> <p>The most common way to create textures from loaded image data.</p> <p>Example: <pre><code>// Load and create a texture\nint width, height, channels;\nstbi_uc *pixels = stbi_load(\"texture.png\", &amp;width, &amp;height, &amp;channels, 4);\nzest_size size = width * height * 4;\n\nzest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.flags = zest_image_preset_texture;\ninfo.format = zest_format_r8g8b8a8_unorm;\n\nzest_image_handle texture = zest_CreateImageWithPixels(device, pixels, size, &amp;info);\nstbi_image_free(pixels);\n</code></pre></p>"},{"location":"api-reference/image/#zest_getimage","title":"zest_GetImage","text":"<p>Retrieves the image object from a handle for usage in various image functions.</p> <pre><code>zest_image zest_GetImage(zest_image_handle handle);\n</code></pre> <p>Example: <pre><code>zest_image image = zest_GetImage(texture_handle);\nzest_uint mip_count = image-&gt;mip_levels;\n</code></pre></p>"},{"location":"api-reference/image/#zest_freeimage","title":"zest_FreeImage","text":"<p>Queues an image for deferred destruction at the end of the current frame.</p> <pre><code>void zest_FreeImage(zest_image_handle image_handle);\n</code></pre> <p>Safe to call while the image may still be in use by in-flight GPU commands.</p>"},{"location":"api-reference/image/#zest_freeimagenow","title":"zest_FreeImageNow","text":"<p>Immediately destroys an image. Only call when certain the image is not in use.</p> <pre><code>void zest_FreeImageNow(zest_image_handle image_handle);\n</code></pre>"},{"location":"api-reference/image/#image-views","title":"Image Views","text":"<p>Image views provide a way to access subsets of an image (specific mip levels, array layers).</p>"},{"location":"api-reference/image/#zest_createviewimageinfo","title":"zest_CreateViewImageInfo","text":"<p>Creates a default image view configuration for an image.</p> <pre><code>zest_image_view_create_info_t zest_CreateViewImageInfo(zest_image image);\n</code></pre> <p>Returns a configuration with sensible defaults based on the image type. Modify the returned struct to customize which mip levels or array layers are accessible.</p> <p>Fields in <code>zest_image_view_create_info_t</code>: - <code>view_type</code> - The type of view (2D, cube, array, etc.) - <code>base_mip_level</code> - First mip level accessible through this view - <code>mip_level_count</code> - Number of mip levels accessible - <code>base_array_layer</code> - First array layer accessible - <code>layer_count</code> - Number of array layers accessible</p>"},{"location":"api-reference/image/#zest_createimageview","title":"zest_CreateImageView","text":"<p>Creates an image view with the specified configuration.</p> <pre><code>zest_image_view_handle zest_CreateImageView(\n    zest_device device,\n    zest_image image,\n    zest_image_view_create_info_t *create_info\n);\n</code></pre> <p>Example: <pre><code>// Create a view for a specific mip level\nzest_image_view_create_info_t view_info = zest_CreateViewImageInfo(image);\nview_info.base_mip_level = 2;\nview_info.mip_level_count = 1;\nzest_image_view_handle mip2_view = zest_CreateImageView(device, image, &amp;view_info);\n</code></pre></p> <p>Note that when you create an image it automatically creates an default image view that is used when acquiring descriptor indexes. You can use this though if you need something more specific like targetting a specific mip level as in the example above.</p>"},{"location":"api-reference/image/#zest_createimageviewspermip","title":"zest_CreateImageViewsPerMip","text":"<p>Creates an array of image views, one for each mip level.</p> <pre><code>zest_image_view_array_handle zest_CreateImageViewsPerMip(zest_device device, zest_image image);\n</code></pre> <p>Useful for compute shaders that need to write to individual mip levels (e.g., mipmap generation, cubemap filtering).</p>"},{"location":"api-reference/image/#zest_getimageview","title":"zest_GetImageView","text":"<p>Retrieves the image view object from a handle.</p> <pre><code>zest_image_view zest_GetImageView(zest_image_view_handle handle);\n</code></pre>"},{"location":"api-reference/image/#zest_getimageviewarray","title":"zest_GetImageViewArray","text":"<p>Retrieves an array of image views from a handle.</p> <pre><code>zest_image_view_array zest_GetImageViewArray(zest_image_view_array_handle handle);\n</code></pre>"},{"location":"api-reference/image/#zest_freeimageview-zest_freeimageviewnow","title":"zest_FreeImageView / zest_FreeImageViewNow","text":"<p>Destroys an image view (deferred or immediate).</p> <pre><code>void zest_FreeImageView(zest_image_view_handle view_handle);\nvoid zest_FreeImageViewNow(zest_image_view_handle view_handle);\n</code></pre>"},{"location":"api-reference/image/#zest_freeimageviewarray-zest_freeimageviewarraynow","title":"zest_FreeImageViewArray / zest_FreeImageViewArrayNow","text":"<p>Destroys an array of image views (deferred or immediate).</p> <pre><code>void zest_FreeImageViewArray(zest_image_view_array_handle view_handle);\nvoid zest_FreeImageViewArrayNow(zest_image_view_array_handle view_handle);\n</code></pre>"},{"location":"api-reference/image/#samplers","title":"Samplers","text":"<p>Samplers define how textures are filtered and addressed when sampled in shaders.</p>"},{"location":"api-reference/image/#zest_createsamplerinfo","title":"zest_CreateSamplerInfo","text":"<p>Creates default sampler configurations.</p> <pre><code>zest_sampler_info_t zest_CreateSamplerInfo();           // Clamp-to-edge addressing\nzest_sampler_info_t zest_CreateSamplerInfoRepeat();     // Repeat/wrap addressing\nzest_sampler_info_t zest_CreateSamplerInfoMirrorRepeat(); // Mirror-repeat addressing\n</code></pre> <p>All variants default to linear filtering with linear mipmap interpolation.</p>"},{"location":"api-reference/image/#zest_createsampler","title":"zest_CreateSampler","text":"<p>Creates a sampler with the specified configuration.</p> <pre><code>zest_sampler_handle zest_CreateSampler(zest_context context, zest_sampler_info_t *info);\n</code></pre> <p>Example: <pre><code>zest_sampler_info_t info = zest_CreateSamplerInfoRepeat();\nzest_sampler_handle sampler_handle = zest_CreateSampler(context, &amp;info);\nzest_sampler sampler = zest_GetSampler(sampler_handle);\n</code></pre></p>"},{"location":"api-reference/image/#zest_getsampler","title":"zest_GetSampler","text":"<p>Retrieves the sampler object from a handle.</p> <pre><code>zest_sampler zest_GetSampler(zest_sampler_handle handle);\n</code></pre>"},{"location":"api-reference/image/#bindless-indices","title":"Bindless Indices","text":"<p>Zest uses bindless descriptors where images and samplers are indexed into global descriptor arrays. These functions manage the allocation and release of those indices.</p>"},{"location":"api-reference/image/#zest_acquiresampledimageindex","title":"zest_AcquireSampledImageIndex","text":"<p>Registers an image in the bindless descriptor array and returns its index for shader access.</p> <pre><code>zest_uint zest_AcquireSampledImageIndex(\n    zest_device device,\n    zest_image image,\n    zest_binding_number_type binding_number\n);\n</code></pre> <p>Common binding numbers: - <code>zest_texture_2d_binding</code> - Standard 2D textures - <code>zest_texture_array_binding</code> - Standard 2D texture arrays - <code>zest_storage_image_binding</code> - Storage images for use in compute shaders - <code>zest_texture_cube_binding</code> - Cubemap textures</p> <p>Example: <pre><code>zest_image image = zest_GetImage(texture_handle);\nzest_uint texture_index = zest_AcquireSampledImageIndex(device, image, zest_texture_2d_binding);\n// Pass texture_index to shader via push constants or uniform buffer\n</code></pre></p>"},{"location":"api-reference/image/#zest_acquiresamplerindex","title":"zest_AcquireSamplerIndex","text":"<p>Registers a sampler in the bindless descriptor array.</p> <pre><code>zest_uint zest_AcquireSamplerIndex(zest_device device, zest_sampler sampler);\n</code></pre> <p>Example: <pre><code>zest_sampler sampler = zest_GetSampler(sampler_handle);\nzest_uint sampler_index = zest_AcquireSamplerIndex(device, sampler);\n</code></pre></p>"},{"location":"api-reference/image/#zest_acquirestorageimageindex","title":"zest_AcquireStorageImageIndex","text":"<p>Registers an image for storage (read/write) access in compute shaders.</p> <pre><code>zest_uint zest_AcquireStorageImageIndex(\n    zest_device device,\n    zest_image image,\n    zest_binding_number_type binding_number\n);\n</code></pre> <p>Use <code>zest_storage_image_binding</code> for the binding number.</p>"},{"location":"api-reference/image/#zest_acquireimagemipindexes","title":"zest_AcquireImageMipIndexes","text":"<p>Registers each mip level of an image separately for individual mip access in shaders.</p> <pre><code>zest_uint *zest_AcquireImageMipIndexes(\n    zest_device device,\n    zest_image image,\n    zest_image_view_array image_view_array,\n    zest_binding_number_type binding_number,\n    zest_descriptor_type descriptor_type\n);\n</code></pre> <p>Returns an array of indices, one per mip level. Useful for compute-based mipmap generation.</p>"},{"location":"api-reference/image/#zest_releaseimageindex","title":"zest_ReleaseImageIndex","text":"<p>Releases a sampled or storage image index back to the pool.</p> <pre><code>void zest_ReleaseImageIndex(\n    zest_device device,\n    zest_image image,\n    zest_binding_number_type binding_number\n);\n</code></pre>"},{"location":"api-reference/image/#zest_releaseimagemipindexes","title":"zest_ReleaseImageMipIndexes","text":"<p>Releases all mip-level indices for an image.</p> <pre><code>void zest_ReleaseImageMipIndexes(\n    zest_device device,\n    zest_image image,\n    zest_binding_number_type binding_number\n);\n</code></pre>"},{"location":"api-reference/image/#zest_releaseallimageindexes","title":"zest_ReleaseAllImageIndexes","text":"<p>Releases all bindless indices associated with an image across all binding numbers.</p> <p>Note: This will happen automatically when the image is freed.</p> <pre><code>void zest_ReleaseAllImageIndexes(zest_device device, zest_image image);\n</code></pre>"},{"location":"api-reference/image/#zest_releasebindlessindex","title":"zest_ReleaseBindlessIndex","text":"<p>Releases a specific bindless index by value (for samplers or when you only have the index).</p> <pre><code>void zest_ReleaseBindlessIndex(\n    zest_device device,\n    zest_uint index,\n    zest_binding_number_type binding_number\n);\n</code></pre>"},{"location":"api-reference/image/#complete-example","title":"Complete Example","text":"<p>Loading a texture and making it available to shaders:</p> <pre><code>// Load image from file\nint width, height, channels;\nstbi_uc *pixels = stbi_load(\"sprite.png\", &amp;width, &amp;height, &amp;channels, 4);\n\n// Create GPU image\nzest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.flags = zest_image_preset_texture;\ninfo.format = zest_format_r8g8b8a8_unorm;\nzest_image_handle image_handle = zest_CreateImageWithPixels(device, pixels, width * height * 4, &amp;info);\nstbi_image_free(pixels);\n\n// Get bindless index for shader access\nzest_image image = zest_GetImage(image_handle);\nzest_uint texture_index = zest_AcquireSampledImageIndex(device, image, zest_texture_2d_binding);\n\n// Create a sampler\nzest_sampler_info_t sampler_info = zest_CreateSamplerInfo();\nzest_sampler_handle sampler_handle = zest_CreateSampler(context, &amp;sampler_info);\nzest_sampler sampler = zest_GetSampler(sampler_handle);\nzest_uint sampler_index = zest_AcquireSamplerIndex(device, sampler);\n\n// Use texture_index and sampler_index in your shader push constants\n</code></pre>"},{"location":"api-reference/image/#see-also","title":"See Also","text":"<ul> <li>Images Concept</li> <li>Bindless Concept</li> </ul>"},{"location":"api-reference/immediate/","title":"Immediate API","text":"<p>One-off GPU commands outside frame graphs (<code>zest_imm_*</code> functions). Use these for initialization, resource uploads, and other operations that don't fit within the frame graph model.</p>"},{"location":"api-reference/immediate/#command-buffer","title":"Command Buffer","text":""},{"location":"api-reference/immediate/#zest_imm_begincommandbuffer","title":"zest_imm_BeginCommandBuffer","text":"<p>Begin immediate command recording. Acquires a command buffer from the specified queue for one-time submission.</p> <pre><code>zest_queue zest_imm_BeginCommandBuffer(zest_device device, zest_device_queue_type target_queue);\n</code></pre> <p>Parameters: - <code>device</code> - The Zest device handle - <code>target_queue</code> - Queue type: <code>zest_queue_graphics</code>, <code>zest_queue_transfer</code>, or <code>zest_queue_compute</code></p> <p>Returns: A queue handle to use with subsequent immediate commands.</p> <p>Usage: Call this at the start of any immediate command sequence. Choose the appropriate queue type for your operation - transfer for copies, compute for compute dispatches, graphics for operations requiring graphics capabilities.</p>"},{"location":"api-reference/immediate/#zest_imm_endcommandbuffer","title":"zest_imm_EndCommandBuffer","text":"<p>Submit the command buffer and wait for completion (blocking). The queue is released immediately after.</p> <pre><code>zest_bool zest_imm_EndCommandBuffer(zest_queue queue);\n</code></pre> <p>Parameters: - <code>queue</code> - The queue handle from <code>zest_imm_BeginCommandBuffer</code></p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Usage: Always call this to finalize and execute immediate commands. This is a blocking call that waits for GPU completion before returning.</p>"},{"location":"api-reference/immediate/#buffer-operations","title":"Buffer Operations","text":""},{"location":"api-reference/immediate/#zest_imm_copybuffer","title":"zest_imm_CopyBuffer","text":"<p>Copy data from one buffer to another. Typically used to upload data from a staging buffer to GPU-local memory.</p> <pre><code>zest_bool zest_imm_CopyBuffer(\n    zest_queue queue,\n    zest_buffer src_buffer,\n    zest_buffer dst_buffer,\n    zest_size size\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>src_buffer</code> - Source buffer (typically staging buffer) - <code>dst_buffer</code> - Destination buffer (typically device-local buffer) - <code>size</code> - Number of bytes to copy</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Upload vertex data to GPU\nzest_buffer staging = zest_CreateStagingBuffer(device, vertex_size, vertex_data);\nzest_buffer gpu_buffer = zest_CreateDeviceBuffer(device, vertex_size, zest_buffer_usage_vertex);\n\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_CopyBuffer(queue, staging, gpu_buffer, vertex_size);\nzest_imm_EndCommandBuffer(queue);\n\nzest_FreeBuffer(staging);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_copybufferregion","title":"zest_imm_CopyBufferRegion","text":"<p>Copy a region from one buffer to another with specific offsets. Useful for partial updates or appending data.</p> <pre><code>zest_bool zest_imm_CopyBufferRegion(\n    zest_queue queue,\n    zest_buffer src_buffer,\n    zest_size src_offset,\n    zest_buffer dst_buffer,\n    zest_size dst_offset,\n    zest_size size\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>src_buffer</code> - Source buffer - <code>src_offset</code> - Byte offset in source buffer - <code>dst_buffer</code> - Destination buffer - <code>dst_offset</code> - Byte offset in destination buffer - <code>size</code> - Number of bytes to copy</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Append mesh data to an existing buffer\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_CopyBufferRegion(queue, staging, 0, vertex_buffer, existing_size, new_data_size);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_fillbuffer","title":"zest_imm_FillBuffer","text":"<p>Fill an entire buffer with a 32-bit value. Commonly used to zero-initialize buffers or set default values.</p> <pre><code>void zest_imm_FillBuffer(\n    zest_queue queue,\n    zest_buffer buffer,\n    zest_uint value\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>buffer</code> - Buffer to fill - <code>value</code> - 32-bit value to fill with (repeated throughout buffer)</p> <p>Example: <pre><code>// Zero-initialize a compute buffer\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_FillBuffer(queue, counter_buffer, 0);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_updatebuffer","title":"zest_imm_UpdateBuffer","text":"<p>Update a buffer with data directly from CPU memory. Limited to 64KB maximum. For larger updates, use staging buffers with <code>zest_imm_CopyBuffer</code>.</p> <pre><code>void zest_imm_UpdateBuffer(\n    zest_queue queue,\n    zest_buffer buffer,\n    void *data,\n    zest_size intended_size\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>buffer</code> - Destination buffer - <code>data</code> - Pointer to source data - <code>intended_size</code> - Size in bytes (max 64KB)</p> <p>Example: <pre><code>// Quick update of uniform data\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_UpdateBuffer(queue, uniform_buffer, &amp;uniforms, sizeof(uniforms));\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#image-operations","title":"Image Operations","text":""},{"location":"api-reference/immediate/#zest_imm_copybuffertoimage","title":"zest_imm_CopyBufferToImage","text":"<p>Copy pixel data from a buffer to an image. Used for texture uploads from staging buffers.</p> <pre><code>zest_bool zest_imm_CopyBufferToImage(\n    zest_queue queue,\n    zest_buffer src_buffer,\n    zest_image dst_image,\n    zest_size size\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>src_buffer</code> - Source buffer containing pixel data - <code>dst_image</code> - Destination image - <code>size</code> - Size in bytes to copy</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Upload texture from staging buffer\nzest_buffer staging = zest_CreateStagingBuffer(device, pixel_size, pixels);\n\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_TransitionImage(queue, texture, zest_image_layout_transfer_dst_optimal, 0, 1, 0, 1);\nzest_imm_CopyBufferToImage(queue, staging, texture, pixel_size);\nzest_imm_TransitionImage(queue, texture, zest_image_layout_shader_read_only_optimal, 0, 1, 0, 1);\nzest_imm_EndCommandBuffer(queue);\n\nzest_FreeBuffer(staging);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_copybufferregionstoimage","title":"zest_imm_CopyBufferRegionsToImage","text":"<p>Copy multiple regions from a buffer to an image. Useful for uploading texture arrays, cube maps, or mip levels from a single buffer.</p> <pre><code>zest_bool zest_imm_CopyBufferRegionsToImage(\n    zest_queue queue,\n    zest_buffer_image_copy_t *regions,\n    zest_uint regions_count,\n    zest_buffer buffer,\n    zest_image image\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>regions</code> - Array of copy region descriptors - <code>regions_count</code> - Number of regions - <code>buffer</code> - Source buffer - <code>image</code> - Destination image</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Upload 6 faces of a cube map\nzest_buffer_image_copy_t regions[6];\n// ... configure regions for each face ...\n\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_TransitionImage(queue, cube_map, zest_image_layout_transfer_dst_optimal, 0, 1, 0, 6);\nzest_imm_CopyBufferRegionsToImage(queue, regions, 6, staging, cube_map);\nzest_imm_TransitionImage(queue, cube_map, zest_image_layout_shader_read_only_optimal, 0, 1, 0, 6);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_transitionimage","title":"zest_imm_TransitionImage","text":"<p>Transition an image to a new layout with full control over mip levels and array layers. Required before and after many image operations. Failure to transition images correctly will result in validation errors and undefined behaviour.</p> <pre><code>zest_bool zest_imm_TransitionImage(\n    zest_queue queue,\n    zest_image image,\n    zest_image_layout new_layout,\n    zest_uint base_mip_index,\n    zest_uint mip_levels,\n    zest_uint base_array_index,\n    zest_uint layer_count\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>image</code> - Image to transition - <code>new_layout</code> - Target layout (e.g., <code>zest_image_layout_shader_read_only_optimal</code>) - <code>base_mip_index</code> - First mip level to transition - <code>mip_levels</code> - Number of mip levels (use <code>ZEST__ALL_MIPS</code> for all) - <code>base_array_index</code> - First array layer to transition - <code>layer_count</code> - Number of layers (use <code>ZEST__ALL_LAYERS</code> for all)</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Common layouts: - <code>zest_image_layout_undefined</code> - Initial/don't care - <code>zest_image_layout_transfer_dst_optimal</code> - Destination for copies - <code>zest_image_layout_transfer_src_optimal</code> - Source for copies - <code>zest_image_layout_shader_read_only_optimal</code> - Sampling in shaders - <code>zest_image_layout_general</code> - Storage images - <code>zest_image_layout_color_attachment_optimal</code> - Render target</p>"},{"location":"api-reference/immediate/#zest_imm_generatemipmaps","title":"zest_imm_GenerateMipMaps","text":"<p>Generate mip maps for an image using hardware filtering. The image must have been created with multiple mip levels.</p> <pre><code>zest_bool zest_imm_GenerateMipMaps(zest_queue queue, zest_image image);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle (must be graphics queue for blit operations) - <code>image</code> - Image to generate mips for</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Generate mips after uploading base level\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_GenerateMipMaps(queue, texture);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_clearcolorimage","title":"zest_imm_ClearColorImage","text":"<p>Clear a color image to a specified value.</p> <pre><code>zest_bool zest_imm_ClearColorImage(\n    zest_queue queue,\n    zest_image image,\n    zest_clear_value_t clear_value\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>image</code> - Color image to clear - <code>clear_value</code> - Clear color (use <code>.color</code> field of the union)</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>zest_clear_value_t clear = { .color = { 0.0f, 0.0f, 0.0f, 1.0f } };\n\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_TransitionImage(queue, image, zest_image_layout_transfer_dst_optimal, 0, 1, 0, 1);\nzest_imm_ClearColorImage(queue, image, clear);\nzest_imm_TransitionImage(queue, image, zest_image_layout_shader_read_only_optimal, 0, 1, 0, 1);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_cleardepthstencilimage","title":"zest_imm_ClearDepthStencilImage","text":"<p>Clear a depth/stencil image to specified depth and stencil values.</p> <pre><code>zest_bool zest_imm_ClearDepthStencilImage(\n    zest_queue queue,\n    zest_image image,\n    float depth,\n    zest_uint stencil\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>image</code> - Depth/stencil image to clear - <code>depth</code> - Depth clear value (typically 1.0 for far plane) - <code>stencil</code> - Stencil clear value (typically 0)</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>zest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_ClearDepthStencilImage(queue, depth_buffer, 1.0f, 0);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_blitimage","title":"zest_imm_BlitImage","text":"<p>Blit (scaled copy) from one image to another with filtering. Useful for resizing images, format conversion, or copying between images of different dimensions.</p> <pre><code>zest_bool zest_imm_BlitImage(\n    zest_queue queue,\n    zest_image src_image,\n    zest_image dst_image,\n    int src_x, int src_y,\n    int src_width, int src_height,\n    int dst_x, int dst_y,\n    int dst_width, int dst_height,\n    zest_filter_type filter\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle (must be graphics queue) - <code>src_image</code> - Source image - <code>dst_image</code> - Destination image - <code>src_x</code>, <code>src_y</code> - Top-left corner of source region - <code>src_width</code>, <code>src_height</code> - Source region dimensions - <code>dst_x</code>, <code>dst_y</code> - Top-left corner of destination region - <code>dst_width</code>, <code>dst_height</code> - Destination region dimensions - <code>filter</code> - <code>zest_filter_nearest</code> or <code>zest_filter_linear</code></p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Downscale an image by half\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_BlitImage(queue, src, dst,\n    0, 0, 1024, 1024,  // source region\n    0, 0, 512, 512,    // destination region (half size)\n    zest_filter_linear);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#zest_imm_resolveimage","title":"zest_imm_ResolveImage","text":"<p>Resolve a multisampled image to a single-sampled image. Used to convert MSAA render targets to regular textures for further processing or display.</p> <pre><code>zest_bool zest_imm_ResolveImage(\n    zest_queue queue,\n    zest_image src_image,\n    zest_image dst_image\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>src_image</code> - Multisampled source image - <code>dst_image</code> - Single-sampled destination image (must match dimensions)</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p>"},{"location":"api-reference/immediate/#compute-operations","title":"Compute Operations","text":""},{"location":"api-reference/immediate/#zest_imm_sendpushconstants","title":"zest_imm_SendPushConstants","text":"<p>Send push constant data to shaders. Must be called inside an immediate command buffer.</p> <pre><code>void zest_imm_SendPushConstants(\n    zest_queue queue,\n    void *data,\n    zest_uint size\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>data</code> - Pointer to push constant data - <code>size</code> - Size in bytes</p>"},{"location":"api-reference/immediate/#zest_imm_bindcomputepipeline","title":"zest_imm_BindComputePipeline","text":"<p>Bind a compute pipeline for subsequent dispatch calls.</p> <pre><code>void zest_imm_BindComputePipeline(zest_queue queue, zest_compute compute);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>compute</code> - Compute pipeline handle</p>"},{"location":"api-reference/immediate/#zest_imm_dispatchcompute","title":"zest_imm_DispatchCompute","text":"<p>Dispatch a compute workload. Must call <code>zest_imm_BindComputePipeline</code> first.</p> <pre><code>zest_bool zest_imm_DispatchCompute(\n    zest_queue queue,\n    zest_uint group_count_x,\n    zest_uint group_count_y,\n    zest_uint group_count_z\n);\n</code></pre> <p>Parameters: - <code>queue</code> - Queue handle from <code>zest_imm_BeginCommandBuffer</code> - <code>group_count_x/y/z</code> - Number of work groups in each dimension</p> <p>Returns: <code>ZEST_TRUE</code> on success.</p> <p>Example: <pre><code>// Run a compute shader outside frame graph\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_compute);\nzest_imm_BindComputePipeline(queue, blur_compute);\nzest_imm_SendPushConstants(queue, &amp;params, sizeof(params));\nzest_imm_DispatchCompute(queue, (width + 15) / 16, (height + 15) / 16, 1);\nzest_imm_EndCommandBuffer(queue);\n</code></pre></p>"},{"location":"api-reference/immediate/#complete-example","title":"Complete Example","text":"<pre><code>// Full texture upload workflow\nvoid upload_texture(zest_device device, zest_image texture, void *pixels, zest_size size) {\n    // Create staging buffer with pixel data\n    zest_buffer staging = zest_CreateStagingBuffer(device, size, pixels);\n\n    // Upload to GPU\n    zest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\n    zest_imm_TransitionImage(queue, texture, zest_image_layout_transfer_dst_optimal, 0, 1, 0, 1);\n    zest_imm_CopyBufferToImage(queue, staging, texture, size);\n    zest_imm_TransitionImage(queue, texture, zest_image_layout_transfer_src_optimal, 0, 1, 0, 1);\n    zest_imm_EndCommandBuffer(queue);\n\n    // Generate mipmaps (requires graphics queue for blit)\n    queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\n    zest_imm_GenerateMipMaps(queue, texture);\n    zest_imm_EndCommandBuffer(queue);\n\n    // Clean up staging buffer\n    zest_FreeBuffer(staging);\n}\n</code></pre>"},{"location":"api-reference/immediate/#see-also","title":"See Also","text":"<ul> <li>Command API - Frame graph commands</li> <li>Buffers Concept</li> <li>Image API - Image creation and management</li> </ul>"},{"location":"api-reference/layer/","title":"Layer API","text":"<p>Layers are the primary mechanism for batching and drawing instanced geometry (sprites, billboards, meshes). They manage staging buffers, draw instructions, and automatic buffer growth.</p> <p>You can consider layers as a convenient way to do instanced based drawing but they're not essential and you can easily roll your own method depending on what you need.</p>"},{"location":"api-reference/layer/#layer-types","title":"Layer Types","text":"<p>Zest provides three layer types:</p> <ul> <li>Instance Layer - For sprites, billboards, and 2D quads. Each instance is a single struct drawn as a quad or whatever else you construct in the vertex shader.</li> <li>Mesh Layer - For dynamic geometry where you control vertices and indices directly.</li> <li>Instance Mesh Layer - For instanced 3D meshes. Upload meshes once, then draw many instances.</li> </ul>"},{"location":"api-reference/layer/#layer-creation","title":"Layer Creation","text":""},{"location":"api-reference/layer/#zest_createinstancelayer","title":"zest_CreateInstanceLayer","text":"<p>Create an instance layer for drawing sprites, billboards, or other small pieces of geometry that you construct in the vertex shader. The layer manages staging buffers that auto-grow as needed.</p> <pre><code>zest_layer_handle zest_CreateInstanceLayer(\n    zest_context context,\n    const char *name,\n    zest_size type_size\n);\n</code></pre> <p>Parameters: - <code>context</code> - The Zest context - <code>name</code> - Unique name for the layer - <code>type_size</code> - Size of your instance struct in bytes (e.g., <code>sizeof(my_sprite_t)</code>)</p> <p>Returns: Handle to the created layer.</p> <p>Example: <pre><code>typedef struct {\n    zest_vec4 position;  // x, y, z, scale\n    zest_vec4 uv;        // u, v, width, height\n    zest_uint color;     // packed RGBA\n} sprite_instance_t;\n\nzest_layer_handle sprites = zest_CreateInstanceLayer(context, \"sprites\", sizeof(sprite_instance_t));\n</code></pre></p>"},{"location":"api-reference/layer/#zest_createfifinstancelayer","title":"zest_CreateFIFInstanceLayer","text":"<p>Create an instance layer with separate buffers for each frame-in-flight. Use this when you need manual control over buffer uploads rather than using transient buffers each frame.</p> <pre><code>zest_layer_handle zest_CreateFIFInstanceLayer(\n    zest_context context,\n    const char *name,\n    zest_size type_size,\n    zest_uint max_instances\n);\n</code></pre> <p>Parameters: - <code>context</code> - The Zest context - <code>name</code> - Unique name for the layer - <code>type_size</code> - Size of your instance struct in bytes - <code>max_instances</code> - Initial capacity for instances</p> <p>Returns: Handle to the created layer.</p>"},{"location":"api-reference/layer/#zest_createmeshlayer","title":"zest_CreateMeshLayer","text":"<p>Create a mesh layer for dynamic geometry where you build vertices and indices each frame or just have a static mesh that you upload once and draw whenever you need.</p> <pre><code>zest_layer_handle zest_CreateMeshLayer(\n    zest_context context,\n    const char *name,\n    zest_size vertex_type_size\n);\n</code></pre> <p>Parameters: - <code>context</code> - The Zest context - <code>name</code> - Unique name for the layer - <code>vertex_type_size</code> - Size of your vertex struct in bytes</p> <p>Returns: Handle to the created layer.</p> <p>Example: <pre><code>typedef struct {\n    zest_vec3 position;\n    zest_vec2 uv;\n    zest_uint color;\n} mesh_vertex_t;\n\nzest_layer_handle dynamic_mesh = zest_CreateMeshLayer(context, \"dynamic_geo\", sizeof(mesh_vertex_t));\n</code></pre></p>"},{"location":"api-reference/layer/#zest_createinstancemeshlayer","title":"zest_CreateInstanceMeshLayer","text":"<p>Create an instance mesh layer for drawing many instances of pre-uploaded meshes. Add meshes to the layer with <code>zest_AddMeshToLayer</code>, then draw instances each frame using an index to the mesh in the layer that you want to draw.</p> <p>You must calculate the required vertex and index capacity that you'll need ahead of time as the vertex and index capacity of the layer will not be grown as needed.</p> <pre><code>zest_layer_handle zest_CreateInstanceMeshLayer(\n    zest_context context,\n    const char *name,\n    zest_size instance_struct_size,\n    zest_size vertex_capacity,\n    zest_size index_capacity\n);\n</code></pre> <p>Parameters: - <code>context</code> - The Zest context - <code>name</code> - Unique name for the layer - <code>instance_struct_size</code> - Size of your instance struct in bytes - <code>vertex_capacity</code> - Initial vertex buffer capacity in bytes - <code>index_capacity</code> - Initial index buffer capacity in bytes</p> <p>Returns: Handle to the created layer.</p> <p>Example: <pre><code>typedef struct {\n    zest_matrix4 transform;\n    zest_vec4 color;\n} mesh_instance_t;\n\nzest_layer_handle meshes = zest_CreateInstanceMeshLayer(\n    context, \"3d_meshes\",\n    sizeof(mesh_instance_t),\n    1024 * 1024,  // 1MB vertex buffer\n    512 * 1024    // 512KB index buffer\n);\n</code></pre></p>"},{"location":"api-reference/layer/#zest_getlayer","title":"zest_GetLayer","text":"<p>Get a layer pointer from a handle. Call once per frame and reuse the pointer for better performance.</p> <pre><code>zest_layer zest_GetLayer(zest_layer_handle handle);\n</code></pre> <p>Parameters: - <code>handle</code> - Layer handle from creation</p> <p>Returns: Layer pointer for use with other layer functions.</p> <p>Example: <pre><code>zest_layer layer = zest_GetLayer(sprite_layer_handle);\n// Use 'layer' for all subsequent operations this frame\n</code></pre></p>"},{"location":"api-reference/layer/#zest_freelayer","title":"zest_FreeLayer","text":"<p>Free a layer and all its resources.</p> <pre><code>void zest_FreeLayer(zest_layer_handle layer);\n</code></pre>"},{"location":"api-reference/layer/#instance-recording","title":"Instance Recording","text":""},{"location":"api-reference/layer/#zest_startinstanceinstructions","title":"zest_StartInstanceInstructions","text":"<p>Begin recording instances for a layer. This is generally used internally but can be used for more advanced things where you want manage your own instance instructions.</p> <pre><code>void zest_StartInstanceInstructions(zest_layer layer);\n</code></pre> <p>Usage: Prepares the layer for receiving new instance data. Must be paired with <code>zest_EndInstanceInstructions</code>.</p>"},{"location":"api-reference/layer/#zest_endinstanceinstructions","title":"zest_EndInstanceInstructions","text":"<p>End recording instances for a layer. Call after all instances are added. For advanced used if your managing your own instanct instructions. This will add the current instruction to the list of instructions in the layer ready to be processed when rendering and executing draw calls.</p> <pre><code>void zest_EndInstanceInstructions(zest_layer layer);\n</code></pre> <p>Usage: Finalizes the current draw instruction. Required before the layer can be drawn.</p>"},{"location":"api-reference/layer/#zest_maybeendinstanceinstructions","title":"zest_MaybeEndInstanceInstructions","text":"<p>Conditionally end instance instructions if the frame-in-flight changed. Useful for FIF layers with manual buffer management.</p> <pre><code>zest_bool zest_MaybeEndInstanceInstructions(zest_layer layer);\n</code></pre> <p>Returns: <code>ZEST_TRUE</code> if instructions were ended, <code>ZEST_FALSE</code> otherwise.</p>"},{"location":"api-reference/layer/#zest_nextinstance","title":"zest_NextInstance","text":"<p>Get a pointer to the next instance slot and advance the instance pointer. You'll need to use this function when creating your \"DrawSprite/DrawBillboard/DrawMeshInstance\" function.</p> <pre><code>void* zest_NextInstance(zest_layer layer);\n</code></pre> <p>Returns: Pointer to the next instance slot. Cast to your instance struct type.</p> <p>Example: <pre><code>zest_SetInstanceInstructions(layer, pipeline_template);\n\nfor (int i = 0; i &lt; sprite_count; i++) {\n    sprite_instance_t *instance = (sprite_instance_t*)zest_NextInstance(layer);\n    instance-&gt;position = sprites[i].position;\n    instance-&gt;uv = sprites[i].uv;\n    instance-&gt;color = sprites[i].color;\n}\n</code></pre></p>"},{"location":"api-reference/layer/#zest_drawinstancebuffer","title":"zest_DrawInstanceBuffer","text":"<p>Copy a buffer of pre-prepared instances directly into the layer. Useful when instance data is computed elsewhere.</p> <pre><code>zest_draw_buffer_result zest_DrawInstanceBuffer(\n    zest_layer layer,\n    void *src,\n    zest_uint amount\n);\n</code></pre> <p>Parameters: - <code>layer</code> - The layer to draw to - <code>src</code> - Source buffer containing instance data - <code>amount</code> - Number of instances to copy</p> <p>Returns: Result enum: - <code>zest_draw_buffer_result_ok</code> - Success - <code>zest_draw_buffer_result_buffer_grew</code> - Buffer was resized - <code>zest_draw_buffer_result_failed_to_grow</code> - Failed to resize buffer</p>"},{"location":"api-reference/layer/#zest_drawinstanceinstruction","title":"zest_DrawInstanceInstruction","text":"<p>Record a draw instruction for a number of instances when writing directly to the staging buffer.</p> <pre><code>void zest_DrawInstanceInstruction(zest_layer layer, zest_uint amount);\n</code></pre> <p>Parameters: - <code>layer</code> - The layer - <code>amount</code> - Number of instances to draw</p>"},{"location":"api-reference/layer/#instance-layer-state","title":"Instance Layer State","text":""},{"location":"api-reference/layer/#zest_startinstancedrawing","title":"zest_StartInstanceDrawing","text":"<p>Set the pipeline for the current draw instruction. Call this before adding instances that should use a specific pipeline.</p> <pre><code>void zest_StartInstanceDrawing(zest_layer layer, zest_pipeline_template pipeline);\n</code></pre> <p>Parameters: - <code>layer</code> - The layer - <code>pipeline</code> - Pipeline template to use for drawing</p> <p>Example: <pre><code>// Draw some sprites specifying a pipeline that you want to use for the draw call\nzest_StartInstanceDrawing(layer, sprite_pipeline);\nfor (int i = 0; i &lt; normal_sprites; i++) {\n    sprite_instance_t *inst = (sprite_instance_t*)zest_NextInstance(layer);\n    // ... fill instance data\n}\n\n// Switch pipeline for glowing sprites. This will end the previous instruction and start a new one.\nzest_StartInstanceDrawing(layer, glow_pipeline);\nfor (int i = 0; i &lt; glow_sprites; i++) {\n    sprite_instance_t *inst = (sprite_instance_t*)zest_NextInstance(layer);\n    // ... fill instance data\n}\n</code></pre></p>"},{"location":"api-reference/layer/#zest_getinstancelayercount","title":"zest_GetInstanceLayerCount","text":"<p>Get the current number of instances recorded in the layer.</p> <pre><code>zest_uint zest_GetInstanceLayerCount(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_getlayerinstancesize","title":"zest_GetLayerInstanceSize","text":"<p>Get the total size in bytes of all instances in the layer.</p> <pre><code>zest_size zest_GetLayerInstanceSize(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#mesh-layer-operations","title":"Mesh Layer Operations","text":""},{"location":"api-reference/layer/#zest_addmeshtolayer","title":"zest_AddMeshToLayer","text":"<p>Add a mesh to an instance mesh layer. The mesh data is uploaded to the GPU and can be instanced many times.</p> <p>Note that the meshes that you add must use the same vertex struct.</p> <pre><code>zest_uint zest_AddMeshToLayer(\n    zest_layer layer,\n    zest_mesh src_mesh,\n    zest_uint texture_index\n);\n</code></pre> <p>Parameters: - <code>layer</code> - Instance mesh layer - <code>src_mesh</code> - Source mesh handle - <code>texture_index</code> - Texture bindless index for this mesh</p> <p>Returns: Mesh index for use with <code>zest_StartInstanceMeshDrawing</code>.</p> <p>Example: <pre><code>zest_mesh cube_mesh = zest_CreateMesh(...);\nzest_uint cube_id = zest_AddMeshToLayer(mesh_layer, cube_mesh, cube_texture_index);\n\n// Later, when drawing:\nzest_StartInstanceMeshDrawing(layer, cube_id, mesh_pipeline);\n</code></pre></p>"},{"location":"api-reference/layer/#zest_getlayermeshoffsets","title":"zest_GetLayerMeshOffsets","text":"<p>Get offset data for a mesh in the layer. Useful for custom draw routines.</p> <pre><code>const zest_mesh_offset_data_t* zest_GetLayerMeshOffsets(zest_layer layer, zest_uint mesh_index);\n</code></pre> <p>Returns: Pointer to offset data containing: - <code>vertex_offset</code> - Offset in vertex buffer - <code>index_offset</code> - Offset in index buffer - <code>vertex_count</code> - Number of vertices - <code>index_count</code> - Number of indices - <code>texture_index</code> - Associated texture descriptor index</p>"},{"location":"api-reference/layer/#zest_getlayermeshtextureindex","title":"zest_GetLayerMeshTextureIndex","text":"<p>Get the texture descriptor index associated with a mesh.</p> <pre><code>zest_uint zest_GetLayerMeshTextureIndex(zest_layer layer, zest_uint mesh_index);\n</code></pre>"},{"location":"api-reference/layer/#zest_setmeshdrawing","title":"zest_SetMeshDrawing","text":"<p>Set the pipeline for mesh layer drawing.</p> <pre><code>void zest_SetMeshDrawing(zest_layer layer, zest_pipeline_template pipeline);\n</code></pre>"},{"location":"api-reference/layer/#zest_startinstancemeshdrawing","title":"zest_StartInstanceMeshDrawing","text":"<p>Set up drawing for a specific mesh with a pipeline. Call this and then add instances that you want to draw</p> <pre><code>void zest_StartInstanceMeshDrawing(\n    zest_layer layer,\n    zest_uint mesh_index,\n    zest_pipeline_template pipeline\n);\n</code></pre> <p>Example: <pre><code>zest_StartInstanceMeshDrawing(mesh_layer, mesh_index, app-&gt;shadow_pipeline);\n//Your own function to fill out instance data\nvoid DrawInstancedMesh(zest_layer layer, position, rotation, scale) {\n</code></pre></p>"},{"location":"api-reference/layer/#zest_getvertexwritebuffer-zest_getindexwritebuffer","title":"zest_GetVertexWriteBuffer / zest_GetIndexWriteBuffer","text":"<p>Get the staging buffers for direct vertex/index writing.</p> <pre><code>zest_buffer zest_GetVertexWriteBuffer(zest_layer layer);\nzest_buffer zest_GetIndexWriteBuffer(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_pushindex","title":"zest_PushIndex","text":"<p>Push an index to the index staging buffer. Automatically grows the buffer if needed.</p> <pre><code>void zest_PushIndex(zest_layer layer, zest_uint offset);\n</code></pre>"},{"location":"api-reference/layer/#zest_growmeshvertexbuffers-zest_growmeshindexbuffers","title":"zest_GrowMeshVertexBuffers / zest_GrowMeshIndexBuffers","text":"<p>Manually trigger buffer growth when you know more space is needed.</p> <pre><code>void zest_GrowMeshVertexBuffers(zest_layer layer);\nvoid zest_GrowMeshIndexBuffers(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_getlayervertexmemoryinuse-zest_getlayerindexmemoryinuse","title":"zest_GetLayerVertexMemoryInUse / zest_GetLayerIndexMemoryInUse","text":"<p>Get current memory usage for mesh layers.</p> <pre><code>zest_size zest_GetLayerVertexMemoryInUse(zest_layer layer);\nzest_size zest_GetLayerIndexMemoryInUse(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#drawing","title":"Drawing","text":""},{"location":"api-reference/layer/#zest_drawinstancelayer","title":"zest_DrawInstanceLayer","text":"<p>Draw all instances in a layer. Use as a frame graph task callback.</p> <pre><code>void zest_DrawInstanceLayer(const zest_command_list command_list, void *user_data);\n</code></pre> <p>Parameters: - <code>command_list</code> - Command list from the frame graph - <code>user_data</code> - Layer pointer (pass via <code>zest_SetPassTask</code>)</p> <p>Example: <pre><code>zest_BeginRenderPass(\"sprites\");\n    zest_SetPassTask(zest_DrawInstanceLayer, sprite_layer);\nzest_EndPass();\n</code></pre></p>"},{"location":"api-reference/layer/#zest_drawinstancemeshlayer","title":"zest_DrawInstanceMeshLayer","text":"<p>Draw all instances in an instance mesh layer. Use as a frame graph task callback.</p> <pre><code>void zest_DrawInstanceMeshLayer(const zest_command_list command_list, void *user_data);\n</code></pre> <p>Parameters: - <code>command_list</code> - Command list from the frame graph - <code>user_data</code> - Layer pointer (pass via <code>zest_SetPassTask</code>)</p> <p>Example: <pre><code>zest_BeginRenderPass(\"Meshes\");\n    zest_SetPassTask(zest_DrawInstanceMeshLayer, mesh_layer);\nzest_EndPass();\n</code></pre></p>"},{"location":"api-reference/layer/#zest_drawinstancemeshlayerwithpipeline","title":"zest_DrawInstanceMeshLayerWithPipeline","text":"<p>Draw an instance mesh layer with a specific pipeline override. This is useful for when you need to draw multiple passes of the same meshes. For example one pass for rendering shadow depth followed by a normal render with the shadows. See the cascading shadows example for a demonstration of this.</p> <pre><code>void zest_DrawInstanceMeshLayerWithPipeline(\n    const zest_command_list command_list,\n    zest_layer layer,\n    zest_pipeline_template pipeline\n);\n</code></pre>"},{"location":"api-reference/layer/#zest_uploadlayerstagingdata","title":"zest_UploadLayerStagingData","text":"<p>Upload layer staging data to the GPU. Call in an upload callback before drawing.</p> <pre><code>void zest_UploadLayerStagingData(zest_layer layer, const zest_command_list command_list);\n</code></pre>"},{"location":"api-reference/layer/#zest_uploadinstancelayerdata","title":"zest_UploadInstanceLayerData","text":"<p>Callback for uploading instance layer data. Use with frame graph upload tasks.</p> <p>Note that if you have more then one layer to upload then you can call multiple of these functions in your own callback instead rather then create multiple transfer passes.</p> <pre><code>void zest_UploadInstanceLayerData(const zest_command_list command_list, void *user_data);\n</code></pre> <p>Example: <pre><code>zest_BeginTransferPass(\"Upload Layer\");\n    zest_SetPassTask(zest_UploadInstanceLayerData, sprite_layer);\nzest_EndPass();\n</code></pre></p>"},{"location":"api-reference/layer/#layer-properties","title":"Layer Properties","text":""},{"location":"api-reference/layer/#zest_setlayerviewport","title":"zest_SetLayerViewPort","text":"<p>Set the viewport and scissor for layer drawing.</p> <pre><code>void zest_SetLayerViewPort(\n    zest_layer layer,\n    int x, int y,\n    zest_uint scissor_width, zest_uint scissor_height,\n    float viewport_width, float viewport_height\n);\n</code></pre> <p>Parameters: - <code>layer</code> - The layer - <code>x</code>, <code>y</code> - Scissor offset - <code>scissor_width</code>, <code>scissor_height</code> - Scissor dimensions - <code>viewport_width</code>, <code>viewport_height</code> - Viewport dimensions</p>"},{"location":"api-reference/layer/#zest_setlayerscissor","title":"zest_SetLayerScissor","text":"<p>Set only the scissor rectangle for the current draw instruction. Call this after you start an instruction like zest_StartInstanceDrawing.</p> <pre><code>void zest_SetLayerScissor(\n    zest_layer layer,\n    int offset_x, int offset_y,\n    zest_uint scissor_width, zest_uint scissor_height\n);\n</code></pre>"},{"location":"api-reference/layer/#zest_setlayerdrawingviewport","title":"zest_SetLayerDrawingViewport","text":"<p>Set viewport/scissor for the current draw instruction. Call this after you start an instruction like zest_StartInstanceDrawing.</p> <pre><code>void zest_SetLayerDrawingViewport(\n    zest_layer layer,\n    int x, int y,\n    zest_uint scissor_width, zest_uint scissor_height,\n    float viewport_width, float viewport_height\n);\n</code></pre>"},{"location":"api-reference/layer/#zest_setlayersizetoswapchain","title":"zest_SetLayerSizeToSwapchain","text":"<p>Update layer viewport to match the current swapchain size.</p> <pre><code>void zest_SetLayerSizeToSwapchain(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_setlayersize","title":"zest_SetLayerSize","text":"<p>Set the layer size explicitly.</p> <pre><code>void zest_SetLayerSize(zest_layer layer, float width, float height);\n</code></pre>"},{"location":"api-reference/layer/#zest_getlayerscissor-zest_getlayerviewport","title":"zest_GetLayerScissor / zest_GetLayerViewport","text":"<p>Get the current scissor/viewport settings.</p> <pre><code>zest_scissor_rect_t zest_GetLayerScissor(zest_layer layer);\nzest_viewport_t zest_GetLayerViewport(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_setlayercolor-zest_setlayercolorf","title":"zest_SetLayerColor / zest_SetLayerColorf","text":"<p>Set the layer color. The alpha value controls the blend between additive (0) and alpha blending (1).</p> <p>These functions will be removed</p> <pre><code>void zest_SetLayerColor(zest_layer layer, zest_byte r, zest_byte g, zest_byte b, zest_byte a);\nvoid zest_SetLayerColorf(zest_layer layer, float r, float g, float b, float a);\n</code></pre> <p>Example: <pre><code>// Full opacity alpha blending\nzest_SetLayerColorf(layer, 1.0f, 1.0f, 1.0f, 1.0f);\n\n// Semi-additive blending\nzest_SetLayerColorf(layer, 1.0f, 1.0f, 1.0f, 0.5f);\n</code></pre></p>"},{"location":"api-reference/layer/#zest_setlayerintensity","title":"zest_SetLayerIntensity","text":"<p>Set the intensity (brightness) of the layer. Values above 1.0 make sprites brighter due to pre-multiplied blending.</p> <p>Will be removed</p> <pre><code>void zest_SetLayerIntensity(zest_layer layer, float value);\n</code></pre>"},{"location":"api-reference/layer/#zest_setlayerpushconstants-zest_getlayerpushconstants","title":"zest_SetLayerPushConstants / zest_GetLayerPushConstants","text":"<p>Set or get push constants for the current draw instruction. These will get uploaded to the GPU for each instruction in the layer.</p> <pre><code>void zest_SetLayerPushConstants(zest_layer layer, void *push_constants, zest_size size);\nvoid* zest_GetLayerPushConstants(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_setlayeruserdata-zest_getlayeruserdata","title":"zest_SetLayerUserData / zest_GetLayerUserData","text":"<p>Store custom data with a layer.</p> <pre><code>void zest_SetLayerUserData(zest_layer layer, void *data);\n#define zest_GetLayerUserData(type, layer) ((type *)layer-&gt;user_data)\n</code></pre>"},{"location":"api-reference/layer/#layer-reset","title":"Layer Reset","text":""},{"location":"api-reference/layer/#zest_resetlayer","title":"zest_ResetLayer","text":"<p>Set the layer frame in flight to the next layer. Use this if you're manually setting the current fif for the layer so that you can avoid uploading the staging buffers every frame and only do so when it's neccessary.</p> <pre><code>void zest_ResetLayer(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_resetinstancelayer","title":"zest_ResetInstanceLayer","text":"<p>Same as ResetLayer but specifically for an instance layer</p> <pre><code>void zest_ResetInstanceLayer(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_resetinstancelayerdrawing","title":"zest_ResetInstanceLayerDrawing","text":"<p>Reset the drawing for an instance layer. This is called after all drawing is done and dispatched to the gpu.</p> <pre><code>void zest_ResetInstanceLayerDrawing(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#draw-instructions","title":"Draw Instructions","text":""},{"location":"api-reference/layer/#zest_nextlayerinstruction","title":"zest_NextLayerInstruction","text":"<p>Get the next draw instruction slot.</p> <p><pre><code>zest_layer_instruction_t* zest_NextLayerInstruction(zest_layer layer);\n</code></pre> Example <pre><code>zest_layer_instruction_t *current = zest_NextLayerInstruction(layer);\nwhile(current) {\n    ...\n    zest_cmd_DrawLayerInstruction(command_list, 6, current);\n    current = zest_NextLayerInstruction(layer);\n}\n</code></pre></p>"},{"location":"api-reference/layer/#zest_getlayerinstruction-zest_getlayerinstructioncount","title":"zest_GetLayerInstruction / zest_GetLayerInstructionCount","text":"<p>Access recorded draw instructions.</p> <pre><code>const zest_layer_instruction_t* zest_GetLayerInstruction(zest_layer layer, zest_uint index);\nzest_uint zest_GetLayerInstructionCount(zest_layer layer);\n</code></pre> <p>Example <pre><code>zest_uint count = zest_GetLayerInstructionCount(layer);\nfor(zest_uint i = 0; i != count; i++) {\n    const zest_layer_instruction_t* zest_GetLayerInstruction(layer, i);\n    ...\n    zest_cmd_DrawLayerInstruction(command_list, 6, current);\n}\n</code></pre></p>"},{"location":"api-reference/layer/#buffer-access","title":"Buffer Access","text":""},{"location":"api-reference/layer/#zest_getlayervertexbuffer-zest_getlayerresourcebuffer","title":"zest_GetLayerVertexBuffer / zest_GetLayerResourceBuffer","text":"<p>Get device-side buffers.</p> <pre><code>zest_buffer zest_GetLayerVertexBuffer(zest_layer layer);\nzest_buffer zest_GetLayerResourceBuffer(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_getlayerstagingvertexbuffer-zest_getlayerstagingindexbuffer","title":"zest_GetLayerStagingVertexBuffer / zest_GetLayerStagingIndexBuffer","text":"<p>Get staging buffers for CPU-side access.</p> <pre><code>zest_buffer zest_GetLayerStagingVertexBuffer(zest_layer layer);\nzest_buffer zest_GetLayerStagingIndexBuffer(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#zest_getlayervertexdescriptorindex","title":"zest_GetLayerVertexDescriptorIndex","text":"<p>Get the bindless descriptor index for the layer's vertex buffer.</p> <pre><code>zest_uint zest_GetLayerVertexDescriptorIndex(zest_layer layer, zest_bool last_frame);\n</code></pre>"},{"location":"api-reference/layer/#zest_getlayerframeinflight","title":"zest_GetLayerFrameInFlight","text":"<p>Get the current frame-in-flight index for the layer.</p> <pre><code>int zest_GetLayerFrameInFlight(zest_layer layer);\n</code></pre>"},{"location":"api-reference/layer/#frame-graph-integration","title":"Frame Graph Integration","text":""},{"location":"api-reference/layer/#zest_addtransientlayerresource","title":"zest_AddTransientLayerResource","text":"<p>Add a layer's buffer as a transient resource in the frame graph. This is an essential function when using layers to draw instanced data.</p> <pre><code>zest_resource_node zest_AddTransientLayerResource(\n    const char *name,\n    const zest_layer layer,\n    zest_bool prev_fif\n);\n</code></pre> <p>Example</p> <pre><code>zest_resource_node billboard_layer_resource = zest_AddTransientLayerResource(\"Billboards\", billboard_layer, false);\n...\nzest_BeginRenderPass(\"Particles Pass\");\nzest_ConnectInput(billboard_layer_resource);\nzest_SetPassTask(zest_DrawInstanceLayer, this);\nzest_ConnectSwapChainOutput();\nzest_EndPass();\n</code></pre>"},{"location":"api-reference/layer/#complete-example","title":"Complete Example","text":"<pre><code>// Create a sprite layer\nzest_layer_handle sprite_handle = zest_CreateInstanceLayer(context, \"sprites\", sizeof(sprite_t));\n\n// In your update function:\nvoid update_sprites(zest_layer layer, sprite_data_t *sprites, int count) {\n    zest_StartInstanceDrawing(layer, sprite_pipeline);\n\n    for (int i = 0; i &lt; count; i++) {\n        sprite_t *inst = (sprite_t*)zest_NextInstance(layer);\n        inst-&gt;position = sprites[i].position;\n        inst-&gt;uv = sprites[i].uv;\n        inst-&gt;color = sprites[i].color;\n    }\n\n    zest_EndInstanceInstructions(layer);  \n}\n\n// In your frame graph setup:\nzest_frame_graph setup_frame_graph() {\n    zest_layer sprite_layer = zest_GetLayer(sprite_layer_handle);\n    zest_BeginFrameGraph();\n    zest_resource_node sprite_layer_resource = zest_AddTransientLayerResource(\"Sprites\", sprite_layer, false);\n\n    zest_BeginRenderPass(\"main\");\n        zest_ConnectInput(sprite_layer_resource);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(zest_DrawInstanceLayer, sprite_layer);\n    zest_EndPass();\n\n    return zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"api-reference/layer/#see-also","title":"See Also","text":"<ul> <li>Layers Concept - Conceptual overview</li> <li>Instancing Tutorial - Step-by-step guide</li> <li>Pipeline API - Pipeline template configuration</li> </ul>"},{"location":"api-reference/math/","title":"Math API","text":"<p>Vector, matrix, and utility math functions for 3D graphics and game development. I expect that most people will just roll with there own or use glm or something but for the purposes of examples Zest has basic vector and matrix math for various things.</p>"},{"location":"api-reference/math/#vector-types","title":"Vector Types","text":"<pre><code>zest_vec2    // { float x, y }\nzest_vec3    // { float x, y, z }\nzest_vec4    // { float x, y, z, w } \nzest_ivec2   // { int x, y }\nzest_ivec3   // { int x, y, z }\nzest_matrix4 // 4x4 matrix (array of 4 zest_vec4) \n</code></pre>"},{"location":"api-reference/math/#vector-construction","title":"Vector Construction","text":""},{"location":"api-reference/math/#zest_vec2set-zest_vec3set-zest_vec4set","title":"<code>zest_Vec2Set</code> / <code>zest_Vec3Set</code> / <code>zest_Vec4Set</code>","text":"<p>Create a vector with specified component values.</p> <pre><code>zest_vec2 zest_Vec2Set(float x, float y);\nzest_vec3 zest_Vec3Set(float x, float y, float z);\nzest_vec4 zest_Vec4Set(float x, float y, float z, float w);\n</code></pre> <p>Usage: Initialize vectors for positions, directions, colors, or any multi-component data.</p> <pre><code>zest_vec3 position = zest_Vec3Set(10.0f, 5.0f, -3.0f);\nzest_vec4 color = zest_Vec4Set(1.0f, 0.5f, 0.0f, 1.0f);  // Orange, full alpha\n</code></pre>"},{"location":"api-reference/math/#zest_vec2set1-zest_vec3set1-zest_vec4set1","title":"<code>zest_Vec2Set1</code> / <code>zest_Vec3Set1</code> / <code>zest_Vec4Set1</code>","text":"<p>Create a vector with all components set to the same value.</p> <pre><code>zest_vec2 zest_Vec2Set1(float v);\nzest_vec3 zest_Vec3Set1(float v);\nzest_vec4 zest_Vec4Set1(float v);\n</code></pre> <p>Usage: Initialize uniform vectors for scaling, clearing, or default values.</p> <pre><code>zest_vec3 uniform_scale = zest_Vec3Set1(2.0f);  // Scale by 2x in all directions\nzest_vec4 white = zest_Vec4Set1(1.0f);          // White color with full alpha\n</code></pre>"},{"location":"api-reference/math/#vector-operations","title":"Vector Operations","text":""},{"location":"api-reference/math/#addition","title":"Addition","text":"<p>Add two vectors component-wise.</p> <pre><code>zest_vec2 zest_AddVec2(zest_vec2 left, zest_vec2 right);\nzest_vec3 zest_AddVec3(zest_vec3 left, zest_vec3 right);\nzest_vec4 zest_AddVec4(zest_vec4 left, zest_vec4 right);\nzest_ivec2 zest_AddiVec2(zest_ivec2 left, zest_ivec2 right);\nzest_ivec3 zest_AddiVec3(zest_ivec3 left, zest_ivec3 right);\n</code></pre> <p>Usage: Move objects, combine velocities, or accumulate forces.</p> <pre><code>zest_vec3 position = zest_Vec3Set(0, 0, 0);\nzest_vec3 velocity = zest_Vec3Set(1, 0, 0);\nposition = zest_AddVec3(position, velocity);  // Move object\n</code></pre>"},{"location":"api-reference/math/#subtraction","title":"Subtraction","text":"<p>Subtract two vectors component-wise.</p> <pre><code>zest_vec2 zest_SubVec2(zest_vec2 left, zest_vec2 right);\nzest_vec3 zest_SubVec3(zest_vec3 left, zest_vec3 right);\nzest_vec4 zest_SubVec4(zest_vec4 left, zest_vec4 right);\n</code></pre> <p>Usage: Calculate direction vectors, distances, or relative positions.</p> <pre><code>zest_vec3 player = zest_Vec3Set(10, 0, 5);\nzest_vec3 enemy = zest_Vec3Set(20, 0, 15);\nzest_vec3 to_enemy = zest_SubVec3(enemy, player);  // Direction from player to enemy\n</code></pre>"},{"location":"api-reference/math/#multiplication","title":"Multiplication","text":"<p>Multiply two vectors component-wise (Hadamard product).</p> <pre><code>zest_vec3 zest_MulVec3(zest_vec3 left, zest_vec3 right);\nzest_vec4 zest_MulVec4(zest_vec4 left, zest_vec4 right);\n</code></pre> <p>Usage: Apply per-axis scaling, combine color with lighting, or modulate values.</p> <pre><code>zest_vec3 base_scale = zest_Vec3Set(1, 2, 1);\nzest_vec3 modifier = zest_Vec3Set(2, 1, 3);\nzest_vec3 final_scale = zest_MulVec3(base_scale, modifier);  // (2, 2, 3)\n</code></pre>"},{"location":"api-reference/math/#division","title":"Division","text":"<p>Divide two vectors component-wise.</p> <pre><code>zest_vec3 zest_DivVec3(zest_vec3 left, zest_vec3 right);\nzest_vec4 zest_DivVec4(zest_vec4 left, zest_vec4 right);\n</code></pre> <p>Usage: Compute ratios or undo scaling operations.</p> <pre><code>zest_vec3 world_size = zest_Vec3Set(100, 50, 100);\nzest_vec3 grid_cells = zest_Vec3Set(10, 5, 10);\nzest_vec3 cell_size = zest_DivVec3(world_size, grid_cells);  // (10, 10, 10)\n</code></pre>"},{"location":"api-reference/math/#scaling","title":"Scaling","text":"<p>Multiply a vector by a scalar value.</p> <pre><code>zest_vec2 zest_ScaleVec2(zest_vec2 v, float s);\nzest_vec3 zest_ScaleVec3(zest_vec3 v, float s);\nzest_vec4 zest_ScaleVec4(zest_vec4 v, float s);\n</code></pre> <p>Usage: Scale velocity by delta time, adjust magnitude, or apply uniform transformations.</p> <pre><code>zest_vec3 velocity = zest_Vec3Set(10, 5, 0);\nfloat delta_time = 0.016f;\nzest_vec3 frame_movement = zest_ScaleVec3(velocity, delta_time);\n</code></pre>"},{"location":"api-reference/math/#normalization","title":"Normalization","text":"<p>Convert a vector to unit length (magnitude of 1).</p> <pre><code>zest_vec2 zest_NormalizeVec2(zest_vec2 v);\nzest_vec3 zest_NormalizeVec3(zest_vec3 v);\nzest_vec4 zest_NormalizeVec4(zest_vec4 v);\n</code></pre> <p>Usage: Get direction vectors, prepare vectors for dot/cross products, or ensure consistent movement speed.</p> <pre><code>zest_vec3 movement = zest_Vec3Set(3, 0, 4);\nzest_vec3 direction = zest_NormalizeVec3(movement);  // (0.6, 0, 0.8)\nzest_vec3 scaled_movement = zest_ScaleVec3(direction, speed);  // Move at constant speed\n</code></pre>"},{"location":"api-reference/math/#length","title":"Length","text":"<p>Calculate the magnitude (length) of a vector.</p> <pre><code>float zest_LengthVec2(zest_vec2 v);\nfloat zest_LengthVec3(zest_vec3 v);\n\n// Non-sqrt versions (squared length) - faster for comparisons\nfloat zest_LengthVec2NS(zest_vec2 v);\nfloat zest_LengthVec3NS(zest_vec3 v);\nfloat zest_LengthVec4NS(zest_vec4 v);\n</code></pre> <p>Usage: Calculate distances, check if vectors exceed thresholds, or validate normalization.</p> <pre><code>zest_vec3 velocity = zest_Vec3Set(3, 4, 0);\nfloat speed = zest_LengthVec3(velocity);  // 5.0\n\n// Use squared length for faster distance comparisons\nfloat dist_sq = zest_LengthVec3NS(zest_SubVec3(a, b));\nif (dist_sq &lt; radius * radius) { /* collision */ }\n</code></pre>"},{"location":"api-reference/math/#flip","title":"Flip","text":"<p>Negate all components of a vector.</p> <pre><code>zest_vec3 zest_FlipVec3(zest_vec3 v);\n</code></pre> <p>Usage: Reverse direction, create opposite forces, or reflect vectors.</p> <pre><code>zest_vec3 forward = zest_Vec3Set(0, 0, 1);\nzest_vec3 backward = zest_FlipVec3(forward);  // (0, 0, -1)\n</code></pre>"},{"location":"api-reference/math/#dot-product","title":"Dot Product","text":"<p>Calculate the dot product (scalar product) of two vectors.</p> <pre><code>float zest_DotProduct3(const zest_vec3 a, const zest_vec3 b);\nfloat zest_DotProduct4(const zest_vec4 a, const zest_vec4 b);\n</code></pre> <p>Usage: Calculate angles between vectors, project vectors, determine if vectors face the same direction, or compute lighting.</p> <pre><code>zest_vec3 surface_normal = zest_Vec3Set(0, 1, 0);\nzest_vec3 light_dir = zest_NormalizeVec3(zest_Vec3Set(1, 1, 0));\nfloat intensity = zest_DotProduct3(surface_normal, light_dir);  // Diffuse lighting\n\n// Check if facing same direction (positive = same, negative = opposite)\nif (zest_DotProduct3(player_forward, to_enemy) &gt; 0) { /* enemy is in front */ }\n</code></pre>"},{"location":"api-reference/math/#cross-product","title":"Cross Product","text":"<p>Calculate the cross product of two 3D vectors, producing a perpendicular vector.</p> <pre><code>zest_vec3 zest_CrossProduct(const zest_vec3 a, const zest_vec3 b);\n</code></pre> <p>Usage: Calculate surface normals, create perpendicular vectors, or determine winding order.</p> <pre><code>zest_vec3 edge1 = zest_SubVec3(v1, v0);\nzest_vec3 edge2 = zest_SubVec3(v2, v0);\nzest_vec3 normal = zest_NormalizeVec3(zest_CrossProduct(edge1, edge2));\n\n// Create a coordinate frame\nzest_vec3 up = zest_Vec3Set(0, 1, 0);\nzest_vec3 forward = zest_Vec3Set(0, 0, 1);\nzest_vec3 right = zest_CrossProduct(up, forward);\n</code></pre>"},{"location":"api-reference/math/#distance","title":"Distance","text":"<p>Calculate the 2D distance between two points.</p> <pre><code>float zest_Distance(float fromx, float fromy, float tox, float toy);\n</code></pre> <p>Usage: Quick 2D distance calculations for UI, 2D games, or screen-space operations.</p> <pre><code>float dist = zest_Distance(player_x, player_y, target_x, target_y);\nif (dist &lt; pickup_radius) { /* collect item */ }\n</code></pre>"},{"location":"api-reference/math/#matrix-operations","title":"Matrix Operations","text":""},{"location":"api-reference/math/#creation","title":"Creation","text":""},{"location":"api-reference/math/#zest_m4","title":"<code>zest_M4</code>","text":"<p>Create a diagonal matrix (identity matrix when v=1).</p> <pre><code>zest_matrix4 zest_M4(float v);\n</code></pre> <p>Usage: Initialize identity matrices or create uniform scaling matrices.</p> <pre><code>zest_matrix4 identity = zest_M4(1.0f);   // Identity matrix\nzest_matrix4 scaled = zest_M4(2.0f);     // Uniform scale by 2\n</code></pre>"},{"location":"api-reference/math/#zest_creatematrix4","title":"<code>zest_CreateMatrix4</code>","text":"<p>Create a complete transformation matrix with rotation, translation, and scale in one call.</p> <pre><code>zest_matrix4 zest_CreateMatrix4(float pitch, float yaw, float roll,\n                                 float x, float y, float z,\n                                 float sx, float sy, float sz);\n</code></pre> <ul> <li><code>pitch, yaw, roll</code> - Rotation angles in radians</li> <li><code>x, y, z</code> - Translation (position)</li> <li><code>sx, sy, sz</code> - Scale factors</li> </ul> <p>Usage: Create a full object transformation matrix efficiently.</p> <pre><code>zest_matrix4 transform = zest_CreateMatrix4(\n    0.0f, zest_Radians(45.0f), 0.0f,  // Rotated 45 degrees on Y\n    10.0f, 0.0f, 5.0f,                 // Position\n    1.0f, 1.0f, 1.0f                   // Uniform scale\n);\n</code></pre>"},{"location":"api-reference/math/#transformations","title":"Transformations","text":""},{"location":"api-reference/math/#zest_matrixtransform","title":"<code>zest_MatrixTransform</code>","text":"<p>Multiply two 4x4 matrices together.</p> <pre><code>zest_matrix4 zest_MatrixTransform(zest_matrix4 *in, zest_matrix4 *m);\n</code></pre> <p>Usage: Combine multiple transformations (e.g., model-view-projection).</p> <pre><code>zest_matrix4 model = zest_CreateMatrix4(...);\nzest_matrix4 view = zest_LookAt(...);\nzest_matrix4 model_view = zest_MatrixTransform(&amp;view, &amp;model);\nzest_matrix4 mvp = zest_MatrixTransform(&amp;projection, &amp;model_view);\n</code></pre>"},{"location":"api-reference/math/#zest_matrixtransformvector","title":"<code>zest_MatrixTransformVector</code>","text":"<p>Transform a vector by a matrix.</p> <pre><code>zest_vec4 zest_MatrixTransformVector(zest_matrix4 *mat, zest_vec4 vec);\n</code></pre> <p>Usage: Apply transformations to points or directions.</p> <pre><code>zest_vec4 local_pos = zest_Vec4Set(1, 0, 0, 1);  // w=1 for points\nzest_vec4 world_pos = zest_MatrixTransformVector(&amp;model_matrix, local_pos);\n\nzest_vec4 local_dir = zest_Vec4Set(0, 1, 0, 0);  // w=0 for directions\nzest_vec4 world_dir = zest_MatrixTransformVector(&amp;model_matrix, local_dir);\n</code></pre>"},{"location":"api-reference/math/#zest_scalematrix4","title":"<code>zest_ScaleMatrix4</code>","text":"<p>Scale a matrix uniformly by a scalar value.</p> <pre><code>zest_matrix4 zest_ScaleMatrix4(zest_matrix4 *m, float scalar);\n</code></pre> <p>Usage: Apply uniform scaling to an existing matrix.</p> <pre><code>zest_matrix4 base = zest_M4(1.0f);\nzest_matrix4 doubled = zest_ScaleMatrix4(&amp;base, 2.0f);\n</code></pre>"},{"location":"api-reference/math/#zest_scalematrix4x4","title":"<code>zest_ScaleMatrix4x4</code>","text":"<p>Scale a matrix by a vec4 (per-axis scaling).</p> <pre><code>zest_matrix4 zest_ScaleMatrix4x4(zest_matrix4 *m, zest_vec4 *v);\n</code></pre> <p>Usage: Apply non-uniform scaling to a matrix.</p> <pre><code>zest_matrix4 matrix = zest_M4(1.0f);\nzest_vec4 scale = zest_Vec4Set(2.0f, 1.0f, 0.5f, 1.0f);\nzest_matrix4 scaled = zest_ScaleMatrix4x4(&amp;matrix, &amp;scale);\n</code></pre>"},{"location":"api-reference/math/#rotations","title":"Rotations","text":"<p>Create rotation matrices around each axis. Angles are in radians.</p> <pre><code>zest_matrix4 zest_Matrix4RotateX(float angle);\nzest_matrix4 zest_Matrix4RotateY(float angle);\nzest_matrix4 zest_Matrix4RotateZ(float angle);\n</code></pre> <p>Usage: Build rotation matrices to combine with other transformations.</p> <pre><code>float angle = zest_Radians(45.0f);\nzest_matrix4 rot_y = zest_Matrix4RotateY(angle);\n\n// Combine rotations\nzest_matrix4 rot_x = zest_Matrix4RotateX(pitch);\nzest_matrix4 rot_y = zest_Matrix4RotateY(yaw);\nzest_matrix4 rotation = zest_MatrixTransform(&amp;rot_y, &amp;rot_x);\n</code></pre>"},{"location":"api-reference/math/#transpose","title":"Transpose","text":"<p>Swap rows and columns of a matrix.</p> <pre><code>zest_matrix4 zest_TransposeMatrix4(zest_matrix4 *mat);\n</code></pre> <p>Usage: Convert between row-major and column-major, or compute the inverse of orthonormal matrices.</p> <pre><code>zest_matrix4 transposed = zest_TransposeMatrix4(&amp;matrix);\n</code></pre>"},{"location":"api-reference/math/#inverse","title":"Inverse","text":"<p>Calculate the inverse of a 4x4 matrix.</p> <pre><code>zest_matrix4 zest_Inverse(zest_matrix4 *m);\n</code></pre> <p>Usage: Undo transformations, create view matrices from camera transforms, or transform from world to local space.</p> <pre><code>zest_matrix4 model = zest_CreateMatrix4(...);\nzest_matrix4 inverse_model = zest_Inverse(&amp;model);\n\n// Transform world point to local space\nzest_vec4 local = zest_MatrixTransformVector(&amp;inverse_model, world_point);\n</code></pre>"},{"location":"api-reference/math/#viewprojection","title":"View/Projection","text":""},{"location":"api-reference/math/#zest_lookat","title":"<code>zest_LookAt</code>","text":"<p>Create a view matrix that looks from <code>eye</code> toward <code>center</code>.</p> <pre><code>zest_matrix4 zest_LookAt(const zest_vec3 eye, const zest_vec3 center, const zest_vec3 up);\n</code></pre> <p>Usage: Create camera view matrices.</p> <pre><code>zest_vec3 camera_pos = zest_Vec3Set(0, 5, 10);\nzest_vec3 target = zest_Vec3Set(0, 0, 0);\nzest_vec3 up = zest_Vec3Set(0, 1, 0);\nzest_matrix4 view = zest_LookAt(camera_pos, target, up);\n</code></pre>"},{"location":"api-reference/math/#zest_perspective","title":"<code>zest_Perspective</code>","text":"<p>Create a perspective projection matrix.</p> <pre><code>zest_matrix4 zest_Perspective(float fovy, float aspect, float zNear, float zFar);\n</code></pre> <ul> <li><code>fovy</code> - Vertical field of view in radians</li> <li><code>aspect</code> - Aspect ratio (width / height)</li> <li><code>zNear, zFar</code> - Near and far clipping planes</li> </ul> <p>Usage: Standard 3D perspective rendering.</p> <pre><code>float fov = zest_Radians(60.0f);\nfloat aspect = (float)width / (float)height;\nzest_matrix4 proj = zest_Perspective(fov, aspect, 0.1f, 1000.0f);\n</code></pre>"},{"location":"api-reference/math/#zest_ortho","title":"<code>zest_Ortho</code>","text":"<p>Create an orthographic projection matrix.</p> <pre><code>zest_matrix4 zest_Ortho(float left, float right, float bottom, float top,\n                         float z_near, float z_far);\n</code></pre> <p>Usage: 2D rendering, UI, shadow maps, or isometric views.</p> <pre><code>// Screen-space orthographic for UI\nzest_matrix4 ortho = zest_Ortho(0, screen_width, screen_height, 0, -1, 1);\n\n// Centered orthographic\nfloat hw = width * 0.5f;\nfloat hh = height * 0.5f;\nzest_matrix4 ortho = zest_Ortho(-hw, hw, -hh, hh, 0.1f, 100.0f);\n</code></pre>"},{"location":"api-reference/math/#interpolation","title":"Interpolation","text":""},{"location":"api-reference/math/#zest_lerp","title":"<code>zest_Lerp</code>","text":"<p>Linearly interpolate between two float values.</p> <pre><code>float zest_Lerp(float from, float to, float t);\n</code></pre>"},{"location":"api-reference/math/#zest_lerpvec2-zest_lerpvec3-zest_lerpvec4","title":"<code>zest_LerpVec2</code> / <code>zest_LerpVec3</code> / <code>zest_LerpVec4</code>","text":"<p>Linearly interpolate between two vectors.</p> <pre><code>zest_vec2 zest_LerpVec2(zest_vec2 *from, zest_vec2 *to, float t);\nzest_vec3 zest_LerpVec3(zest_vec3 *from, zest_vec3 *to, float t);\nzest_vec4 zest_LerpVec4(zest_vec4 *from, zest_vec4 *to, float t);\n</code></pre> <ul> <li><code>t = 0</code> returns <code>from</code></li> <li><code>t = 1</code> returns <code>to</code></li> <li><code>0 &lt; t &lt; 1</code> returns a blend between them</li> </ul> <p>Usage: Smooth animations, camera transitions, color fading, or physics interpolation.</p> <pre><code>// Smooth camera movement\nzest_vec3 current_pos = ...;\nzest_vec3 target_pos = ...;\nfloat smoothing = 0.1f;\ncurrent_pos = zest_LerpVec3(&amp;current_pos, &amp;target_pos, smoothing);\n\n// Color transition\nzest_vec4 start_color = zest_Vec4Set(1, 0, 0, 1);  // Red\nzest_vec4 end_color = zest_Vec4Set(0, 0, 1, 1);    // Blue\nzest_vec4 blended = zest_LerpVec4(&amp;start_color, &amp;end_color, 0.5f);  // Purple\n</code></pre>"},{"location":"api-reference/math/#angle-conversion","title":"Angle Conversion","text":""},{"location":"api-reference/math/#zest_radians","title":"<code>zest_Radians</code>","text":"<p>Convert degrees to radians.</p> <pre><code>float zest_Radians(float degrees);\n</code></pre>"},{"location":"api-reference/math/#zest_degrees","title":"<code>zest_Degrees</code>","text":"<p>Convert radians to degrees.</p> <pre><code>float zest_Degrees(float radians);\n</code></pre> <p>Usage: Interface between user-friendly angles (degrees) and math functions (radians).</p> <pre><code>float fov_degrees = 60.0f;\nfloat fov_radians = zest_Radians(fov_degrees);\n\nzest_matrix4 rot = zest_Matrix4RotateY(zest_Radians(90.0f));  // Rotate 90 degrees\n</code></pre>"},{"location":"api-reference/math/#packing-functions","title":"Packing Functions","text":"<p>Packing functions compress floating-point vectors into smaller integer formats for efficient GPU storage.</p>"},{"location":"api-reference/math/#zest_pack10bit","title":"<code>zest_Pack10bit</code>","text":"<p>Pack a normalized vec3 into a 32-bit unsigned int (10 bits per component + 2 extra bits). Note that this packing will not work on Mac GPUs (the vertex attribute description is not available for it).</p> <pre><code>zest_uint zest_Pack10bit(zest_vec3 *v, zest_uint extra);\n</code></pre> <p>Usage: Compress normals or directions with 2 bits for extra data (e.g., material ID, flags).</p> <pre><code>zest_vec3 normal = zest_Vec3Set(0.707f, 0.707f, 0.0f);\nzest_uint packed = zest_Pack10bit(&amp;normal, 0);  // extra bits = 0\n</code></pre>"},{"location":"api-reference/math/#zest_pack8bitx3","title":"<code>zest_Pack8bitx3</code>","text":"<p>Pack a vec3 into a 32-bit unsigned int (8 bits per component).</p> <pre><code>zest_uint zest_Pack8bitx3(zest_vec3 *v);\n</code></pre>"},{"location":"api-reference/math/#zest_pack8bit","title":"<code>zest_Pack8bit</code>","text":"<p>Pack three floats into a 32-bit unsigned int (8 bits each).</p> <pre><code>zest_uint zest_Pack8bit(float x, float y, float z);\n</code></pre> <p>Usage: Compress colors or low-precision vectors.</p> <pre><code>zest_uint packed_color = zest_Pack8bit(1.0f, 0.5f, 0.0f);  // Orange\n</code></pre>"},{"location":"api-reference/math/#zest_pack16bit2snorm","title":"<code>zest_Pack16bit2SNorm</code>","text":"<p>Pack two normalized floats (-1 to 1) into a 32-bit unsigned int (16 bits each).</p> <pre><code>zest_uint zest_Pack16bit2SNorm(float x, float y);\n</code></pre>"},{"location":"api-reference/math/#zest_pack16bit4snorm","title":"<code>zest_Pack16bit4SNorm</code>","text":"<p>Pack four normalized floats (-1 to 1) into a 64-bit unsigned int (16 bits each).</p> <pre><code>zest_u64 zest_Pack16bit4SNorm(float x, float y, float z, float w);\n</code></pre> <p>Usage: Compress UV coordinates, tangent vectors, or other normalized data.</p> <pre><code>zest_uint packed_uv = zest_Pack16bit2SNorm(u * 2.0f - 1.0f, v * 2.0f - 1.0f);\n</code></pre>"},{"location":"api-reference/math/#zest_pack16bit2sscaled","title":"<code>zest_Pack16bit2SScaled</code>","text":"<p>Pack two floats into a 32-bit unsigned int with scaling.</p> <pre><code>zest_uint zest_Pack16bit2SScaled(float x, float y, float max_value);\n</code></pre>"},{"location":"api-reference/math/#zest_pack16bit4sscaled","title":"<code>zest_Pack16bit4SScaled</code>","text":"<p>Pack four floats into a 64-bit unsigned int with separate XY and ZW scaling.</p> <pre><code>zest_u64 zest_Pack16bit4SScaled(float x, float y, float z, float w,\n                                 float max_value_xy, float max_value_zw);\n</code></pre>"},{"location":"api-reference/math/#zest_pack16bit4sfloat","title":"<code>zest_Pack16bit4SFloat</code>","text":"<p>Pack four 32-bit floats into four 16-bit half-precision floats.</p> <pre><code>zest_u64 zest_Pack16bit4SFloat(float x, float y, float z, float w);\n</code></pre> <p>Usage: GPU-compatible half-precision storage with full float range.</p>"},{"location":"api-reference/math/#zest_floattohalf","title":"<code>zest_FloatToHalf</code>","text":"<p>Convert a single 32-bit float to a 16-bit half-precision float.</p> <pre><code>zest_uint zest_FloatToHalf(float f);\n</code></pre> <p>Usage: Manual half-float conversion for custom packing.</p> <pre><code>zest_uint half_value = zest_FloatToHalf(3.14159f);\n</code></pre>"},{"location":"api-reference/math/#zest_pack16bitstretch","title":"<code>zest_Pack16bitStretch</code>","text":"<p>Pack two floats into a 32-bit unsigned int using stretch encoding.</p> <pre><code>zest_uint zest_Pack16bitStretch(float x, float y);\n</code></pre>"},{"location":"api-reference/math/#color","title":"Color","text":""},{"location":"api-reference/math/#zest_colorset","title":"<code>zest_ColorSet</code>","text":"<p>Create a color from RGBA byte values (0-255).</p> <pre><code>zest_color_t zest_ColorSet(zest_byte r, zest_byte g, zest_byte b, zest_byte a);\n</code></pre> <p>Usage: Create colors from typical 8-bit color values.</p> <pre><code>zest_color_t red = zest_ColorSet(255, 0, 0, 255);\nzest_color_t semi_transparent_blue = zest_ColorSet(0, 0, 255, 128);\n</code></pre>"},{"location":"api-reference/math/#zest_colorset1","title":"<code>zest_ColorSet1</code>","text":"<p>Create a grayscale color with all components set to the same value.</p> <pre><code>zest_color_t zest_ColorSet1(zest_byte c);\n</code></pre> <p>Usage: Quick grayscale colors.</p> <pre><code>zest_color_t white = zest_ColorSet1(255);\nzest_color_t gray = zest_ColorSet1(128);\nzest_color_t black = zest_ColorSet1(0);\n</code></pre>"},{"location":"api-reference/math/#see-also","title":"See Also","text":"<ul> <li>Camera API</li> </ul>"},{"location":"api-reference/pipeline/","title":"Pipeline API","text":"<p>Functions for creating and configuring graphics and compute pipelines. Zest uses pipeline templates that are compiled into actual GPU pipelines on demand, with automatic caching for efficiency.</p>"},{"location":"api-reference/pipeline/#pipeline-template-creation","title":"Pipeline Template Creation","text":""},{"location":"api-reference/pipeline/#zest_createpipelinetemplate","title":"<code>zest_CreatePipelineTemplate</code>","text":"<p>Create a new pipeline template with default settings.</p> <pre><code>zest_pipeline_template zest_CreatePipelineTemplate(zest_device device, const char *name);\n</code></pre> <p>Usage: Start building a new rendering pipeline. Templates define the shader programs, vertex input layout, rasterization state, and blending configuration.</p> <pre><code>zest_pipeline_template my_pipeline = zest_CreatePipelineTemplate(device, \"my_custom_pipeline\");\nzest_SetPipelineShaders(my_pipeline, vertex_shader, fragment_shader);\nzest_SetPipelineTopology(my_pipeline, zest_topology_triangle_list);\n// Configure other settings...\n</code></pre>"},{"location":"api-reference/pipeline/#zest_copypipelinetemplate","title":"<code>zest_CopyPipelineTemplate</code>","text":"<p>Copy an existing template to create a variant with modified settings.</p> <pre><code>zest_pipeline_template zest_CopyPipelineTemplate(const char *name, zest_pipeline_template source);\n</code></pre> <p>Usage: Create pipeline variations (e.g., wireframe version of a solid pipeline) without duplicating all configuration code.</p> <pre><code>// Create wireframe variant of existing pipeline\nzest_pipeline_template wireframe = zest_CopyPipelineTemplate(\"wireframe_pipeline\", solid_pipeline);\nzest_SetPipelinePolygonFillMode(wireframe, zest_polygon_mode_line);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_freepipelinetemplate","title":"<code>zest_FreePipelineTemplate</code>","text":"<p>Free a pipeline template and all its cached pipeline instances.</p> <pre><code>void zest_FreePipelineTemplate(zest_pipeline_template pipeline_template);\n</code></pre> <p>Usage: Clean up pipelines that are no longer needed, such as during hot-reload or shutdown.</p> <pre><code>zest_FreePipelineTemplate(old_pipeline);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_pipelineisvalid","title":"<code>zest_PipelineIsValid</code>","text":"<p>Check if a pipeline template is in a valid state. This will build the pipeline if it hasn't been already and report if the pipeline failed to build or had errors.</p> <pre><code>zest_bool zest_PipelineIsValid(zest_pipeline_template pipeline);\n</code></pre> <p>Usage: Verify pipeline configuration before use, especially after shader changes.</p> <pre><code>if (!zest_PipelineIsValid(pipeline)) {\n    // Handle invalid pipeline - likely shader compilation error\n}\n</code></pre>"},{"location":"api-reference/pipeline/#shaders","title":"Shaders","text":""},{"location":"api-reference/pipeline/#zest_setpipelineshaders","title":"<code>zest_SetPipelineShaders</code>","text":"<p>Set both vertex and fragment shaders at once.</p> <pre><code>void zest_SetPipelineShaders(zest_pipeline_template pipeline_template,\n                              zest_shader_handle vertex_shader,\n                              zest_shader_handle fragment_shader);\n</code></pre> <p>Usage: Configure the shader programs for a graphics pipeline.</p> <pre><code>zest_shader_handle vert = zest_CreateShaderFromFile(device, \"shaders/mesh.vert\", \"mesh_vert\", zest_vertex_shader, 0);\nzest_shader_handle frag = zest_CreateShaderFromFile(device, \"shaders/mesh.frag\", \"mesh_frag\", zest_fragment_shader, 0);\nzest_SetPipelineShaders(pipeline, vert, frag);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinevertshader-zest_setpipelinefragshader","title":"<code>zest_SetPipelineVertShader</code> / <code>zest_SetPipelineFragShader</code>","text":"<p>Set vertex or fragment shader individually.</p> <pre><code>void zest_SetPipelineVertShader(zest_pipeline_template pipeline_template, zest_shader_handle shader);\nvoid zest_SetPipelineFragShader(zest_pipeline_template pipeline_template, zest_shader_handle shader);\n</code></pre> <p>Usage: Update individual shaders, useful for shader hot-reloading or when multiple pipelines share shaders.</p> <pre><code>// Swap out just the fragment shader\nzest_SetPipelineFragShader(pipeline, new_fragment_shader);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelineshader","title":"<code>zest_SetPipelineShader</code>","text":"<p>Set a combined vertex and fragment shader (single shader handle containing both stages).</p> <pre><code>void zest_SetPipelineShader(zest_pipeline_template pipeline_template,\n                            zest_shader_handle combined_vertex_and_fragment_shader);\n</code></pre> <p>Usage: Use with shader systems that compile vertex and fragment stages together.</p>"},{"location":"api-reference/pipeline/#vertex-input","title":"Vertex Input","text":""},{"location":"api-reference/pipeline/#zest_addvertexinputbindingdescription","title":"<code>zest_AddVertexInputBindingDescription</code>","text":"<p>Define a vertex buffer binding (stride and input rate).</p> <pre><code>zest_vertex_binding_desc_t zest_AddVertexInputBindingDescription(\n    zest_pipeline_template pipeline_template,\n    zest_uint binding,\n    zest_uint stride,\n    zest_input_rate input_rate\n);\n</code></pre> <p>Input Rates: - <code>zest_input_rate_vertex</code> - Advance per vertex for general mesh drawing - <code>zest_input_rate_instance</code> - Advance per instance for instanced drawing</p> <p>Usage: Configure how vertex data is read from buffers.</p> <pre><code>// Per-vertex position/normal/uv data\nzest_AddVertexInputBindingDescription(pipeline, 0, sizeof(Vertex_t), zest_input_rate_vertex);\n\n// Per-instance transform data\nzest_AddVertexInputBindingDescription(pipeline, 1, sizeof(InstanceData_t), zest_input_rate_instance);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_addvertexattribute","title":"<code>zest_AddVertexAttribute</code>","text":"<p>Define a vertex attribute within a binding.</p> <pre><code>void zest_AddVertexAttribute(\n    zest_pipeline_template pipeline_template,\n    zest_uint binding,\n    zest_uint location,\n    zest_format format,\n    zest_uint offset\n);\n</code></pre> <p>Common Formats: - <code>zest_format_r32g32b32_sfloat</code> - vec3 (position, normal) - <code>zest_format_r32g32_sfloat</code> - vec2 (UV coordinates) - <code>zest_format_r8g8b8a8_unorm</code> - Color (4 bytes normalized) - <code>zest_format_r32g32b32a32_sfloat</code> - vec4</p> <p>Usage: Map vertex struct fields to shader input locations.</p> <pre><code>typedef struct {\n    float position[3];  // location 0\n    float normal[3];    // location 1\n    float uv[2];        // location 2\n} Vertex;\n\nzest_AddVertexInputBindingDescription(pipeline, 0, sizeof(Vertex), zest_input_rate_vertex);\nzest_AddVertexAttribute(pipeline, 0, 0, zest_format_r32g32b32_sfloat, offsetof(Vertex, position));\nzest_AddVertexAttribute(pipeline, 0, 1, zest_format_r32g32b32_sfloat, offsetof(Vertex, normal));\nzest_AddVertexAttribute(pipeline, 0, 2, zest_format_r32g32_sfloat, offsetof(Vertex, uv));\n</code></pre>"},{"location":"api-reference/pipeline/#zest_clearvertexinputbindingdescriptions","title":"<code>zest_ClearVertexInputBindingDescriptions</code>","text":"<p>Remove all vertex binding descriptions from a pipeline template.</p> <pre><code>void zest_ClearVertexInputBindingDescriptions(zest_pipeline_template pipeline_template);\n</code></pre> <p>Usage: Reset vertex vertex input binding descriptions when copying pipelines that need different requirements.</p>"},{"location":"api-reference/pipeline/#zest_clearvertexattributedescriptions","title":"<code>zest_ClearVertexAttributeDescriptions</code>","text":"<p>Remove all vertex attribute descriptions from a pipeline template.</p> <pre><code>void zest_ClearVertexAttributeDescriptions(zest_pipeline_template pipeline_template);\n</code></pre> <p>Usage: Reset vertex input configuration when copying pipelines that need different layouts.</p> <pre><code>zest_pipeline_template fullscreen = zest_CopyPipelineTemplate(\"fullscreen\", base_pipeline);\nzest_ClearVertexInputBindingDescriptions(fullscreen);\nzest_ClearVertexAttributeDescriptions(fullscreen);\nzest_SetPipelineDisableVertexInput(fullscreen);  // Fullscreen pass uses vertex ID\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelineenablevertexinput-zest_setpipelinedisablevertexinput","title":"<code>zest_SetPipelineEnableVertexInput</code> / <code>zest_SetPipelineDisableVertexInput</code>","text":"<p>Enable or disable vertex input for the pipeline.</p> <pre><code>void zest_SetPipelineEnableVertexInput(zest_pipeline_template pipeline_template);\nvoid zest_SetPipelineDisableVertexInput(zest_pipeline_template pipeline_template);\n</code></pre> <p>Usage: Disable vertex input for fullscreen passes that generate vertices in the shader.</p> <pre><code>// Fullscreen quad using gl_VertexIndex\nzest_SetPipelineDisableVertexInput(fullscreen_pipeline);\n</code></pre>"},{"location":"api-reference/pipeline/#state-configuration","title":"State Configuration","text":""},{"location":"api-reference/pipeline/#zest_setpipelinetopology","title":"<code>zest_SetPipelineTopology</code>","text":"<p>Set the primitive topology (how vertices form primitives).</p> <pre><code>void zest_SetPipelineTopology(zest_pipeline_template pipeline_template, zest_topology topology);\n</code></pre> <p>Topology Values: | Value | Description | |-------|-------------| | <code>zest_topology_point_list</code> | Individual points | | <code>zest_topology_line_list</code> | Pairs of vertices form lines | | <code>zest_topology_line_strip</code> | Connected line segments | | <code>zest_topology_triangle_list</code> | Every 3 vertices form a triangle (most common) | | <code>zest_topology_triangle_strip</code> | Connected triangles sharing edges | | <code>zest_topology_triangle_fan</code> | Triangles sharing a central vertex |</p> <p>Usage: Define how the GPU assembles primitives from vertex data.</p> <pre><code>zest_SetPipelineTopology(mesh_pipeline, zest_topology_triangle_list);\nzest_SetPipelineTopology(particle_pipeline, zest_topology_point_list);\nzest_SetPipelineTopology(line_pipeline, zest_topology_line_list);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinecullmode","title":"<code>zest_SetPipelineCullMode</code>","text":"<p>Set face culling mode.</p> <pre><code>void zest_SetPipelineCullMode(zest_pipeline_template pipeline_template, zest_cull_mode cull_mode);\n</code></pre> <p>Cull Modes: | Value | Description | |-------|-------------| | <code>zest_cull_mode_none</code> | No culling (render both sides) | | <code>zest_cull_mode_front</code> | Cull front-facing triangles | | <code>zest_cull_mode_back</code> | Cull back-facing triangles (default for most 3D) | | <code>zest_cull_mode_front_and_back</code> | Cull all triangles (useful for stencil operations) |</p> <p>Usage: Optimize rendering by not drawing hidden faces.</p> <pre><code>zest_SetPipelineCullMode(opaque_pipeline, zest_cull_mode_back);  // Standard 3D\nzest_SetPipelineCullMode(double_sided_pipeline, zest_cull_mode_none);  // Foliage, UI\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinefrontface","title":"<code>zest_SetPipelineFrontFace</code>","text":"<p>Set which winding order is considered front-facing.</p> <pre><code>void zest_SetPipelineFrontFace(zest_pipeline_template pipeline_template, zest_front_face front_face);\n</code></pre> <p>Values: - <code>zest_front_face_counter_clockwise</code> - CCW winding is front (OpenGL default) - <code>zest_front_face_clockwise</code> - CW winding is front (Zest default)</p> <p>Usage: Match the winding order used by your mesh data.</p> <pre><code>zest_SetPipelineFrontFace(pipeline, zest_front_face_clockwise);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinepolygonfillmode","title":"<code>zest_SetPipelinePolygonFillMode</code>","text":"<p>Set how polygons are rasterized.</p> <pre><code>void zest_SetPipelinePolygonFillMode(zest_pipeline_template pipeline_template, zest_polygon_mode polygon_mode);\n</code></pre> <p>Polygon Modes: | Value | Description | |-------|-------------| | <code>zest_polygon_mode_fill</code> | Fill triangles (default) | | <code>zest_polygon_mode_line</code> | Draw triangle edges only (wireframe) | | <code>zest_polygon_mode_point</code> | Draw triangle vertices only |</p> <p>Usage: Debug visualization or stylized rendering.</p> <pre><code>zest_SetPipelinePolygonFillMode(wireframe_pipeline, zest_polygon_mode_line);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinedepthtest","title":"<code>zest_SetPipelineDepthTest</code>","text":"<p>Configure depth testing and writing.</p> <pre><code>void zest_SetPipelineDepthTest(zest_pipeline_template pipeline_template,\n                                zest_bool enable_test,\n                                zest_bool write_enable);\n</code></pre> <p>Usage: Control depth buffer behavior for different rendering scenarios.</p> <pre><code>// Standard opaque rendering - test and write depth\nzest_SetPipelineDepthTest(opaque_pipeline, ZEST_TRUE, ZEST_TRUE);\n\n// Transparent rendering - test but don't write\nzest_SetPipelineDepthTest(transparent_pipeline, ZEST_TRUE, ZEST_FALSE);\n\n// UI/overlay - no depth testing\nzest_SetPipelineDepthTest(ui_pipeline, ZEST_FALSE, ZEST_FALSE);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinedepthbias","title":"<code>zest_SetPipelineDepthBias</code>","text":"<p>Enable or disable depth bias (polygon offset).</p> <pre><code>void zest_SetPipelineDepthBias(zest_pipeline_template pipeline_template, zest_bool enabled);\n</code></pre> <p>Usage: Prevent z-fighting for decals, shadows, or coplanar geometry.</p> <pre><code>zest_SetPipelineDepthBias(decal_pipeline, ZEST_TRUE);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelineblend","title":"<code>zest_SetPipelineBlend</code>","text":"<p>Set the color blending state.</p> <pre><code>void zest_SetPipelineBlend(zest_pipeline_template pipeline_template,\n                           zest_color_blend_attachment_t blend_attachment);\n</code></pre> <p>Usage: Configure how fragment colors combine with the framebuffer.</p> <pre><code>zest_SetPipelineBlend(transparent_pipeline, zest_AlphaBlendState());\nzest_SetPipelineBlend(additive_pipeline, zest_AdditiveBlendState());\nzest_SetPipelineBlend(opaque_pipeline, zest_BlendStateNone());\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelineviewcount","title":"<code>zest_SetPipelineViewCount</code>","text":"<p>Set the number of views for multiview rendering.</p> <pre><code>void zest_SetPipelineViewCount(zest_pipeline_template pipeline_template, zest_uint view_count);\n</code></pre> <p>Usage: Configure pipelines for VR sterio, cubemap, cascading shadows, or other multiview rendering scenarios.</p> <pre><code>zest_SetPipelineViewCount(vr_pipeline, 2);  // Left and right eye\n</code></pre>"},{"location":"api-reference/pipeline/#zest_setpipelinelayout","title":"<code>zest_SetPipelineLayout</code>","text":"<p>Set a custom pipeline layout.</p> <pre><code>void zest_SetPipelineLayout(zest_pipeline_template pipeline_template, zest_pipeline_layout pipeline_layout);\n</code></pre> <p>Usage: Use a custom descriptor layout for pipelines requiring non-default bindings.</p> <pre><code>zest_pipeline_layout custom_layout = zest_CreatePipelineLayout(&amp;layout_info);\nzest_SetPipelineLayout(pipeline, custom_layout);\n</code></pre>"},{"location":"api-reference/pipeline/#blend-state-helpers","title":"Blend State Helpers","text":"<p>Pre-configured blend states for common scenarios.</p> <pre><code>zest_color_blend_attachment_t zest_BlendStateNone(void);               // No blending (opaque)\nzest_color_blend_attachment_t zest_AlphaBlendState(void);              // Standard alpha blending\nzest_color_blend_attachment_t zest_AlphaOnlyBlendState(void);          // Blend alpha channel only\nzest_color_blend_attachment_t zest_AdditiveBlendState(void);           // Additive blending\nzest_color_blend_attachment_t zest_AdditiveBlendState2(void);          // Alternative additive\nzest_color_blend_attachment_t zest_PreMultiplyBlendState(void);        // Pre-multiplied alpha\nzest_color_blend_attachment_t zest_PreMultiplyBlendStateForSwap(void); // Pre-multiplied for swapchain\nzest_color_blend_attachment_t zest_MaxAlphaBlendState(void);           // Max alpha blending\nzest_color_blend_attachment_t zest_ImGuiBlendState(void);              // ImGui-compatible blending\n</code></pre> <p>Usage:</p> <pre><code>// Opaque geometry\nzest_SetPipelineBlend(opaque_pipeline, zest_BlendStateNone());\n\n// Transparent with alpha\nzest_SetPipelineBlend(transparent_pipeline, zest_AlphaBlendState());\n\n// Particle effects (additive glow)\nzest_SetPipelineBlend(particle_pipeline, zest_AdditiveBlendState());\n\n// UI with pre-multiplied alpha textures\nzest_SetPipelineBlend(ui_pipeline, zest_PreMultiplyBlendState());\n</code></pre>"},{"location":"api-reference/pipeline/#using-pipelines","title":"Using Pipelines","text":""},{"location":"api-reference/pipeline/#zest_getpipeline","title":"<code>zest_GetPipeline</code>","text":"<p>Get or build a pipeline for use with a command list.</p> <pre><code>zest_pipeline zest_GetPipeline(zest_pipeline_template pipeline_template,\n                                        const zest_command_list command_list);\n</code></pre> <p>Usage: Retrieve a compiled pipeline during rendering. Pipelines are cached and reused automatically.</p> <pre><code>void render_callback(zest_command_list cmd, void *user_data) {\n    zest_pipeline pipeline = zest_GetPipeline(my_pipeline, cmd);\n    zest_cmd_BindPipeline(cmd, pipeline);\n    // Draw commands...\n}\n</code></pre>"},{"location":"api-reference/pipeline/#pipeline-layout","title":"Pipeline Layout","text":""},{"location":"api-reference/pipeline/#zest_newpipelinelayoutinfo","title":"<code>zest_NewPipelineLayoutInfo</code>","text":"<p>Create a new pipeline layout info structure.</p> <pre><code>zest_pipeline_layout_info_t zest_NewPipelineLayoutInfo(zest_device device);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_newpipelinelayoutinfowithglobalbindless","title":"<code>zest_NewPipelineLayoutInfoWithGlobalBindless</code>","text":"<p>Create a pipeline layout info that includes the global bindless descriptor set.</p> <pre><code>zest_pipeline_layout_info_t zest_NewPipelineLayoutInfoWithGlobalBindless(zest_device device);\n</code></pre> <p>Usage: Most pipelines should use this to access the bindless resource system.</p> <pre><code>zest_pipeline_layout_info_t info = zest_NewPipelineLayoutInfoWithGlobalBindless(device);\n// Add additional descriptor layouts if needed\nzest_pipeline_layout layout = zest_CreatePipelineLayout(&amp;info);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_addpipelinelayoutdescriptorlayout","title":"<code>zest_AddPipelineLayoutDescriptorLayout</code>","text":"<p>Add a descriptor set layout to the pipeline layout.</p> <pre><code>void zest_AddPipelineLayoutDescriptorLayout(zest_pipeline_layout_info_t *info, zest_set_layout layout);\n</code></pre> <p>Usage: Add custom descriptor set layouts beyond the global bindless set.</p>"},{"location":"api-reference/pipeline/#zest_setpipelinelayoutpushconstantrange","title":"<code>zest_SetPipelineLayoutPushConstantRange</code>","text":"<p>Configure push constants for the pipeline layout. </p> <pre><code>void zest_SetPipelineLayoutPushConstantRange(zest_pipeline_layout_info_t *info,\n                                              zest_uint size,\n                                              zest_supported_shader_stages stage_flags);\n</code></pre> <p>Usage: Define push constant range accessible to shaders.</p> <pre><code>typedef struct {\n    float mvp[16];\n    float time;\n} PushConstants;\n\nzest_pipeline_layout_info_t info = zest_NewPipelineLayoutInfoWithGlobalBindless(device);\nzest_SetPipelineLayoutPushConstantRange(&amp;info, sizeof(PushConstants),\n    zest_pipeline_stage_vertex_shader_bit | zest_pipeline_stage_fragment_shader_bit);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_createpipelinelayout","title":"<code>zest_CreatePipelineLayout</code>","text":"<p>Create a pipeline layout from the info structure.</p> <pre><code>zest_pipeline_layout zest_CreatePipelineLayout(zest_pipeline_layout_info_t *info);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_getpipelinelayout","title":"<code>zest_GetPipelineLayout</code>","text":"<p>Get the layout from an existing pipeline.</p> <pre><code>zest_pipeline_layout zest_GetPipelineLayout(zest_pipeline pipeline);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_getdefaultpipelinelayout","title":"<code>zest_GetDefaultPipelineLayout</code>","text":"<p>Get the device's default pipeline layout (includes global bindless).</p> <pre><code>zest_pipeline_layout zest_GetDefaultPipelineLayout(zest_device device);\n</code></pre>"},{"location":"api-reference/pipeline/#shader-creation","title":"Shader Creation","text":""},{"location":"api-reference/pipeline/#zest_createshaderfromfile","title":"<code>zest_CreateShaderFromFile</code>","text":"<p>Create a shader from a source file. As Zest current only has a platform layer for Vulkan this will need a glsl shader which gets compiled using shaderc.</p> <pre><code>zest_shader_handle zest_CreateShaderFromFile(zest_device device,\n                                              const char *file,\n                                              const char *name,\n                                              zest_shader_type type,\n                                              zest_bool disable_caching);\n</code></pre> <p>Shader Types: - <code>zest_vertex_shader</code> - <code>zest_fragment_shader</code> - <code>zest_compute_shader</code></p> <p>Usage: Load and compile shaders from source files.</p> <pre><code>zest_shader_handle vert = zest_CreateShaderFromFile(\n    device,\n    \"shaders/mesh.vert\",\n    \"mesh_vertex.spv\",  //Will be cached to disk with this name\n    zest_vertex_shader,\n    ZEST_FALSE  // Enable caching\n);\n\nzest_shader_handle frag = zest_CreateShaderFromFile(\n    device,\n    \"shaders/mesh.frag\",\n    \"mesh_fragment.spv\",\n    zest_fragment_shader,\n    ZEST_FALSE\n);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_createshader","title":"<code>zest_CreateShader</code>","text":"<p>Create a shader from source code string. As Zest current only has a platform layer for Vulkan this will need a glsl shader which gets compiled using shaderc. </p> <pre><code>zest_shader_handle zest_CreateShader(zest_device device,\n                                      const char *shader_code,\n                                      zest_shader_type type,\n                                      const char *name,\n                                      zest_bool disable_caching);\n</code></pre> <p>Usage: Compile shaders from runtime-generated or embedded source code.</p> <pre><code>const char *shader_source = \"...\";\nzest_shader_handle shader = zest_CreateShader(device, shader_source, zest_fragment_shader, \"dynamic_frag\", ZEST_TRUE);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_createshaderspvmemory","title":"<code>zest_CreateShaderSPVMemory</code>","text":"<p>Create a shader from pre-compiled SPIR-V bytecode in memory.</p> <pre><code>zest_shader_handle zest_CreateShaderSPVMemory(zest_device device,\n                                               const unsigned char *shader_code,\n                                               zest_uint spv_length,\n                                               const char *name,\n                                               zest_shader_type type);\n</code></pre> <p>Usage: Load embedded SPIR-V shaders compiled at build time.</p> <pre><code>// shader_spv.h generated by build system\n\nzest_shader_handle shader = zest_CreateShaderSPVMemory(\n    device,\n    mesh_vert_spv,\n    sizeof(mesh_vert_spv),\n    \"mesh_vert.spv\",\n    zest_vertex_shader\n);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_createshaderfromspvfile","title":"<code>zest_CreateShaderFromSPVFile</code>","text":"<p>Load a pre-compiled SPIR-V shader from a file.</p> <pre><code>zest_shader_handle zest_CreateShaderFromSPVFile(zest_device device,\n                                              const char *filename,\n                                              zest_shader_type type);\n</code></pre> <p>Usage: Load shaders compiled offline with glslc or similar tools.</p> <pre><code>zest_shader_handle vert = zest_CreateShaderFromSPVFile(device, \"shaders/mesh.vert.spv\", zest_vertex_shader);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_addshaderfromspvmemory","title":"<code>zest_AddShaderFromSPVMemory</code>","text":"<p>Load a pre-compiled SPIR-V shader from a memory buffer.</p> <pre><code>zest_shader_handle zest_AddShaderFromSPVMemory(zest_device device,\n                                                const char *name,\n                                                const void *buffer,\n                                                zest_uint size,\n                                                zest_shader_type type);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_validateshader","title":"<code>zest_ValidateShader</code>","text":"<p>Validate shader source code without creating a shader object.</p> <pre><code>zest_bool zest_ValidateShader(zest_device device,\n                               const char *shader_code,\n                               zest_shader_type type,\n                               const char *name);\n</code></pre> <p>Usage: Check shader validity before committing to compilation.</p>"},{"location":"api-reference/pipeline/#zest_reloadshader","title":"<code>zest_ReloadShader</code>","text":"<p>Reload a shader from its original source.</p> <pre><code>zest_bool zest_ReloadShader(zest_shader_handle shader);\n</code></pre> <p>Usage: Hot-reload shaders during development.</p> <pre><code>if (file_changed) {\n    if (zest_ReloadShader(my_shader)) {\n        // Shader reloaded successfully\n    }\n}\n</code></pre>"},{"location":"api-reference/pipeline/#zest_compileshader","title":"<code>zest_CompileShader</code>","text":"<p>Compile or recompile a shader.</p> <pre><code>zest_bool zest_CompileShader(zest_shader_handle shader);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_getshader","title":"<code>zest_GetShader</code>","text":"<p>Get the shader object pointer from a handle.</p> <pre><code>zest_shader zest_GetShader(zest_shader_handle shader_handle);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_freeshader","title":"<code>zest_FreeShader</code>","text":"<p>Free a shader and its resources.</p> <pre><code>void zest_FreeShader(zest_shader_handle shader);\n</code></pre>"},{"location":"api-reference/pipeline/#compute-pipelines","title":"Compute Pipelines","text":""},{"location":"api-reference/pipeline/#zest_createcompute","title":"<code>zest_CreateCompute</code>","text":"<p>Create a compute pipeline.</p> <pre><code>zest_compute_handle zest_CreateCompute(zest_device device,\n                                        const char *name,\n                                        zest_shader_handle shader);\n</code></pre> <p>Usage: Set up a compute shader for GPU computation.</p> <pre><code>zest_shader_handle compute_shader = zest_CreateShaderFromFile(\n    device, \"shaders/particle_sim.comp\", \"particle_sim\", zest_compute_shader, ZEST_FALSE);\n\nzest_compute_handle compute = zest_CreateCompute(device, \"particle_simulation\", compute_shader);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_getcompute","title":"<code>zest_GetCompute</code>","text":"<p>Get the compute object pointer from a handle.</p> <pre><code>zest_compute zest_GetCompute(zest_compute_handle compute_handle);\n</code></pre>"},{"location":"api-reference/pipeline/#zest_freecompute","title":"<code>zest_FreeCompute</code>","text":"<p>Free a compute pipeline.</p> <pre><code>void zest_FreeCompute(zest_compute_handle compute);\n</code></pre>"},{"location":"api-reference/pipeline/#complete-example","title":"Complete Example","text":"<pre><code>// Create and configure a complete rendering pipeline\nzest_pipeline_template create_mesh_pipeline(zest_device device) {\n    // Create shaders\n    zest_shader_handle vert = zest_CreateShaderFromFile(\n        device, \"shaders/mesh.vert\", \"mesh_vert\", zest_vertex_shader, ZEST_FALSE);\n    zest_shader_handle frag = zest_CreateShaderFromFile(\n        device, \"shaders/mesh.frag\", \"mesh_frag\", zest_fragment_shader, ZEST_FALSE);\n\n    // Create pipeline template\n    zest_pipeline_template pipeline = zest_CreatePipelineTemplate(device, \"mesh_pipeline\");\n\n    // Set shaders\n    zest_SetPipelineShaders(pipeline, vert, frag);\n\n    // Configure vertex input\n    typedef struct {\n        float position[3];\n        float normal[3];\n        float uv[2];\n    } MeshVertex;\n\n    zest_AddVertexInputBindingDescription(pipeline, 0, sizeof(MeshVertex), zest_input_rate_vertex);\n    zest_AddVertexAttribute(pipeline, 0, 0, zest_format_r32g32b32_sfloat, offsetof(MeshVertex, position));\n    zest_AddVertexAttribute(pipeline, 0, 1, zest_format_r32g32b32_sfloat, offsetof(MeshVertex, normal));\n    zest_AddVertexAttribute(pipeline, 0, 2, zest_format_r32g32_sfloat, offsetof(MeshVertex, uv));\n\n    // Configure rasterization\n    zest_SetPipelineTopology(pipeline, zest_topology_triangle_list);\n    zest_SetPipelineCullMode(pipeline, zest_cull_mode_back);\n    zest_SetPipelineFrontFace(pipeline, zest_front_face_clockwise);\n    zest_SetPipelinePolygonFillMode(pipeline, zest_polygon_mode_fill);\n\n    // Configure depth testing\n    zest_SetPipelineDepthTest(pipeline, ZEST_TRUE, ZEST_TRUE);\n\n    // Configure blending (opaque)\n    zest_SetPipelineBlend(pipeline, zest_BlendStateNone());\n\n    return pipeline;\n}\n</code></pre>"},{"location":"api-reference/pipeline/#see-also","title":"See Also","text":"<ul> <li>Pipelines Concept</li> <li>Instancing Tutorial</li> <li>Frame Graph API</li> </ul>"},{"location":"api-reference/timer/","title":"Timer API","text":"<p>Timing and fixed timestep utilities for game loops and simulations. The timer system provides a fixed timestep loop with accumulator-based timing, which is essential for deterministic physics and smooth rendering with interpolation.</p> <p>You can also just roll your own but this can cover a lot of needs.</p>"},{"location":"api-reference/timer/#timer-type","title":"Timer Type","text":"<pre><code>typedef struct zest_timer_t {\n    double start_time;\n    double delta_time;\n    double update_frequency;\n    double update_tick_length;\n    double update_time;\n    double ticker;\n    double accumulator;\n    double accumulator_delta;\n    double current_time;\n    double lerp;\n    double time_passed;\n    double seconds_passed;\n    double max_elapsed_time;\n    int update_count;\n} zest_timer_t;\n</code></pre>"},{"location":"api-reference/timer/#creation","title":"Creation","text":""},{"location":"api-reference/timer/#zest_createtimer","title":"<code>zest_CreateTimer</code>","text":"<p>Create a timer with a target update frequency.</p> <pre><code>zest_timer_t zest_CreateTimer(double update_frequency);\n</code></pre> <ul> <li><code>update_frequency</code> - Target updates per second (Hz)</li> </ul> <p>Usage: Initialize a timer for your game loop. Common frequencies are 60 Hz for gameplay or 120+ Hz for physics.</p> <pre><code>zest_timer_t timer = zest_CreateTimer(60.0);   // 60 updates per second\nzest_timer_t physics_timer = zest_CreateTimer(120.0);  // 120 Hz physics\n</code></pre>"},{"location":"api-reference/timer/#configuration","title":"Configuration","text":""},{"location":"api-reference/timer/#zest_timersetupdatefrequency","title":"<code>zest_TimerSetUpdateFrequency</code>","text":"<p>Change the update frequency of an existing timer.</p> <pre><code>void zest_TimerSetUpdateFrequency(zest_timer_t *timer, double update_frequency);\n</code></pre> <p>Usage: Dynamically adjust tick rate, such as for slow-motion effects or performance scaling.</p> <pre><code>// Slow motion: halve the update rate\nzest_TimerSetUpdateFrequency(&amp;timer, 30.0);\n\n// Return to normal\nzest_TimerSetUpdateFrequency(&amp;timer, 60.0);\n</code></pre>"},{"location":"api-reference/timer/#zest_timersetmaxframes","title":"<code>zest_TimerSetMaxFrames</code>","text":"<p>Set the maximum accumulated time (prevents spiral of death).</p> <pre><code>void zest_TimerSetMaxFrames(zest_timer_t *timer, double frames);\n</code></pre> <ul> <li><code>frames</code> - Maximum number of frames worth of time to accumulate</li> </ul> <p>Usage: Prevent the simulation from running too many updates after a lag spike, which could cause further lag and create a \"spiral of death.\"</p> <pre><code>// Limit to 4 frames of accumulated time\nzest_TimerSetMaxFrames(&amp;timer, 4.0);\n</code></pre>"},{"location":"api-reference/timer/#zest_timerreset","title":"<code>zest_TimerReset</code>","text":"<p>Reset the timer's clock to the current time.</p> <pre><code>void zest_TimerReset(zest_timer_t *timer);\n</code></pre> <p>Usage: Reset timing after pausing, loading, or other interruptions to prevent large delta times.</p> <pre><code>// After loading screen or pause menu\nzest_TimerReset(&amp;timer);\n</code></pre>"},{"location":"api-reference/timer/#per-frame-updates","title":"Per-Frame Updates","text":""},{"location":"api-reference/timer/#zest_timertick","title":"<code>zest_TimerTick</code>","text":"<p>Update the timer's delta time. Call once per frame before using delta time.</p> <pre><code>void zest_TimerTick(zest_timer_t *timer);\n</code></pre> <p>Usage: Update the timer at the start of each frame to calculate elapsed time.</p> <pre><code>while (running) {\n    zest_TimerTick(&amp;timer);\n\n    // Use timer for updates and rendering\n    // ...\n}\n</code></pre>"},{"location":"api-reference/timer/#zest_timerdeltatime","title":"<code>zest_TimerDeltaTime</code>","text":"<p>Get the time elapsed since the last tick (in seconds).</p> <pre><code>double zest_TimerDeltaTime(zest_timer_t *timer);\n</code></pre> <p>Usage: Get raw frame time for variable timestep operations like camera movement or UI animations.</p> <pre><code>zest_TimerTick(&amp;timer);\ndouble dt = zest_TimerDeltaTime(&amp;timer);\n\n// Variable timestep camera movement\ncamera_pos.x += input_x * camera_speed * dt;\ncamera_pos.y += input_y * camera_speed * dt;\n</code></pre>"},{"location":"api-reference/timer/#fixed-timestep-loop","title":"Fixed Timestep Loop","text":"<p>Fixed timestep loops run game logic at a consistent rate regardless of frame rate, which is essential for deterministic physics and network synchronization.</p>"},{"location":"api-reference/timer/#zest_timeraccumulate","title":"<code>zest_TimerAccumulate</code>","text":"<p>Add the elapsed time since last frame to the accumulator.</p> <pre><code>double zest_TimerAccumulate(zest_timer_t *timer);\n</code></pre> <p>Returns: The accumulated time in seconds.</p> <p>Usage: Called at the start of your fixed timestep loop to accumulate frame time.</p> <pre><code>zest_TimerAccumulate(&amp;timer);\nwhile (zest_TimerDoUpdate(&amp;timer)) {\n    // Fixed rate update\n    zest_TimerUnAccumulate(&amp;timer);\n}\n</code></pre>"},{"location":"api-reference/timer/#zest_timerdoupdate","title":"<code>zest_TimerDoUpdate</code>","text":"<p>Check if another fixed timestep update should run.</p> <pre><code>zest_bool zest_TimerDoUpdate(zest_timer_t *timer);\n</code></pre> <p>Returns: <code>ZEST_TRUE</code> if the accumulator has enough time for another update.</p> <p>Usage: Loop condition for fixed timestep updates.</p> <pre><code>while (zest_TimerDoUpdate(&amp;timer)) {\n    UpdatePhysics(zest_TimerUpdateTime(&amp;timer));\n    zest_TimerUnAccumulate(&amp;timer);\n}\n</code></pre>"},{"location":"api-reference/timer/#zest_timerunaccumulate","title":"<code>zest_TimerUnAccumulate</code>","text":"<p>Subtract one tick's worth of time from the accumulator.</p> <pre><code>void zest_TimerUnAccumulate(zest_timer_t *timer);\n</code></pre> <p>Usage: Called after each fixed update to consume accumulated time.</p> <pre><code>while (zest_TimerDoUpdate(&amp;timer)) {\n    // Run one fixed update\n    UpdateGameLogic();\n    zest_TimerUnAccumulate(&amp;timer);  // Consume the time\n}\n</code></pre>"},{"location":"api-reference/timer/#zest_timerpendingticks","title":"<code>zest_TimerPendingTicks</code>","text":"<p>Get the number of fixed updates that will run this frame.</p> <pre><code>int zest_TimerPendingTicks(zest_timer_t *timer);\n</code></pre> <p>Usage: Useful for debugging or adjusting behavior based on update count.</p> <pre><code>zest_TimerAccumulate(&amp;timer);\nint ticks = zest_TimerPendingTicks(&amp;timer);\nif (ticks &gt; 3) {\n    // Many updates pending - maybe skip some non-essential work\n}\n</code></pre>"},{"location":"api-reference/timer/#zest_timerset","title":"<code>zest_TimerSet</code>","text":"<p>Update the lerp value after processing all fixed updates.</p> <pre><code>void zest_TimerSet(zest_timer_t *timer);\n</code></pre> <p>Usage: Called after the fixed update loop to prepare the interpolation value for rendering.</p> <pre><code>zest_TimerAccumulate(&amp;timer);\nwhile (zest_TimerDoUpdate(&amp;timer)) {\n    UpdateLogic();\n    zest_TimerUnAccumulate(&amp;timer);\n}\nzest_TimerSet(&amp;timer);  // Prepare lerp for rendering\n</code></pre>"},{"location":"api-reference/timer/#helper-macros","title":"Helper Macros","text":"<p>Convenience macros that wrap the fixed timestep loop pattern.</p> <pre><code>#define zest_StartTimerLoop(timer)  zest_TimerAccumulate(&amp;timer); \\\n    int pending_ticks = zest_TimerPendingTicks(&amp;timer); \\\n    while (zest_TimerDoUpdate(&amp;timer)) {\n\n#define zest_EndTimerLoop(timer)    zest_TimerUnAccumulate(&amp;timer); \\\n    } \\\n    zest_TimerSet(&amp;timer);\n</code></pre> <p>Usage: Simplify the fixed timestep loop boilerplate.</p> <pre><code>// Fixed timestep game loop\nzest_StartTimerLoop(timer) {\n    // This runs at fixed rate (e.g., 60 times per second)\n    UpdatePhysics(zest_TimerUpdateTime(&amp;timer));\n    UpdateGameLogic();\n} zest_EndTimerLoop(timer);\n\n// Render with interpolation\nfloat t = zest_TimerLerp(&amp;timer);\nRenderScene(t);\n</code></pre>"},{"location":"api-reference/timer/#timing-information","title":"Timing Information","text":""},{"location":"api-reference/timer/#zest_timerframelength","title":"<code>zest_TimerFrameLength</code>","text":"<p>Get the fixed frame length in seconds (1.0 / frequency).</p> <pre><code>double zest_TimerFrameLength(zest_timer_t *timer);\n</code></pre> <p>Usage: Get the fixed timestep duration for physics and game logic.</p> <pre><code>double dt = zest_TimerFrameLength(&amp;timer);  // e.g., 0.01666... for 60 Hz\nvelocity.y -= gravity * dt;\nposition = zest_AddVec3(position, zest_ScaleVec3(velocity, dt));\n</code></pre>"},{"location":"api-reference/timer/#zest_timerupdatetime","title":"<code>zest_TimerUpdateTime</code>","text":"<p>Get the update time (same as frame length, 1.0 / frequency).</p> <pre><code>double zest_TimerUpdateTime(zest_timer_t *timer);\n</code></pre> <p>Usage: Alternative name for getting the fixed timestep duration.</p> <pre><code>double fixed_dt = zest_TimerUpdateTime(&amp;timer);\n</code></pre>"},{"location":"api-reference/timer/#zest_timerupdatefrequency","title":"<code>zest_TimerUpdateFrequency</code>","text":"<p>Get the current update frequency in Hz.</p> <pre><code>double zest_TimerUpdateFrequency(zest_timer_t *timer);\n</code></pre> <p>Usage: Query the timer's configured update rate.</p> <pre><code>double freq = zest_TimerUpdateFrequency(&amp;timer);  // e.g., 60.0\n</code></pre>"},{"location":"api-reference/timer/#zest_timerupdatewasrun","title":"<code>zest_TimerUpdateWasRun</code>","text":"<p>Check if at least one fixed update was run this frame.</p> <pre><code>zest_bool zest_TimerUpdateWasRun(zest_timer_t *timer);\n</code></pre> <p>Usage: Determine if game state changed this frame (useful for networking or replay systems).</p> <pre><code>if (zest_TimerUpdateWasRun(&amp;timer)) {\n    // Game state was updated - send network snapshot\n    SendNetworkUpdate();\n}\n</code></pre>"},{"location":"api-reference/timer/#interpolation","title":"Interpolation","text":""},{"location":"api-reference/timer/#zest_timerlerp","title":"<code>zest_TimerLerp</code>","text":"<p>Get the interpolation factor for smooth rendering between fixed updates.</p> <pre><code>double zest_TimerLerp(zest_timer_t *timer);\n</code></pre> <p>Returns: A value between 0.0 and 1.0 representing progress toward the next fixed update.</p> <p>Usage: Interpolate between previous and current state for smooth rendering at any frame rate.</p> <pre><code>// Fixed update loop - store previous state\nzest_StartTimerLoop(timer) {\n    previous_position = current_position;\n    current_position = UpdatePhysics();\n} zest_EndTimerLoop(timer);\n\n// Render with interpolation for smooth visuals\ndouble t = zest_TimerLerp(&amp;timer);\nzest_vec3 render_pos = zest_LerpVec3(&amp;previous_position, &amp;current_position, (float)t);\nDrawObject(render_pos);\n</code></pre>"},{"location":"api-reference/timer/#complete-example","title":"Complete Example","text":"<pre><code>// Initialize timer at 60 Hz\nzest_timer_t timer = zest_CreateTimer(60.0);\nzest_TimerSetMaxFrames(&amp;timer, 4.0);  // Prevent spiral of death\n\n// Game state (double-buffered for interpolation)\nzest_vec3 prev_player_pos, player_pos;\nzest_vec3 player_velocity = zest_Vec3Set(0, 0, 0);\n\nwhile (running) {\n    // Update timer\n    zest_TimerTick(&amp;timer);\n\n    // Handle input (variable rate)\n    ProcessInput();\n\n    // Fixed timestep game loop\n    zest_StartTimerLoop(timer) {\n        double dt = zest_TimerFrameLength(&amp;timer);\n\n        // Save previous state for interpolation\n        prev_player_pos = player_pos;\n\n        // Physics update at fixed rate\n        player_velocity.y -= 9.8f * dt;  // Gravity\n        player_pos = zest_AddVec3(player_pos, zest_ScaleVec3(player_velocity, dt));\n\n        // Collision detection\n        HandleCollisions();\n\n    } zest_EndTimerLoop(timer);\n\n    // Render with interpolation\n    double t = zest_TimerLerp(&amp;timer);\n    zest_vec3 render_pos = zest_LerpVec3(&amp;prev_player_pos, &amp;player_pos, (float)t);\n\n    RenderScene(render_pos);\n    PresentFrame();\n}\n</code></pre>"},{"location":"api-reference/timer/#why-fixed-timestep","title":"Why Fixed Timestep?","text":"<p>Fixed timestep loops provide several benefits:</p> <ol> <li>Deterministic Physics - Same inputs always produce same results</li> <li>Stable Simulations - No explosions from large delta times</li> <li>Network Sync - Easier to synchronize game state across clients</li> <li>Replay Systems - Record inputs, replay exactly</li> <li>Smooth Rendering - Interpolation provides smooth visuals at any frame rate</li> </ol> <p>The tradeoff is slightly more complex code, but the <code>zest_StartTimerLoop</code>/<code>zest_EndTimerLoop</code> macros minimize this.</p>"},{"location":"api-reference/timer/#see-also","title":"See Also","text":"<ul> <li>First Application - Timer usage in main loop</li> <li>Math API - Interpolation functions for smooth rendering</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>This section provides deep dives into Zest's core systems. Each concept page explains the design, API, and best practices.</p>"},{"location":"concepts/#core-architecture","title":"Core Architecture","text":"Concept Description Device &amp; Context The two fundamental objects in Zest Frame Graph The declarative execution model Memory Management TLSF allocator and memory pools Bindless Descriptors Global descriptor set design"},{"location":"concepts/#resource-types","title":"Resource Types","text":"Concept Description Pipelines Graphics and compute pipeline templates Buffers Vertex, index, uniform, and storage buffers Images Textures, render targets, and samplers Layers Instance, mesh, and font rendering systems"},{"location":"concepts/#recommended-reading-order","title":"Recommended Reading Order","text":"<ol> <li>Device &amp; Context - Start here to understand the basic structure</li> <li>Frame Graph - The most important concept in Zest</li> <li>Pipelines - How to set up rendering state</li> <li>Buffers and Images - Resource management</li> <li>Layers - High-level rendering abstractions</li> <li>Bindless Descriptors - Advanced descriptor management</li> </ol>"},{"location":"concepts/bindless/","title":"Bindless Descriptors","text":"<p>Zest uses a bindless descriptor model where all resources are indexed into global arrays. This eliminates per-object descriptor set management and enables flexible resource access.</p>"},{"location":"concepts/bindless/#why-bindless","title":"Why Bindless?","text":"<p>In the case of Vulkan (not so much with Direct X and Metal), it requires creating and binding separate descriptor sets for each object's resources. This creates overhead from: - Allocating descriptor sets from pools - Updating descriptors when resources change - Binding different sets between draw calls</p> <p>Bindless descriptors solve this by putting all resources into large arrays indexed by integers. You bind the global descriptor set once, then pass indices via push constants or uniform buffers to select which resources each draw call uses.</p>"},{"location":"concepts/bindless/#how-bindless-works","title":"How Bindless Works","text":"<p>The following pseudocode illustrates the conceptual difference:</p>"},{"location":"concepts/bindless/#traditional-model","title":"Traditional Model","text":"<pre><code>// Per-object descriptor sets (Vulkan traditional)\nVkDescriptorSet object1_set = CreateDescriptorSet(texture1, sampler);\nVkDescriptorSet object2_set = CreateDescriptorSet(texture2, sampler);\n\n// Must bind different sets per object\nvkCmdBindDescriptorSets(..., object1_set);\nvkCmdDraw(...);\nvkCmdBindDescriptorSets(..., object2_set);\nvkCmdDraw(...);\n</code></pre>"},{"location":"concepts/bindless/#bindless-model","title":"Bindless Model","text":"<pre><code>// Single global set with all resources - bound once at frame start\n// (Zest binds this automatically during frame graph execution)\n\n// Pass indices via push constants to select resources\npush.tex_index = object1_texture_index;\nzest_cmd_SendPushConstants(cmd, &amp;push, sizeof(push));\nzest_cmd_Draw(cmd, vertex_count, 1, 0, 0);\n\npush.tex_index = object2_texture_index;\nzest_cmd_SendPushConstants(cmd, &amp;push, sizeof(push));\nzest_cmd_Draw(cmd, vertex_count, 1, 0, 0);\n</code></pre>"},{"location":"concepts/bindless/#resource-types","title":"Resource Types","text":"<p>Zest's bindless system supports:</p> Binding Constant Resource Type Array 0 <code>zest_sampler_binding</code> Samplers <code>sampler[]</code> 1 <code>zest_texture_2d_binding</code> 2D Textures <code>texture2D[]</code> 2 <code>zest_texture_cube_binding</code> Cube Textures <code>textureCube[]</code> 3 <code>zest_texture_array_binding</code> Texture Arrays <code>texture2DArray[]</code> 4 <code>zest_texture_3d_binding</code> 3D Textures <code>texture3D[]</code> 5 <code>zest_storage_buffer_binding</code> Storage Buffers <code>buffer[]</code> 6 <code>zest_storage_image_binding</code> Storage Images <code>image2D[]</code> 7 <code>zest_uniform_buffer_binding</code> Uniform Buffers <code>uniform[]</code> <p>Take note of the binding numbers as that's what you need to use to correctly set up your shaders.</p>"},{"location":"concepts/bindless/#acquiring-indices","title":"Acquiring Indices","text":""},{"location":"concepts/bindless/#sampled-images-textures","title":"Sampled Images (Textures)","text":"<pre><code>zest_image image = zest_GetImage(image_handle);\n\n// Acquire index for 2D texture\nzest_uint tex_index = zest_AcquireSampledImageIndex(\n    device,\n    image,\n    zest_texture_2d_binding  // Binding type\n);\n</code></pre>"},{"location":"concepts/bindless/#samplers","title":"Samplers","text":"<pre><code>zest_sampler sampler = zest_GetSampler(sampler_handle);\nzest_uint sampler_index = zest_AcquireSamplerIndex(device, sampler);\n</code></pre>"},{"location":"concepts/bindless/#storage-images","title":"Storage Images","text":"<pre><code>zest_uint storage_index = zest_AcquireStorageImageIndex(device, image, zest_storage_image_binding);\n</code></pre>"},{"location":"concepts/bindless/#storage-buffers","title":"Storage Buffers","text":"<pre><code>zest_uint buffer_index = zest_AcquireStorageBufferIndex(device, buffer);\n</code></pre>"},{"location":"concepts/bindless/#uniform-buffers","title":"Uniform Buffers","text":"<pre><code>//(Indexes are acquired automatically when the uniform buffer is created)\nzest_uniform_buffer_handle ubo_handle = zest_CreateUniformBuffer(context, \"camera\", sizeof(camera_t));\nzest_uniform_buffer ubo = zest_GetUniformBuffer(ubo_handle);\nzest_uint ubo_index = zest_GetUniformBufferDescriptorIndex(ubo);\n</code></pre>"},{"location":"concepts/bindless/#shader-setup","title":"Shader Setup","text":""},{"location":"concepts/bindless/#glsl-descriptor-layout","title":"GLSL Descriptor Layout","text":"<pre><code>#version 450\n#extension GL_EXT_nonuniform_qualifier : enable\n\n// Bindless arrays at set 0 (binding numbers match zest_binding_number_type)\nlayout(set = 0, binding = 0) uniform sampler samplers[];           // zest_sampler_binding\nlayout(set = 0, binding = 1) uniform texture2D textures[];         // zest_texture_2d_binding\nlayout(set = 0, binding = 2) uniform textureCube cubemaps[];       // zest_texture_cube_binding\nlayout(set = 0, binding = 3) uniform texture2D texture_arrays[];   // zest_texture_array_binding\nlayout(set = 0, binding = 5) buffer StorageBuffers {               // zest_storage_buffer_binding\n    float data[];\n} storage_buffers[];\nlayout(set = 0, binding = 6, rgba16f) uniform image2D storage_images[];  // zest_storage_image_binding\nlayout(set = 0, binding = 7) uniform UniformBuffers {              // zest_uniform_buffer_binding\n    mat4 view;\n    mat4 projection;\n} uniforms[];\n\n// Push constants for indices\nlayout(push_constant) uniform PushConstants {\n    uint texture_index;\n    uint sampler_index;\n    uint ubo_index;\n} push;\n\nvoid main() {\n    // Sample texture using indices\n    vec4 color = texture(\n        sampler2D(textures[push.texture_index], samplers[push.sampler_index]),\n        uv\n    );\n\n    // Access uniform buffer\n    mat4 vp = uniforms[push.ubo_index].view * uniforms[push.ubo_index].projection;\n}\n</code></pre>"},{"location":"concepts/bindless/#slang-descriptor-layout","title":"Slang Descriptor Layout","text":"<pre><code>// Bindless resources\nSampler2D textures[];\nSamplerState samplers[];\n\nstruct PushConstants {\n    uint textureIndex;\n    uint samplerIndex;\n};\n[[vk::push_constant]] PushConstants push;\n\nfloat4 main() : SV_Target {\n    return textures[push.textureIndex].Sample(samplers[push.samplerIndex], uv);\n}\n</code></pre>"},{"location":"concepts/bindless/#push-constants","title":"Push Constants","text":"<p>Push constants are the primary way to pass indices to shaders.</p>"},{"location":"concepts/bindless/#defining-push-constants","title":"Defining Push Constants","text":"<pre><code>struct push_constants_t {\n    zest_matrix4 transform;\n    zest_uint texture_index;\n    zest_uint sampler_index;\n    zest_uint ubo_index;\n    float time;\n};\n</code></pre>"},{"location":"concepts/bindless/#sending-push-constants","title":"Sending Push Constants","text":"<pre><code>void RenderCallback(zest_command_list cmd, void* data) {\n    app_t* app = (app_t*)data;\n\n    push_constants_t push = {};\n    push.transform = app-&gt;model_matrix;\n    push.texture_index = app-&gt;texture_index;\n    push.sampler_index = app-&gt;sampler_index;\n    push.ubo_index = app-&gt;ubo_index;\n    push.time = app-&gt;current_time;\n\n    zest_cmd_SendPushConstants(cmd, &amp;push, sizeof(push));\n    zest_cmd_Draw(cmd, 6, 1, 0, 0);  // vertex_count, instance_count, first_vertex, first_instance\n}\n</code></pre>"},{"location":"concepts/bindless/#releasing-indices","title":"Releasing Indices","text":"<pre><code>// Release image indices (sampled or storage images)\n// Pass the image and the binding type used when acquiring\nzest_ReleaseImageIndex(device, image, zest_texture_2d_binding);\nzest_ReleaseImageIndex(device, image, zest_storage_image_binding);\n\n// Release storage buffer index (uses array index directly)\nzest_ReleaseStorageBufferIndex(device, buffer_index);\n</code></pre> <p>Note: Image indices, Sampler indices and uniform buffer indices are managed automatically when the resource is freed.</p>"},{"location":"concepts/bindless/#bindless-layout-access","title":"Bindless Layout Access","text":"<p>Access the device's bindless descriptor set layout:</p>"},{"location":"concepts/bindless/#per-instance-indices","title":"Per-Instance Indices","text":"<p>For instanced rendering, store indices in instance data:</p> <pre><code>struct instance_t {\n    zest_vec3 position;\n    zest_uint texture_index;  // Each instance can have different texture\n    zest_uint material_index;\n};\n</code></pre> <p>In shader:</p> <pre><code>layout(location = 3) in uint in_texture_index;\n\nvoid main() {\n    vec4 color = texture(\n        sampler2D(textures[in_texture_index], samplers[0]),\n        uv\n    );\n}\n</code></pre>"},{"location":"concepts/bindless/#best-practices","title":"Best Practices","text":"<ol> <li>Acquire indices at load time - Not every frame</li> <li>Release indices when done - Prevents descriptor pool exhaustion</li> <li>Use push constants for dynamic indices - Fast to update</li> <li>Store static indices in instance data - For per-object textures</li> </ol>"},{"location":"concepts/bindless/#limitations","title":"Limitations","text":"<ul> <li>Maximum resources depend on GPU limits (usually 500K+ descriptors)</li> <li>Some older GPUs have lower limits</li> <li><code>GL_EXT_nonuniform_qualifier</code> required for non-uniform indexing in GLSL shaders</li> </ul>"},{"location":"concepts/bindless/#example-multi-textured-scene","title":"Example: Multi-Textured Scene","text":"<pre><code>// At load time\nstruct object_t {\n    zest_uint texture_index;\n    zest_uint normal_index;\n    zest_uint index_count;\n    zest_uint index_offset;\n};\n\nobject_t objects[MAX_OBJECTS];\nfor (int i = 0; i &lt; object_count; i++) {\n    objects[i].texture_index = zest_AcquireSampledImageIndex(device,\n        zest_GetImage(textures[i]), zest_texture_2d_binding);\n    objects[i].normal_index = zest_AcquireSampledImageIndex(device,\n        zest_GetImage(normals[i]), zest_texture_2d_binding);\n}\n\n// At render time\nvoid RenderCallback(zest_command_list cmd, void* data) {\n    scene_t* scene = (scene_t*)data;\n    push_constants_t push = {};\n\n    for (int i = 0; i &lt; scene-&gt;object_count; i++) {\n        push.texture_index = scene-&gt;objects[i].texture_index;\n        push.normal_index = scene-&gt;objects[i].normal_index;\n        zest_cmd_SendPushConstants(cmd, &amp;push, sizeof(push));\n        zest_cmd_DrawIndexed(cmd,\n            scene-&gt;objects[i].index_count,  // index_count\n            1,                               // instance_count\n            scene-&gt;objects[i].index_offset, // first_index\n            0,                               // vertex_offset\n            0);                              // first_instance\n    }\n}\n</code></pre>"},{"location":"concepts/bindless/#see-also","title":"See Also","text":"<ul> <li>Images - Image creation and bindless indices</li> <li>Pipelines - Push constant configuration</li> <li>API Reference - Bindless functions</li> </ul>"},{"location":"concepts/buffers/","title":"Buffers","text":"<p>Buffers are GPU memory regions for vertex data, indices, uniforms, and general storage. Zest provides flexible buffer creation and management.</p>"},{"location":"concepts/buffers/#buffer-types","title":"Buffer Types","text":"Type Usage Memory Vertex Vertex attributes GPU only Index Index data GPU only Uniform Shader uniforms CPU visible Storage Shader read/write GPU only Staging CPU to GPU transfer CPU visible"},{"location":"concepts/buffers/#creating-buffers","title":"Creating Buffers","text":""},{"location":"concepts/buffers/#basic-buffer","title":"Basic Buffer","text":"<pre><code>zest_buffer_info_t info = zest_CreateBufferInfo(\n    zest_buffer_type_vertex,       // Type\n    zest_memory_usage_gpu_only     // Memory location\n);\n\nzest_buffer buffer = zest_CreateBuffer(device, size_in_bytes, &amp;info);\n</code></pre>"},{"location":"concepts/buffers/#buffer-types_1","title":"Buffer Types","text":"<pre><code>// Vertex buffer (for vertex attributes)\nzest_buffer_info_t info = zest_CreateBufferInfo(zest_buffer_type_vertex, zest_memory_usage_gpu_only);\n\n// Index buffer\nzest_buffer_info_t info = zest_CreateBufferInfo(zest_buffer_type_index, zest_memory_usage_gpu_only);\n\n// Storage buffer (for compute shaders)\nzest_buffer_info_t info = zest_CreateBufferInfo(zest_buffer_type_storage, zest_memory_usage_gpu_only);\n\n// Vertex + storage (readable in vertex/fragment shaders)\nzest_buffer_info_t info = zest_CreateBufferInfo(zest_buffer_type_vertex_storage, zest_memory_usage_gpu_only);\n</code></pre>"},{"location":"concepts/buffers/#memory-usage","title":"Memory Usage","text":"<pre><code>zest_memory_usage_gpu_only     // Fast GPU access, no CPU access\nzest_memory_usage_cpu_to_gpu   // CPU can write, used for uploads\nzest_memory_usage_gpu_to_cpu   // GPU writes, CPU can read back\n</code></pre>"},{"location":"concepts/buffers/#uploading-data","title":"Uploading Data","text":""},{"location":"concepts/buffers/#staging-buffer-approach","title":"Staging Buffer Approach","text":"<p>For large uploads, use a staging buffer:</p> <pre><code>// Create staging buffer with data\nzest_buffer staging = zest_CreateStagingBuffer(device, data_size, cpu_data);\n\n// Copy to GPU buffer\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_CopyBuffer(queue, staging, gpu_buffer, data_size);\nzest_imm_EndCommandBuffer(queue);\n\n// Free staging buffer\nzest_FreeBuffer(staging);\n</code></pre>"},{"location":"concepts/buffers/#in-frame-graph","title":"In Frame Graph","text":"<p>Copy operations in a transfer pass:</p> <pre><code>zest_BeginTransferPass(\"Upload\"); {\n    zest_ConnectOutput(buffer_resource);\n    zest_SetPassTask(UploadCallback, app);\n    zest_EndPass();\n}\n\nvoid UploadCallback(zest_command_list cmd, void* user_data) {\n    ...\n    zest_cmd_CopyBuffer(cmd, staging, dest, size);\n}\n</code></pre>"},{"location":"concepts/buffers/#uniform-buffers","title":"Uniform Buffers","text":"<p>Per-frame uniform data with automatic multi-buffering. This means that inside the uniform buffer is a buffer for each frame in flight so you can safely modify one while the other is being accessed by the GPU.</p> <pre><code>// Create uniform buffer (returns a handle)\nzest_uniform_buffer_handle ubo = zest_CreateUniformBuffer(context, \"camera_ubo\", sizeof(camera_t));\n\n// Get pointer to current frame's data\nuniform_data_t* ubo = (uniform_data_t*)zest_GetUniformBufferData(ubo);\nubo-&gt;view = view_matrix;\nubo-&gt;projection = proj_matrix;\n\n// Get descriptor index for shader. Each frame each have a different index (one for each frame in flight)\nzest_uint ubo_index = zest_GetUniformBufferDescriptorIndex(ubo);\n</code></pre>"},{"location":"concepts/buffers/#using-uniform-buffers-in-shaders","title":"Using Uniform Buffers in Shaders","text":"<pre><code>layout(set = 0, binding = 7) uniform CameraUBO {\n    mat4 view;\n    mat4 projection;\n} camera[];\n\nvoid main() {\n    mat4 view = camera[push.ubo_index].view;\n}\n</code></pre>"},{"location":"concepts/buffers/#buffer-operations","title":"Buffer Operations","text":""},{"location":"concepts/buffers/#resize-and-grow","title":"Resize and Grow","text":"<pre><code>// Resize buffer (may reallocate) - takes pointer to buffer\nzest_ResizeBuffer(&amp;buffer, new_size);\n\n// Grow buffer (only if needed) - takes pointer, unit size, and minimum bytes\nzest_GrowBuffer(&amp;buffer, unit_size, minimum_bytes);\n\n// Get current size\nzest_size size = zest_GetBufferSize(buffer);\n</code></pre>"},{"location":"concepts/buffers/#accessing-buffer-data","title":"Accessing Buffer Data","text":"<p>For CPU-visible buffers, you can directly access the mapped memory:</p> <pre><code>// Get pointer to buffer data (persistently mapped)\nvoid* data = zest_BufferData(buffer);\nmemcpy(data, src, size);\n\n// Get pointer to end of buffer (for bounds checking)\nvoid* end = zest_BufferDataEnd(buffer);\n</code></pre>"},{"location":"concepts/buffers/#free-buffer","title":"Free Buffer","text":"<pre><code>// Immediately frees the buffer\nzest_FreeBuffer(buffer);\n</code></pre>"},{"location":"concepts/buffers/#memory-pools","title":"Memory Pools","text":"<p>Buffers are allocated from named memory pools managed by the device. Pool sizes can be configured after device creation:</p> <pre><code>// Configure GPU buffer pool (minimum allocation size, total pool size)\nzest_SetGPUBufferPoolSize(device, zloc__KILOBYTE(64), zloc__MEGABYTE(128));\n\n// Configure GPU buffer pool for small buffers (minimum allocation size, total pool size)\nzest_SetGPUSmallBufferPoolSize(device, zloc__KILOBYTE(1), zloc__MEGABYTE(8));\n\n// Configure staging buffer pool\nzest_SetStagingBufferPoolSize(device, zloc__KILOBYTE(64), zloc__MEGABYTE(64));\n</code></pre>"},{"location":"concepts/buffers/#why-separate-small-buffer-pools","title":"Why Separate Small Buffer Pools?","text":"<p>Zest uses a TLSF (Two-Level Segregated Fit) allocator that tracks memory blocks using proxy structures. Each allocatable block in the pool requires a small proxy header to track its state (free/used, size, neighbors). The minimum block size determines how many potential blocks exist in a pool.</p> <p>With a large pool (e.g., 128MB) and a small minimum block size (e.g., 1KB), you would have up to 128K potential blocks, each requiring proxy overhead. This wastes memory on bookkeeping. A larger minimum block size (e.g., 64KB) reduces proxy count to ~2K blocks, which is much more efficient.</p> <p>However, if your application allocates many small buffers (under 64KB), a large minimum block size wastes space due to internal fragmentation - each small allocation rounds up to the minimum size.</p> <p>The solution is separate pools: - Large buffer pool: Large minimum block size (64KB+), efficient for big allocations - Small buffer pool: Small minimum block size (1KB), smaller total pool size to limit proxy overhead</p> <p>This also helps with external fragmentation. Small allocations mixed with large ones can fragment a pool over time, making it hard to find contiguous space for large allocations. Keeping them separate prevents small buffers from fragmenting the large buffer pool.</p> <p>New pools are allocated when they run out of space. See Memory Management for detailed pool configuration.</p>"},{"location":"concepts/buffers/#command-buffer-operations","title":"Command Buffer Operations","text":""},{"location":"concepts/buffers/#bind-buffers","title":"Bind Buffers","text":"<pre><code>// Bind vertex buffer (first_binding, binding_count, buffer)\nzest_cmd_BindVertexBuffer(cmd, 0, 1, buffer);\n\n// Bind index buffer\nzest_cmd_BindIndexBuffer(cmd, buffer);\n</code></pre>"},{"location":"concepts/buffers/#copy-buffers","title":"Copy Buffers","text":"<pre><code>// Copy entire buffer\nzest_cmd_CopyBuffer(cmd, src, dst, size);\n</code></pre>"},{"location":"concepts/buffers/#transient-buffers","title":"Transient Buffers","text":"<p>Temporary buffers within a frame graph:</p> <pre><code>zest_buffer_resource_info_t info = {\n    .size = particle_count * sizeof(particle_t),\n    .usage_hints = zest_resource_usage_hint_vertex_buffer\n};\nzest_resource_node particles = zest_AddTransientBufferResource(\"Particles\", &amp;info);\n</code></pre> <p>Transient buffers:</p> <ul> <li>Are allocated from a shared pool</li> <li>Can share memory with non-overlapping resources</li> <li>Are automatically freed after frame graph execution</li> </ul>"},{"location":"concepts/buffers/#best-practices","title":"Best Practices","text":"<ol> <li>Use staging buffers - For large GPU-only uploads</li> <li>Prefer GPU-only memory - Faster for rendering</li> <li>Use uniform buffers - For frequently updated small data</li> <li>Size pools appropriately - Based on your application's needs. The defaults will be fine to start with.</li> <li>Use transient buffers - For intermediate data in multi-pass rendering</li> </ol>"},{"location":"concepts/buffers/#example-particle-buffer","title":"Example: Particle Buffer","text":"<pre><code>// Create particle buffer\nzest_buffer_info_t info = zest_CreateBufferInfo(\n    zest_buffer_type_vertex_storage,\n    zest_memory_usage_gpu_only\n);\nzest_buffer particles = zest_CreateBuffer(device, MAX_PARTICLES * sizeof(particle_t), &amp;info);\n\n// Initial upload\nzest_buffer staging = zest_CreateStagingBuffer(device, initial_size, initial_data);\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_CopyBuffer(queue, staging, particles, initial_size);\nzest_imm_EndCommandBuffer(queue);\nzest_FreeBuffer(staging);\n\n// Use in render callback\nvoid RenderParticles(zest_command_list cmd, void* user_data) {\n    zest_cmd_BindVertexBuffer(cmd, 0, 1, particles);\n    zest_cmd_Draw(cmd, particle_count, 1, 0, 0);\n}\n</code></pre>"},{"location":"concepts/buffers/#see-also","title":"See Also","text":"<ul> <li>Memory Management - Pool configuration</li> <li>Buffer API - Complete function reference</li> <li>Compute Tutorial - Storage buffers with compute</li> </ul>"},{"location":"concepts/device-and-context/","title":"Device &amp; Context","text":"<p>Zest organizes rendering around two core objects: the Device and the Context. Understanding their responsibilities is fundamental to using the library.</p>"},{"location":"concepts/device-and-context/#device-zest_device","title":"Device (<code>zest_device</code>)","text":"<p>The device is a singleton that represents your GPU and all shared resources.</p>"},{"location":"concepts/device-and-context/#creation","title":"Creation","text":"<p>An example of creating a device with SDL2:</p> <pre><code>// Create a window first - the device needs it to query required Vulkan extensions\nzest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My Window\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, false);\n</code></pre> <p>If you need more control, you can use the device builder directly:</p> <pre><code>// Create the device using Vulkan as the platform layer\nzest_device_builder device_builder = zest_BeginVulkanDeviceBuilder();\n// Add your required extensions here\nzest_AddDeviceBuilderExtensions(device_builder, extensions, count);\nif (enable_validation) {\n    zest_AddDeviceBuilderValidation(device_builder);\n    zest_DeviceBuilderLogToConsole(device_builder);\n}\nzest_device device = zest_EndDeviceBuilder(device_builder);\n</code></pre> <p>Ensure that you include the SDL2 header before zest.h when using the SDL2 helper functions.</p>"},{"location":"concepts/device-and-context/#what-the-device-manages","title":"What the Device Manages","text":"Resource Description Platform Instance The Platform API entry point (Currently Vulkan, DX/Metal/WebGPU(?) added in future) Physical Device GPU selection and feature queries Shaders Compiled/Loaded shaders Pipeline Templates Cached pipeline configurations Compute Pipelines Cached pipelines for compute dispatches Bindless Descriptors Global descriptor set for all resources Memory Pools GPU memory allocation (TLSF) and CPU side memory pools Samplers Texture samplers for use in shaders Images All textures stored on the GPU"},{"location":"concepts/device-and-context/#device-lifecycle","title":"Device Lifecycle","text":"<pre><code>int main() {\n    // Create once at startup\n    zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My Window\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, false);\n\n    // ... create contexts, run application ...\n\n    // Destroy at shutdown \n    zest_DestroyDevice(device);\n}\n</code></pre>"},{"location":"concepts/device-and-context/#per-frame-device-update","title":"Per-Frame Device Update","text":"<pre><code>while (running) {\n    zest_UpdateDevice(device);  // Must call every frame\n    // ...\n}\n</code></pre> <p><code>zest_UpdateDevice()</code> handles:</p> <ul> <li>Deferred resource destruction</li> <li>Memory pool maintenance</li> </ul>"},{"location":"concepts/device-and-context/#context-zest_context","title":"Context (<code>zest_context</code>)","text":"<p>A context represents a render target - typically a window with its swapchain.</p>"},{"location":"concepts/device-and-context/#creation_1","title":"Creation","text":"<pre><code>// Create window handles (platform-specific)\nzest_window_data_t window = zest_implsdl2_CreateWindow(\n    50, 50,        // Position\n    1280, 768,     // Size\n    0,             // Maximised (0 = false)\n    \"My Window\"    // Title\n);\n\n// Configure context\nzest_create_context_info_t info = zest_CreateContextInfo();\nZEST__UNFLAG(info.flags, zest_context_init_flag_enable_vsync);  // Disable vsync\n\n// Create context\nzest_context context = zest_CreateContext(device, &amp;window, &amp;info);\n</code></pre>"},{"location":"concepts/device-and-context/#what-the-context-manages","title":"What the Context Manages","text":"Resource Description Swapchain Presentation images Command Pools Per-frame command buffer allocation Synchronization Uses semaphores for frame pacing Frame Graph Cache Compiled frame graphs Linear Allocators Fast per-frame memory"},{"location":"concepts/device-and-context/#context-lifecycle","title":"Context Lifecycle","text":"<pre><code>// Create context for each window\nzest_context context1 = zest_CreateContext(device, &amp;window1, &amp;info);\nzest_context context2 = zest_CreateContext(device, &amp;window2, &amp;info);\n\n// ... run application ...\n\n// Contexts are destroyed with the device\nzest_DestroyDevice(device);\n</code></pre>"},{"location":"concepts/device-and-context/#frame-boundaries","title":"Frame Boundaries","text":"<p>Each frame is bracketed by <code>zest_BeginFrame()</code> and <code>zest_EndFrame()</code>. You must build or retrieve a frame graph between these calls:</p> <pre><code>// Create a cache key for the frame graph (typically done once per frame)\nzest_frame_graph_cache_key_t cache_key = zest_InitialiseCacheKey(context, NULL, 0);\n\nif (zest_BeginFrame(context)) {\n    // Try to retrieve cached frame graph\n    zest_frame_graph frame_graph = zest_GetCachedFrameGraph(context, &amp;cache_key);\n    if (!frame_graph) {\n        // Build new frame graph if not cached\n        if (zest_BeginFrameGraph(context, \"Main Graph\", &amp;cache_key)) {\n            // ... define passes ...\n            frame_graph = zest_EndFrameGraph();\n        }\n    }\n\n    // Execute frame graph and present\n    zest_EndFrame(context, frame_graph);\n}\n</code></pre> <p><code>zest_BeginFrame()</code> returns false if the window is minimized or if the swap chain could not be acquired (window resized or other state change), allowing you to skip rendering. See Frame Graph for details on building and caching frame graphs.</p>"},{"location":"concepts/device-and-context/#multiple-contexts-multi-window","title":"Multiple Contexts (Multi-Window)","text":"<p>One device can serve multiple contexts:</p> <pre><code>zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My Window\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, false);\n\n// Main window\nzest_window_data_t main_window = zest_implsdl2_CreateWindow(...);\nzest_context main_context = zest_CreateContext(device, &amp;main_window, &amp;info);\n\n// Secondary window\nzest_window_data_t debug_window = zest_implsdl2_CreateWindow(...);\nzest_context debug_context = zest_CreateContext(device, &amp;debug_window, &amp;info);\n\nwhile (running) {\n    zest_UpdateDevice(device);\n\n    // Render to main window\n    if (zest_BeginFrame(main_context)) {\n        zest_frame_graph main_graph = /* build or retrieve frame graph */;\n        zest_EndFrame(main_context, main_graph);\n    }\n\n    // Render to debug window\n    if (zest_BeginFrame(debug_context)) {\n        zest_frame_graph debug_graph = /* build or retrieve frame graph */;\n        zest_EndFrame(debug_context, debug_graph);\n    }\n}\n</code></pre>"},{"location":"concepts/device-and-context/#configuration-options","title":"Configuration Options","text":""},{"location":"concepts/device-and-context/#context-flags","title":"Context Flags","text":"<pre><code>zest_create_context_info_t info = zest_CreateContextInfo();\n\n// Disable vsync\nZEST__UNFLAG(info.flags, zest_context_init_flag_enable_vsync);\n\n// Enable vsync (default)\nZEST__FLAG(info.flags, zest_context_init_flag_enable_vsync);\n</code></pre>"},{"location":"concepts/device-and-context/#memory-pool-sizes","title":"Memory Pool Sizes","text":"<p>The device manages multiple named memory pools for different buffer types (device buffers, staging buffers, transient buffers, etc.). Default pool sizes are configured automatically, but can be customized after device creation using <code>zest_SetDevicePoolSize()</code> and <code>zest_SetStagingBufferPoolSize()</code>.</p> <p>See Memory Management for details on pool configuration.</p>"},{"location":"concepts/device-and-context/#utility-functions","title":"Utility Functions","text":""},{"location":"concepts/device-and-context/#window-information","title":"Window Information","text":"<pre><code>// Get screen dimensions\nzest_uint width = zest_ScreenWidth(context);\nzest_uint height = zest_ScreenHeight(context);\n\n// Float versions\nfloat w = zest_ScreenWidthf(context);\nfloat h = zest_ScreenHeightf(context);\n\n// DPI scale\nfloat dpi = zest_DPIScale(context);\n\n// Native window handle (for platform APIs)\nvoid* native = zest_NativeWindow(context);\nSDL_Window* sdl_window = (SDL_Window*)zest_Window(context);\n</code></pre>"},{"location":"concepts/device-and-context/#swapchain-information","title":"Swapchain Information","text":"<pre><code>zest_swapchain swapchain = zest_GetSwapchain(context);\nzest_format format = zest_GetSwapchainFormat(swapchain);\nzest_extent2d_t extent = zest_GetSwapChainExtent(context);\n\n// Set clear color\nzest_SetSwapchainClearColor(context, 0.1f, 0.1f, 0.1f, 1.0f);\n</code></pre>"},{"location":"concepts/device-and-context/#frame-state","title":"Frame State","text":"<pre><code>// Current frame-in-flight index (0 to ZEST_MAX_FIF - 1, default is 2 frames in flight)\nzest_uint fif = zest_CurrentFIF(context);\n\n// Check if swapchain was recreated (window resize)\nif (zest_SwapchainWasRecreated(context)) {\n    // Rebuild resolution-dependent resources\n}\n</code></pre>"},{"location":"concepts/device-and-context/#best-practices","title":"Best Practices","text":"<ol> <li>Create device first - Before any contexts or resources</li> <li>Call <code>zest_UpdateDevice()</code> every frame - Even if not rendering</li> <li>Check <code>zest_BeginFrame()</code> return value - Returns false when minimized or swapchain was not acquired</li> <li>Share resources via device - Textures, pipelines work across contexts</li> <li>Destroy device last - After all rendering is complete</li> </ol>"},{"location":"concepts/device-and-context/#see-also","title":"See Also","text":"<ul> <li>Architecture Overview - High-level design</li> <li>Frame Graph - Execution model</li> <li>Memory Management - Pool configuration</li> </ul>"},{"location":"concepts/images/","title":"Images","text":"<p>Images in Zest represent GPU memory that stores pixel data. This includes textures (sampled in shaders), color attachments (render targets), depth/stencil attachments, and storage images (read/write in compute shaders).</p> <p>Zest uses a handle-based system where <code>zest_image_handle</code> is a lightweight reference to the underlying <code>zest_image</code> resource. This separation allows safe deferred destruction while maintaining fast access during rendering.</p>"},{"location":"concepts/images/#creating-images","title":"Creating Images","text":""},{"location":"concepts/images/#basic-image","title":"Basic Image","text":"<pre><code>zest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.format = zest_format_r8g8b8a8_unorm;\ninfo.flags = zest_image_preset_texture_mipmaps;\n\nzest_image_handle handle = zest_CreateImage(device, &amp;info);\nzest_image image = zest_GetImage(handle);\n</code></pre>"},{"location":"concepts/images/#with-pixel-data","title":"With Pixel Data","text":"<pre><code>// Load pixels (using stb_image or similar)\nint width, height, channels;\nunsigned char* pixels = stbi_load(\"texture.png\", &amp;width, &amp;height, &amp;channels, 4);\n\n// Create image info\nzest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.format = zest_format_r8g8b8a8_unorm;\ninfo.flags = zest_image_preset_texture_mipmaps;\n\n// Create with pixels\nzest_size pixel_size = width * height * 4;\nzest_image_handle handle = zest_CreateImageWithPixels(device, pixels, pixel_size, &amp;info);\n\n//Image is now ready to be sampled in a texture.\n\nstbi_image_free(pixels);\n</code></pre>"},{"location":"concepts/images/#image-presets","title":"Image Presets","text":"<p>Common configurations via flags:</p> <pre><code>// Texture with mipmaps (most common)\ninfo.flags = zest_image_preset_texture_mipmaps;\n\n// Texture without mipmaps\ninfo.flags = zest_image_preset_texture;\n\n// Color attachment (render target)\ninfo.flags = zest_image_preset_color_attachment;\n\n// Depth attachment\ninfo.flags = zest_image_preset_depth_attachment;\n\n// Storage image (compute shader access)\ninfo.flags = zest_image_preset_storage;\n</code></pre>"},{"location":"concepts/images/#image-formats","title":"Image Formats","text":"<p>Common formats:</p> <pre><code>// Color formats\nzest_format_r8g8b8a8_unorm      // 8-bit RGBA, normalized\nzest_format_r8g8b8a8_srgb       // 8-bit RGBA, sRGB\nzest_format_r16g16b16a16_sfloat // 16-bit float RGBA (HDR)\nzest_format_r32g32b32a32_sfloat // 32-bit float RGBA\n\n// Depth formats\nzest_format_d32_sfloat          // 32-bit depth\nzest_format_d24_unorm_s8_uint   // 24-bit depth + 8-bit stencil\n\n// Compressed formats\nzest_format_bc1_rgb_unorm       // BC1 (DXT1)\nzest_format_bc3_unorm           // BC3 (DXT5)\nzest_format_bc7_unorm           // BC7 (high quality)\n</code></pre>"},{"location":"concepts/images/#samplers","title":"Samplers","text":"<p>Samplers define how textures are filtered and addressed.</p>"},{"location":"concepts/images/#creating-samplers","title":"Creating Samplers","text":"<pre><code>zest_sampler_info_t info = zest_CreateSamplerInfo();\nzest_sampler_handle sampler = zest_CreateSampler(context, &amp;info);\n</code></pre>"},{"location":"concepts/images/#sampler-options","title":"Sampler Options","text":"<pre><code>zest_sampler_info_t info = zest_CreateSamplerInfo();\n\n// Filtering\ninfo.min_filter = zest_filter_linear;\ninfo.mag_filter = zest_filter_linear;\ninfo.mipmap_mode = zest_mipmap_mode_linear;\n\n// Address mode\ninfo.address_mode_u = zest_sampler_address_mode_repeat;\ninfo.address_mode_v = zest_sampler_address_mode_repeat;\ninfo.address_mode_w = zest_sampler_address_mode_clamp_to_edge;\n\n// Anisotropic filtering (reduces blur on surfaces viewed at angles)\ninfo.anisotropy_enable = ZEST_TRUE;\ninfo.max_anisotropy = 16.0f;\n</code></pre>"},{"location":"concepts/images/#bindless-access","title":"Bindless Access","text":"<p>Zest uses bindless descriptors to access images in shaders. Instead of binding individual textures to specific slots, all textures are stored in global descriptor arrays and accessed by index. This allows shaders to use any texture without rebinding, enabling efficient batching and dynamic material systems.</p> <p>The following functions apply to persistant images that were created outside of a frame graph. Transient images acquire indexes with different functions as they will get automatically released at the end of each frame.</p>"},{"location":"concepts/images/#acquiring-indices","title":"Acquiring Indices","text":"<pre><code>// Get image and sampler\nzest_image image = zest_GetImage(image_handle);\nzest_sampler sampler = zest_GetSampler(sampler_handle);\n\n// Acquire bindless indices\nzest_uint tex_index = zest_AcquireSampledImageIndex(device, image, zest_texture_2d_binding);\nzest_uint sampler_index = zest_AcquireSamplerIndex(device, sampler);\n</code></pre>"},{"location":"concepts/images/#using-in-shaders","title":"Using in Shaders","text":"<pre><code>// Descriptor arrays\nlayout(set = 0, binding = 0) uniform sampler samplers[];\nlayout(set = 0, binding = 1) uniform texture2D textures[];\n\n// Sample using indices from push constants\nvoid main() {\n    vec4 color = texture(\n        sampler2D(textures[push.tex_index], samplers[push.sampler_index]),\n        uv\n    );\n}\n</code></pre>"},{"location":"concepts/images/#releasing-indices","title":"Releasing Indices","text":"<pre><code>// When image is no longer needed, release its bindless index\nzest_ReleaseImageIndex(device, image, zest_texture_2d_binding);\n\n// To release all bindless indices for an image at once\nzest_ReleaseAllImageIndexes(device, image);\n</code></pre> <p>Note: When you call zest_FreeImage or zest_FreeImageNow any indexes that the image acquired will be released so you only need to call the functions above if you want to keep the image but no longer need to sample it in the shader.</p>"},{"location":"concepts/images/#image-views","title":"Image Views","text":"<p>Image views provide a way to access a subset of an image's data. While an image might contain multiple mip levels or array layers, a view can expose just a portion of that data to shaders or as an attachment. This is useful for mipmap generation, cubemap face access, or array texture slicing.</p> <p>When an image is created it is automatically set up with a default view, but you can create other views if you have more specific needs.</p> <pre><code>// Create view info (defaults to all mips and layers)\nzest_image_view_create_info_t view_info = zest_CreateViewImageInfo(image);\n\n// Customize for specific mip range\nview_info.base_mip_level = 0;\nview_info.level_count = 1;  // Single mip\n\n// Create the view\nzest_image_view_handle view_handle = zest_CreateImageView(device, image, &amp;view_info);\nzest_image_view view = zest_GetImageView(view_handle);\n\n// Create views for all mips (one view per mip level)\nzest_image_view_array_handle views_handle = zest_CreateImageViewsPerMip(device, image);\nzest_image_view_array views = zest_GetImageViewArray(views_handle);\nzest_uint mip_count = image-&gt;info.mip_levels;\n\n// Free views\nzest_FreeImageView(view_handle);\nzest_FreeImageViewArray(views_handle);\n</code></pre>"},{"location":"concepts/images/#render-targets","title":"Render Targets","text":""},{"location":"concepts/images/#creating-render-targets","title":"Creating Render Targets","text":"<pre><code>zest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.format = zest_format_r16g16b16a16_sfloat;\ninfo.flags = zest_image_preset_color_attachment;\n\nzest_image_handle render_target = zest_CreateImage(device, &amp;info);\n</code></pre>"},{"location":"concepts/images/#transient-render-targets","title":"Transient Render Targets","text":"<p>For intermediate targets that only exist within a single frame, use the frame graph's transient resource system. These resources are automatically created and destroyed as needed:</p> <pre><code>zest_image_resource_info_t info = {\n    .format = zest_format_r16g16b16a16_sfloat,\n    .usage_hints = zest_resource_usage_hint_none,  // Frame graph infers usage\n    .width = screen_width,   // 0 defaults to screen width\n    .height = screen_height, // 0 defaults to screen height\n    .mip_levels = 1\n};\nzest_resource_node hdr_target = zest_AddTransientImageResource(\"HDR\", &amp;info);\n</code></pre>"},{"location":"concepts/images/#depth-buffers","title":"Depth Buffers","text":"<pre><code>zest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.format = zest_format_d32_sfloat;\ninfo.flags = zest_image_preset_depth_attachment;\n\nzest_image_handle depth = zest_CreateImage(device, &amp;info);\n</code></pre>"},{"location":"concepts/images/#loading-ktx-textures","title":"Loading KTX Textures","text":"<p>Using the optional zest_utilities.h:</p> <pre><code>#include &lt;zest_utilities.h&gt;\n\nzest_image_handle texture = zest_LoadKTX(device, \"my_texture\", \"path/to/texture.ktx\");\n</code></pre> <p>KTX format supports:</p> <ul> <li>Mipmaps</li> <li>Cubemaps</li> <li>Compressed formats</li> <li>Array textures</li> </ul>"},{"location":"concepts/images/#image-operations","title":"Image Operations","text":"<p>Zest provides two ways to perform image operations: - Immediate mode (<code>zest_imm_*</code>): One-off operations that block until complete. Useful for initialization and loading. - Frame graph commands (<code>zest_cmd_*</code>): Operations within render/compute passes. Automatically synchronized by the frame graph.</p>"},{"location":"concepts/images/#blit-between-images","title":"Blit Between Images","text":"<p>Use immediate mode commands for one-off operations outside the frame graph:</p> <pre><code>zest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_BlitImage(queue, src_image, dst_image,\n    0, 0, src_width, src_height,    // Source region\n    0, 0, dst_width, dst_height,    // Destination region\n    zest_filter_linear);\nzest_imm_EndCommandBuffer(queue);\n</code></pre>"},{"location":"concepts/images/#generate-mipmaps","title":"Generate Mipmaps","text":"<pre><code>zest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_imm_GenerateMipMaps(queue, image);\nzest_imm_EndCommandBuffer(queue);\n</code></pre>"},{"location":"concepts/images/#clear-image","title":"Clear Image","text":"<p>Within a frame graph callback:</p> <pre><code>void ClearCallback(zest_command_list cmd, void* data) {\n    zest_cmd_ImageClear(cmd, image);\n}\n</code></pre> <p>For immediate mode clearing with specific values:</p> <pre><code>zest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_graphics);\nzest_clear_value_t clear = { .color = {0.0f, 0.0f, 0.0f, 1.0f} };\nzest_imm_ClearColorImage(queue, image, clear);\nzest_imm_EndCommandBuffer(queue);\n</code></pre>"},{"location":"concepts/images/#blit-mip-level-frame-graph","title":"Blit Mip Level (Frame Graph)","text":"<p>Within a frame graph, blit from one mip level to another:</p> <pre><code>void BlitCallback(zest_command_list cmd, void* data) {\n    zest_cmd_BlitImageMip(cmd, src_resource, dst_resource, mip_to_blit,\n        zest_pipeline_stage_fragment_shader_bit);\n}\n</code></pre>"},{"location":"concepts/images/#freeing-images","title":"Freeing Images","text":"<p>Images should be freed when no longer needed. Use deferred destruction to ensure the GPU has finished using the resource:</p> <pre><code>// Deferred free (safe - waits for GPU to finish)\nzest_FreeImage(image_handle);\n\n// Immediate free (only use when you've ensured GPU is done)\nzest_FreeImageNow(image_handle);\n</code></pre>"},{"location":"concepts/images/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate formats - sRGB for color textures, linear for data</li> <li>Generate mipmaps - For textures viewed at varying distances</li> <li>Use compressed formats - BC7 for quality, BC1 for small size, not essential but if you're using a lot of texture memory then well worth it.</li> <li>Prefer transient images - For intermediate render targets</li> </ol>"},{"location":"concepts/images/#see-also","title":"See Also","text":"<ul> <li>Bindless Descriptors - Descriptor system details</li> <li>Image API - Complete function reference</li> <li>Textures Tutorial - Loading and using textures</li> </ul>"},{"location":"concepts/layers/","title":"Layers","text":"<p>Layers are Zest's high-level rendering abstraction for batched and instanced drawing. They handle buffer management, instance data, and draw call organization.</p>"},{"location":"concepts/layers/#layer-types","title":"Layer Types","text":"Layer Type Use Case Key Feature Instance Layer 2D sprites, billboards Per-instance data array Mesh Layer ImGui, custom meshes Dynamic vertex/index buffers Instance Mesh Layer 3D models, instancing Meshes + per-instance data Font Layer Text rendering MSDF font integration"},{"location":"concepts/layers/#instance-layers","title":"Instance Layers","text":"<p>For rendering many similar objects with per-instance data (sprites, particles, billboards).</p>"},{"location":"concepts/layers/#creating-an-instance-layer","title":"Creating an Instance Layer","text":"<pre><code>zest_layer_handle layer = zest_CreateInstanceLayer(\n    context,\n    \"sprites\",\n    sizeof(sprite_instance_t),  // Per-instance data size\n    MAX_INSTANCES\n);\n</code></pre>"},{"location":"concepts/layers/#instance-data-structure","title":"Instance Data Structure","text":"<pre><code>struct sprite_instance_t {\n    zest_vec3 position;\n    zest_vec2 scale;\n    float rotation;\n    zest_uint texture_index;\n    zest_color_t color;\n};\n</code></pre>"},{"location":"concepts/layers/#adding-instances","title":"Adding Instances","text":"<pre><code>zest_layer layer = zest_GetLayer(layer_handle);\n\n// Start recording instances\nzest_StartInstanceInstructions(layer);\n\n// Add instances - zest_NextInstance returns pointer to next slot\nfor (int i = 0; i &lt; sprite_count; i++) {\n    sprite_instance_t* inst = (sprite_instance_t*)zest_NextInstance(layer);\n    inst-&gt;position = sprites[i].pos;\n    inst-&gt;scale = sprites[i].size;\n    inst-&gt;rotation = sprites[i].angle;\n    inst-&gt;texture_index = sprites[i].tex;\n    inst-&gt;color = sprites[i].color;\n}\n\n// End recording (optional: is also ended in the next call to zest_StartInstanceInstructions\nzest_EndInstanceInstructions(layer);\n</code></pre>"},{"location":"concepts/layers/#drawing-instances","title":"Drawing Instances","text":"<p>Use <code>zest_DrawInstanceLayer</code> as a pass task callback:</p> <pre><code>// Set up the render pass with the built-in draw function\nzest_BeginRenderPass(\"Draw Sprites\"); {\n    zest_ConnectSwapChainOutput();\n    zest_SetPassTask(zest_DrawInstanceLayer, layer);  // Pass layer as user_data\n    zest_EndPass();\n}\n</code></pre> <p>Or implement a custom draw callback:</p> <pre><code>void RenderCallback(zest_command_list cmd, void* data) {\n    zest_layer layer = (zest_layer)data;\n\n    // Get instance count\n    zest_uint count = zest_GetInstanceLayerCount(layer);\n    if (count == 0) return;\n\n    // Bind pipeline and draw\n    zest_pipeline pipeline = zest_GetPipeline(sprite_pipeline, cmd);\n    zest_cmd_BindPipeline(cmd, pipeline);\n\n    // Custom drawing logic here...\n}\n</code></pre>"},{"location":"concepts/layers/#mesh-layers","title":"Mesh Layers","text":"<p>For dynamic geometry with arbitrary vertex/index data (UI, procedural meshes).</p>"},{"location":"concepts/layers/#creating-a-mesh-layer","title":"Creating a Mesh Layer","text":"<pre><code>zest_layer_handle layer = zest_CreateMeshLayer(\n    context,\n    \"ui_mesh\",\n    sizeof(ui_vertex_t)   // Vertex size\n);\n</code></pre>"},{"location":"concepts/layers/#adding-mesh-data","title":"Adding Mesh Data","text":"<pre><code>zest_layer layer = zest_GetLayer(layer_handle);\n\n// Get write buffers (returns zest_buffer, use zest_BufferData to get pointer)\nzest_buffer vertex_buffer = zest_GetVertexWriteBuffer(layer);\nzest_buffer index_buffer = zest_GetIndexWriteBuffer(layer);\n\nui_vertex_t* vertices = (ui_vertex_t*)zest_BufferData(vertex_buffer);\nzest_uint* indices = (zest_uint*)zest_BufferData(index_buffer);\n\n// Write vertex data\nvertices[0] = (ui_vertex_t){.pos = {0, 0}, .uv = {0, 0}, .color = WHITE};\nvertices[1] = (ui_vertex_t){.pos = {100, 0}, .uv = {1, 0}, .color = WHITE};\n// ...\n\n// Write index data\nindices[0] = 0; indices[1] = 1; indices[2] = 2;\n// ...\n\n// Set mesh drawing mode with pipeline\nzest_SetMeshDrawing(layer, mesh_pipeline);\n</code></pre>"},{"location":"concepts/layers/#instance-mesh-layers","title":"Instance Mesh Layers","text":"<p>Combines pre-loaded meshes with per-instance data. Ideal for 3D instanced rendering.</p>"},{"location":"concepts/layers/#creating-an-instance-mesh-layer","title":"Creating an Instance Mesh Layer","text":"<pre><code>zest_layer_handle layer = zest_CreateInstanceMeshLayer(\n    context,\n    \"3d_objects\",\n    sizeof(mesh_instance_t),  // Per-instance data size\n    MAX_VERTICES,             // Total vertex capacity\n    MAX_INDICES               // Total index capacity\n);\n</code></pre>"},{"location":"concepts/layers/#loading-meshes","title":"Loading Meshes","text":"<pre><code>zest_layer layer = zest_GetLayer(layer_handle);\n\n// Load mesh data (from file, GLTF, etc.)\nmesh_data_t mesh = load_mesh(\"model.gltf\");\n\n// Add mesh to layer\nzest_uint mesh_index = zest_AddMeshToLayer(layer, &amp;mesh, texture_index);\n</code></pre>"},{"location":"concepts/layers/#using-zest-mesh-api","title":"Using Zest Mesh API","text":"<pre><code>// Create a mesh (returns zest_mesh directly, not a handle)\nzest_mesh mesh = zest_NewMesh(context, sizeof(vertex_t));\n\n// Reserve space\nzest_ReserveMeshVertices(mesh, vertex_count);\n\n// Add vertices - zest_NextMeshVertex takes current pointer and returns the next\nvoid* current = NULL;\nfor (int i = 0; i &lt; vertex_count; i++) {\n    vertex_t* v = (vertex_t*)zest_NextMeshVertex(mesh, current);\n    v-&gt;position = positions[i];\n    v-&gt;normal = normals[i];\n    v-&gt;uv = uvs[i];\n    current = v;\n}\n\n// Copy index data\nzest_CopyMeshIndexData(mesh, indices, index_count);\n\n// Add to layer\nzest_uint mesh_id = zest_AddMeshToLayer(layer, mesh, texture_index);\n\n// Free mesh (data is now copied to layer)\nzest_FreeMesh(mesh);\n</code></pre>"},{"location":"concepts/layers/#drawing-instance-mesh-layer","title":"Drawing Instance Mesh Layer","text":"<pre><code>void RenderCallback(zest_command_list cmd, void* data) {\n    app_t* app = (app_t*)data;\n    zest_layer layer = zest_GetLayer(app-&gt;mesh_layer);\n\n    // Bind mesh vertex/index buffers\n\n    zest_cmd_BindMeshVertexBuffer(command_list, layer);\n    zest_cmd_BindMeshIndexBuffer(command_list, layer);\n\n    zest_buffer device_buffer = zest_GetLayerResourceBuffer(layer);\n    zest_cmd_BindVertexBuffer(command_list, 1, 1, device_buffer);\n\n    zest_pipeline pipeline = zest_GetPipeline(app-&gt;mesh_pipeline, command_list);\n\n    zest_uint instruction_count = zest_GetLayerInstructionCount(layer);\n    for(int i = 0; i != instruction_count; i++) {\n        const zest_layer_instruction_t *current = zest_GetLayerInstruction(layer, i);\n        const zest_mesh_offset_data_t *mesh_offsets = zest_GetLayerMeshOffsets(layer, current-&gt;mesh_index);\n\n        zest_cmd_LayerViewport(command_list, layer);\n        zest_cmd_BindPipeline(command_list, pipeline);\n\n        scene_push_constants_t *push = (scene_push_constants_t*)current-&gt;push_constant;\n        push-&gt;shadow_index = shadow_index;\n        zest_cmd_SendPushConstants(command_list, (void*)push, sizeof(scene_push_constants_t));\n\n        zest_cmd_DrawIndexed(command_list, mesh_offsets-&gt;index_count, current-&gt;total_instances, mesh_offsets-&gt;index_offset, mesh_offsets-&gt;vertex_offset, current-&gt;start_index);\n    }\n}\n</code></pre>"},{"location":"concepts/layers/#layer-properties","title":"Layer Properties","text":""},{"location":"concepts/layers/#viewport-and-scissor","title":"Viewport and Scissor","text":"<pre><code>// Set viewport with full control\nzest_SetLayerViewPort(\n    layer,\n    0, 0,                    // x, y offset\n    scissor_width, scissor_height,\n    viewport_width, viewport_height\n);\n\n// Set scissor rect\nzest_SetLayerScissor(layer, offset_x, offset_y, width, height);\n\n// Match swapchain size (convenience)\nzest_SetLayerSizeToSwapchain(layer);\n\n// Set specific size\nzest_SetLayerSize(layer, width, height);\n</code></pre>"},{"location":"concepts/layers/#colors","title":"Colors","text":"<p>These properties are a way that you can store a color in a layer and use it to tint or color instances.</p> <pre><code>// Set RGBA (0-255)\nzest_SetLayerColor(layer, 255, 255, 255, 255);\n\n// Set RGBA (0.0-1.0)\nzest_SetLayerColorf(layer, 1.0f, 1.0f, 1.0f, 1.0f);\n\n// Intensity multiplier\nzest_SetLayerIntensity(layer, 1.5f);\n</code></pre>"},{"location":"concepts/layers/#user-data","title":"User Data","text":"<pre><code>zest_SetLayerUserData(layer, my_data);\nAppData *data = (AppData*)zest_GetLayerUserData(layer);\n</code></pre>"},{"location":"concepts/layers/#push-constants","title":"Push Constants","text":"<p>Pass data to shaders via push constants:</p> <pre><code>// Define push constant struct\nstruct push_constants_t {\n    zest_matrix4 view_projection;\n    zest_uint texture_index;\n};\n\n// Set push constants for layer\npush_constants_t push = {...};\nzest_SetLayerPushConstants(layer, &amp;push, sizeof(push));\n\n// In render callback\nvoid RenderCallback(zest_command_list cmd, void* data) {\n    zest_layer layer = zest_GetLayer(layer_handle);\n    push_constants_t* push = (push_constants_t*)zest_GetLayerPushConstants(layer);\n\n    // Modify if needed\n    push-&gt;view_projection = camera.vp;\n\n    // Send to shader\n    zest_cmd_SendPushConstants(cmd, push, sizeof(*push));\n}\n</code></pre>"},{"location":"concepts/layers/#uploading-layer-data","title":"Uploading Layer Data","text":"<p>Layer data must be uploaded to GPU before rendering:</p> <pre><code>// In transfer pass - use built-in upload function as callback\nzest_BeginTransferPass(\"Upload Layers\"); {\n    zest_SetPassTask(zest_UploadInstanceLayerData, layer);  // Pass layer as user_data\n    zest_EndPass();\n}\n</code></pre> <p>Or implement a custom upload callback:</p> <pre><code>void UploadCallback(zest_command_list cmd, void* data) {\n    zest_layer layer = (zest_layer)data;\n    zest_UploadLayerStagingData(layer, cmd);\n}\n</code></pre>"},{"location":"concepts/layers/#resetting-layers","title":"Resetting Layers","text":"<p>Clear instance data for next frame:</p> <pre><code>zest_layer layer = zest_GetLayer(layer_handle);\n\n// Reset layer to the next frame in flight\nzest_ResetLayer(layer);\n\n// Same as ResetLayer but specifically for an instance layer with manual frame in flight control\nzest_ResetInstanceLayer(layer);\n\n// Reset instance drawing state only. This is called automatically when you call \n// zest_StartInstanceDrawing or zest_StartInstanceMeshDrawing in a new frame\nzest_ResetInstanceLayerDrawing(layer);\n</code></pre>"},{"location":"concepts/layers/#best-practices","title":"Best Practices","text":"<ol> <li>Choose the right layer type - Instance for sprites, Mesh for UI or static meshes, Instance Mesh for 3D</li> <li>Batch by texture - Minimize texture switches within a layer</li> <li>Upload before rendering - Use transfer pass to upload layer data</li> <li>Size appropriately - Set max instances/vertices based on expected usage</li> </ol>"},{"location":"concepts/layers/#see-also","title":"See Also","text":"<ul> <li>Instancing Tutorial - Complete instancing example</li> <li>Layer API - Complete function reference</li> <li>Pipelines - Pipeline configuration for layers</li> </ul>"},{"location":"concepts/memory/","title":"Memory Management","text":"<p>Zest uses a TLSF (Two-Level Segregated Fit) allocator for both CPU and GPU memory. This provides fast, fragmentation-resistant allocation.</p>"},{"location":"concepts/memory/#tlsf-allocator","title":"TLSF Allocator","text":""},{"location":"concepts/memory/#properties","title":"Properties","text":"<ul> <li>O(1) allocation and free - Constant time operations</li> <li>Low fragmentation - Two-level segregation minimizes waste</li> <li>Bounded overhead - Predictable memory usage</li> <li>Thread-safe - Safe for multi-threaded use</li> </ul>"},{"location":"concepts/memory/#how-it-works","title":"How It Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   TLSF Pool                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  First Level: Size classes (powers of 2)        \u2502\n\u2502  \u251c\u2500\u2500 64 KB                                      \u2502\n\u2502  \u251c\u2500\u2500 128 KB                                     \u2502\n\u2502  \u251c\u2500\u2500 256 KB                                     \u2502\n\u2502  \u2514\u2500\u2500 ...                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Second Level: Subdivisions within each class   \u2502\n\u2502  \u251c\u2500\u2500 64-80 KB                                   \u2502\n\u2502  \u251c\u2500\u2500 80-96 KB                                   \u2502\n\u2502  \u251c\u2500\u2500 96-112 KB                                  \u2502\n\u2502  \u2514\u2500\u2500 ...                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/memory/#memory-pools","title":"Memory Pools","text":"<p>Zest organizes GPU memory into pools:</p> Pool Default Size Contents Device Buffer Pool 64 MB GPU-only vertex, index, storage buffers Small Buffer Pool 4 MB GPU-only vertex, index, storage buffers for small buffers Staging Buffer Pool 32 MB CPU-visible upload buffers Small Staging Buffer Pool 4 MB Small CPU-visible upload buffers Transient Image Memory Pool 64 MB Transient textures and render targets used in frame graphs Transient Buffer Memory Pool 32 MB Transient buffers used in frame graphs Small Transient Buffer Memory Pool 4 MB Small Transient buffers used in frame graphs"},{"location":"concepts/memory/#image-memory","title":"Image Memory","text":"<p>Unlike buffers, non-transient images allocate memory directly rather than from pools. This is because images have highly varied requirements (format, dimensions, mip levels, array layers, sample counts) that would require many specialized pools, adding complexity without significant benefit.</p> <p>Transient images (created via <code>zest_AddTransientImageResource</code>) do use pooled memory, since the frame graph compiler can efficiently manage and alias their memory and the requirements are less veried.</p> <p>For optimal memory usage with many small textures:</p> <ul> <li>Use texture arrays - Store multiple textures in array layers of a single image</li> <li>Use image atlases - Pack multiple sprites/textures into a single large image</li> <li>Use bindless indexing - Reference textures by descriptor index in shaders</li> </ul> <pre><code>// Instead of many small individual images (each allocates separately),\n// prefer texture arrays or atlases:\n\nzest_image_info_t info = zest_CreateImageInfo(256, 256);\ninfo.format = zest_format_r8g8b8a8_unorm;\ninfo.layer_count = 64;  // Store 64 textures in one allocation\nzest_image_handle texture_array = zest_CreateImage(device, &amp;info);\n</code></pre>"},{"location":"concepts/memory/#configuring-pool-sizes","title":"Configuring Pool Sizes","text":"<p>Configure after creating the device but before creating buffers:</p> <pre><code>// Set pool sizes (minimum allocation size, pool size in bytes)\nzest_SetGPUBufferPoolSize(device, 1024, 64 * 1024 * 1024);      // 64 MB GPU buffer pool for large pools\nzest_SetStagingBufferPoolSize(device, 1024, 32 * 1024 * 1024);  // 32 MB staging pool for large pools\n\n### Auto-Expansion\n\nPools automatically expand when exhausted by adding additional pools. If the requested allocation is larger then the pool size then the pool allocation size will be the next power of 2 from the requested allocaiton size.\n\n```cpp\nzest_buffer_info_t info = zest_CreateBufferInfo(zest_buffer_type_storage, zest_memory_usage_gpu_only);\n\n// Initial allocation succeeds\nzest_buffer buf1 = zest_CreateBuffer(device, 32 * 1024 * 1024, &amp;info);\n\n// Pool expands if needed\nzest_buffer buf2 = zest_CreateBuffer(device, 64 * 1024 * 1024, &amp;info);\n</code></pre>"},{"location":"concepts/memory/#linear-allocators","title":"Linear Allocators","text":"<p>For frame-lifetime allocations, contexts use linear allocators internally. These are used automatically by the frame graph system for building the frame graph and means that the frame graph can be cached instantly by simply promoting the used linear memory to persistant memory.  </p> <p>Benefits:</p> <ul> <li>Extremely fast - Just bump a pointer</li> <li>Zero fragmentation - Entire pool reset at once</li> <li>Cache-friendly - Sequential allocations</li> <li>Can be cached instantly - The linear memory that was used is simply promoted to persistant memory.</li> </ul>"},{"location":"concepts/memory/#memory-types","title":"Memory Types","text":""},{"location":"concepts/memory/#gpu-only-memory","title":"GPU-Only Memory","text":"<p>Fastest for GPU access, no CPU access:</p> <pre><code>zest_buffer_info_t info = zest_CreateBufferInfo(\n    zest_buffer_type_vertex,\n    zest_memory_usage_gpu_only\n);\n</code></pre> <p>Use for:</p> <ul> <li>Vertex buffers</li> <li>Index buffers</li> <li>Textures</li> <li>Render targets</li> </ul>"},{"location":"concepts/memory/#cpu-to-gpu-memory","title":"CPU-to-GPU Memory","text":"<p>CPU can write, GPU can read. Used for uploads:</p> <pre><code>zest_buffer_info_t info = zest_CreateBufferInfo(\n    zest_buffer_type_uniform,\n    zest_memory_usage_cpu_to_gpu\n);\n</code></pre> <p>Use for:</p> <ul> <li>Uniform buffers (updated every frame)</li> <li>Staging buffers for uploads</li> </ul>"},{"location":"concepts/memory/#gpu-to-cpu-memory","title":"GPU-to-CPU Memory","text":"<p>GPU can write, CPU can read. Used for readback:</p> <pre><code>zest_buffer_info_t info = zest_CreateBufferInfo(\n    zest_buffer_type_storage,\n    zest_memory_usage_gpu_to_cpu\n);\n</code></pre> <p>Use for:</p> <ul> <li>Readback buffers</li> <li>GPU compute results that need CPU access</li> </ul>"},{"location":"concepts/memory/#transient-resources","title":"Transient Resources","text":"<p>Resources that only exist within a frame graph execution:</p> <pre><code>zest_image_resource_info_t info = {\n    .format = zest_format_r16g16b16a16_sfloat,\n    .usage_hints = zest_resource_usage_hint_none,  // Set as needed\n    .width = 1920,\n    .height = 1080,\n    .mip_levels = 1,\n    .layer_count = 1\n};\nzest_resource_node target = zest_AddTransientImageResource(\"HDR\", &amp;info);\n</code></pre>"},{"location":"concepts/memory/#memory-aliasing","title":"Memory Aliasing","text":"<p>Transient resources can share memory when their lifetimes don't overlap:</p> <pre><code>Pass 1: Write \u2192 Target A\nPass 2: Read Target A, Write \u2192 Target B\nPass 3: Read Target B, Write \u2192 Target C\nPass 3: Read Target C\n\nTarget A and Target C can share the same memory!\n</code></pre> <p>The frame graph compiler automatically handles aliasing.</p>"},{"location":"concepts/memory/#deferred-destruction","title":"Deferred Destruction","text":"<p>Resources are destroyed when safe (after GPU finishes):</p> <pre><code>// Mark for destruction (safe, deferred until GPU is done)\nzest_FreeBuffer(buffer);\nzest_FreeImage(image_handle);\n</code></pre> <p>For immediate destruction (ensure GPU is idle first):</p> <pre><code>zest_WaitForIdleDevice(device);\nzest_FreeImageNow(image_handle);\nzest_FreeImageViewNow(view_handle);\n</code></pre> <p>Note: Buffer destruction is always deferred through <code>zest_FreeBuffer()</code>. </p>"},{"location":"concepts/memory/#memory-statistics","title":"Memory Statistics","text":"<p>Query memory usage:</p> <pre><code>// Host memory stats (from TLSF allocator)\n// This is memory stored CPU side for everything the API allocates\nzloc_allocation_stats_t device_stats = zest_GetDeviceMemoryStats(device);\nprintf(\"Capacity: %zu bytes\\n\", device_stats.capacity);\nprintf(\"Free: %zu bytes\\n\", device_stats.free);\nprintf(\"Used: %zu bytes\\n\", device_stats.capacity - device_stats.free);\nprintf(\"Blocks in use: %d\\n\", device_stats.blocks_in_use);\n\n// Context memory stats\nzloc_allocation_stats_t context_stats = zest_GetContextMemoryStats(context);\n\n// Print detailed memory report\nzest_OutputMemoryUsage(context);\n</code></pre>"},{"location":"concepts/memory/#memory-debugging","title":"Memory Debugging","text":""},{"location":"concepts/memory/#enable-memory-tracking","title":"Enable Memory Tracking","text":"<pre><code>// Set error log path for memory warnings\nzest_SetErrorLogPath(device, \"memory_log.txt\");\n\n// Print reports for a context. Can be useful to use after zest_EndFrameGraph to print any errors.\n// Reports are also printed when the device is destroyed.\nzest_PrintReports(context);\n</code></pre>"},{"location":"concepts/memory/#common-issues","title":"Common Issues","text":"<p>Leaks:</p> <pre><code>Symptom: Memory usage grows over time\nSolution: Ensure all resources are freed, check zest_OutputMemoryUsage(). When the device is destroyed it will check for any blocks of memory that have not been freed and alert you that there maybe a potential memory leak.\n</code></pre>"},{"location":"concepts/memory/#best-practices","title":"Best Practices","text":"<ol> <li>Size pools for your use case - Larger pools = fewer reallocations</li> <li>Use transient resources - For intermediate render targets</li> <li>Prefer GPU-only memory - For static resources</li> <li>Batch uploads - Minimize staging buffer churn</li> <li>Monitor memory usage - Use <code>zest_OutputMemoryUsage()</code> during development or check for leak reports when the device is destroyed.</li> </ol>"},{"location":"concepts/memory/#example-memory-efficient-rendering","title":"Example: Memory-Efficient Rendering","text":"<pre><code>// Configure pools based on expected usage (minimum size, pool size)\nzest_SetGPUBufferPoolSize(device, 1024, 256 * 1024 * 1024);    // 256 MB for large scenes\nzest_SetStagingBufferPoolSize(device, 1024, 64 * 1024 * 1024); // 64 MB for streaming\n\n// Use transient resources for render targets\nzest_key key;\nif (zest_BeginFrameGraph(context, \"Renderer\", &amp;key)) {\n    // These share memory when possible\n    zest_resource_node gbuffer_albedo = zest_AddTransientImageResource(\"Albedo\", &amp;rt_info);\n    zest_resource_node gbuffer_normal = zest_AddTransientImageResource(\"Normal\", &amp;rt_info);\n    zest_resource_node gbuffer_depth = zest_AddTransientImageResource(\"Depth\", &amp;depth_info);\n\n    // ... passes ...\n\n    frame_graph = zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"concepts/memory/#see-also","title":"See Also","text":"<ul> <li>Buffers - Buffer creation and management</li> <li>Images - Image memory</li> <li>Frame Graph - Transient resources</li> </ul>"},{"location":"concepts/pipelines/","title":"Pipelines","text":"<p>Zest uses a pipeline template system. Instead of creating GPU pipelines directly, you configure templates that are compiled on-demand when first used. This deferred compilation approach simplifies pipeline management - you only need to specify what you want, and Zest handles the actual device pipeline creation and caching.</p>"},{"location":"concepts/pipelines/#pipeline-templates-vs-built-pipelines","title":"Pipeline Templates vs Built Pipelines","text":"Pipeline Template Built Pipeline Configuration only Actual GPU pipeline Stored in device Created per command list Reusable Cached internally Configured once Used for drawing <pre><code>// 1. Create template (once at startup)\nzest_pipeline_template my_template = zest_CreatePipelineTemplate(device, \"my_pipeline\");\n// ... configure ...\n\n// 2. Build pipeline (in render callback)\nzest_pipeline pipeline = zest_GetPipeline(my_template, cmd);\nzest_cmd_BindPipeline(cmd, pipeline);\n</code></pre>"},{"location":"concepts/pipelines/#creating-a-pipeline-template","title":"Creating a Pipeline Template","text":"<pre><code>zest_pipeline_template sprite_template = zest_CreatePipelineTemplate(device, \"sprite_pipeline\");\n\n// Set shaders\nzest_SetPipelineShaders(sprite_template, vertex_shader, fragment_shader);\n\n// Configure vertex input\nzest_AddVertexInputBindingDescription(sprite_template, 0, sizeof(vertex_t), zest_input_rate_vertex);\nzest_AddVertexAttribute(sprite_template, 0, 0, zest_format_r32g32b32_sfloat, offsetof(vertex_t, position));\nzest_AddVertexAttribute(sprite_template, 0, 1, zest_format_r32g32_sfloat, offsetof(vertex_t, uv));\nzest_AddVertexAttribute(sprite_template, 0, 2, zest_format_r8g8b8a8_unorm, offsetof(vertex_t, color));\n\n// Configure state\nzest_SetPipelineTopology(sprite_template, zest_topology_triangle_list);\nzest_SetPipelineCullMode(sprite_template, zest_cull_mode_none);\nzest_SetPipelineDepthTest(sprite_template, true, true);\nzest_SetPipelineBlend(sprite_template, zest_AlphaBlendState());\n</code></pre>"},{"location":"concepts/pipelines/#shaders","title":"Shaders","text":""},{"location":"concepts/pipelines/#creating-shaders","title":"Creating Shaders","text":"<pre><code>// From file (auto-compiles if needed)\nzest_shader_handle vert = zest_CreateShaderFromFile(\n    device,\n    \"shaders/sprite.vert\",    // Source file in GLSL \n    \"sprite.vert.spv\",        // Cache name\n    zest_vertex_shader,       // Shader type\n    false                     // Whether to disable caching (false = enable caching)\n);\n\n// From pre-compiled SPIR-V file\nzest_shader_handle frag = zest_CreateShaderFromSPVFile(\n    device,\n    \"shaders/sprite.frag.spv\",\n    zest_fragment_shader\n);\n\n// From SPIR-V in memory\nzest_shader_handle comp = zest_AddShaderFromSPVMemory(\n    device,\n    \"compute.spv\",            // Name\n    spirv_data,               // Buffer\n    spirv_size,               // Size\n    zest_compute_shader       // Shader type\n);\n</code></pre>"},{"location":"concepts/pipelines/#setting-shaders","title":"Setting Shaders","text":"<pre><code>// Graphics pipeline - both shaders at once\nzest_SetPipelineShaders(my_template, vertex_shader, fragment_shader);\n\n// Or set shaders separately\nzest_SetPipelineVertShader(my_template, vertex_shader);\nzest_SetPipelineFragShader(my_template, fragment_shader);\n\n// Combined vertex+fragment shader (single file containing both)\nzest_SetPipelineShader(my_template, combined_shader);\n</code></pre> <p>Note: Compute shaders are handled separately through <code>zest_CreateCompute()</code> rather than pipeline templates. See the Compute Pipelines section.</p>"},{"location":"concepts/pipelines/#vertex-input","title":"Vertex Input","text":"<p>Vertex input describes how vertex data is organized in memory and how it maps to shader inputs. A binding represents a buffer of vertex data, while attributes describe individual data fields within that buffer.</p>"},{"location":"concepts/pipelines/#binding-descriptions","title":"Binding Descriptions","text":"<pre><code>// Per-vertex data (binding 0)\nzest_AddVertexInputBindingDescription(\n    my_template,\n    0,                        // Binding index\n    sizeof(vertex_t),         // Stride\n    zest_input_rate_vertex    // Per vertex\n);\n\n// Per-instance data (binding 1)\nzest_AddVertexInputBindingDescription(\n    my_template,\n    1,\n    sizeof(instance_t),\n    zest_input_rate_instance  // Per instance\n);\n</code></pre>"},{"location":"concepts/pipelines/#attribute-descriptions","title":"Attribute Descriptions","text":"<pre><code>// Position at location 0\nzest_AddVertexAttribute(\n    my_template,\n    0,                              // Binding\n    0,                              // Location\n    zest_format_r32g32b32_sfloat,   // Format\n    offsetof(vertex_t, position)    // Offset\n);\n\n// UV at location 1\nzest_AddVertexAttribute(my_template, 0, 1, zest_format_r32g32_sfloat, offsetof(vertex_t, uv));\n\n// Color at location 2 (packed)\nzest_AddVertexAttribute(my_template, 0, 2, zest_format_r8g8b8a8_unorm, offsetof(vertex_t, color));\n</code></pre>"},{"location":"concepts/pipelines/#clearing-vertex-input","title":"Clearing Vertex Input","text":"<pre><code>zest_ClearVertexInputBindingDescriptions(my_template);\n</code></pre>"},{"location":"concepts/pipelines/#pipeline-state","title":"Pipeline State","text":""},{"location":"concepts/pipelines/#topology","title":"Topology","text":"<pre><code>zest_SetPipelineTopology(my_template, zest_topology_triangle_list);    // Default\nzest_SetPipelineTopology(my_template, zest_topology_triangle_strip);\nzest_SetPipelineTopology(my_template, zest_topology_line_list);\nzest_SetPipelineTopology(my_template, zest_topology_point_list);\n</code></pre>"},{"location":"concepts/pipelines/#culling","title":"Culling","text":"<pre><code>zest_SetPipelineCullMode(my_template, zest_cull_mode_back);   // Cull back faces\nzest_SetPipelineCullMode(my_template, zest_cull_mode_front);  // Cull front faces\nzest_SetPipelineCullMode(my_template, zest_cull_mode_none);   // No culling (Default)\n</code></pre>"},{"location":"concepts/pipelines/#front-face","title":"Front Face","text":"<pre><code>zest_SetPipelineFrontFace(my_template, zest_front_face_counter_clockwise);  // Default\nzest_SetPipelineFrontFace(my_template, zest_front_face_clockwise);\n</code></pre>"},{"location":"concepts/pipelines/#polygon-mode","title":"Polygon Mode","text":"<pre><code>zest_SetPipelinePolygonFillMode(my_template, zest_polygon_mode_fill);   // Solid (Default)\nzest_SetPipelinePolygonFillMode(my_template, zest_polygon_mode_line);   // Wireframe\nzest_SetPipelinePolygonFillMode(my_template, zest_polygon_mode_point);  // Points\n</code></pre>"},{"location":"concepts/pipelines/#depth-testing","title":"Depth Testing","text":"<pre><code>// Enable depth test and write\nzest_SetPipelineDepthTest(my_template, true, true);\n\n// Depth test only (no write)\nzest_SetPipelineDepthTest(my_template, true, false);\n\n// Disable depth\nzest_SetPipelineDepthTest(my_template, false, false);\n</code></pre>"},{"location":"concepts/pipelines/#blend-states","title":"Blend States","text":""},{"location":"concepts/pipelines/#built-in-blend-states","title":"Built-in Blend States","text":"<pre><code>zest_SetPipelineBlend(my_template, zest_BlendStateNone());       // No blending\nzest_SetPipelineBlend(my_template, zest_AlphaBlendState());      // Standard alpha\nzest_SetPipelineBlend(my_template, zest_AdditiveBlendState());   // Additive\nzest_SetPipelineBlend(my_template, zest_PreMultiplyBlendState()); // Pre-multiplied\nzest_SetPipelineBlend(my_template, zest_ImGuiBlendState());      // ImGui style\n</code></pre>"},{"location":"concepts/pipelines/#custom-blend-state","title":"Custom Blend State","text":"<pre><code>zest_color_blend_attachment_t blend = {\n    .blend_enable = ZEST_TRUE,\n    .src_color_blend_factor = zest_blend_factor_src_alpha,\n    .dst_color_blend_factor = zest_blend_factor_one_minus_src_alpha,\n    .color_blend_op = zest_blend_op_add,\n    .src_alpha_blend_factor = zest_blend_factor_one,\n    .dst_alpha_blend_factor = zest_blend_factor_one_minus_src_alpha,\n    .alpha_blend_op = zest_blend_op_add,\n    .color_write_mask = zest_color_component_r_bit | zest_color_component_g_bit |\n                        zest_color_component_b_bit | zest_color_component_a_bit\n};\nzest_SetPipelineBlend(my_template, blend);\n</code></pre>"},{"location":"concepts/pipelines/#copying-templates","title":"Copying Templates","text":"<p>Create variants from existing templates:</p> <pre><code>// Copy and modify\nzest_pipeline_template wireframe = zest_CopyPipelineTemplate(\"wireframe\", solid_template);\nzest_SetPipelinePolygonFillMode(wireframe, zest_polygon_mode_line);\n\n// Copy with different shaders\nzest_pipeline_template shadow = zest_CopyPipelineTemplate(\"shadow\", main_template);\nzest_SetPipelineShaders(shadow, shadow_vert, shadow_frag);\n</code></pre>"},{"location":"concepts/pipelines/#pipeline-layouts","title":"Pipeline Layouts","text":"<p>Pipeline layouts define the interface between shaders and descriptor sets (resources like buffers and textures). Zest provides a default bindless layout that works for most use cases. Custom layouts are not currently fully supported, although most of the API is there some of the internals need updating to allow it.</p> <pre><code>zest_pipeline_layout_info_t layout_info = zest_NewPipelineLayoutInfo(device);\nzest_AddPipelineLayoutDescriptorLayout(&amp;layout_info, my_descriptor_layout);\nzest_pipeline_layout layout = zest_CreatePipelineLayout(&amp;layout_info);\n</code></pre>"},{"location":"concepts/pipelines/#using-pipelines","title":"Using Pipelines","text":"<pre><code>void RenderCallback(const zest_command_list cmd, void* user_data) {\n    app_t* app = (app_t*)user_data;\n\n    // Build pipeline for this command list, once built the pipeline is cached and subsequent\n    // calls will retrieve the pipeline from the cache instead.\n    zest_pipeline pipeline = zest_GetPipeline(app-&gt;pipeline_template, cmd);\n\n    // Bind pipeline\n    zest_cmd_BindPipeline(cmd, pipeline);\n\n    // Set viewport/scissor (min_depth, max_depth)\n    zest_cmd_SetScreenSizedViewport(cmd, 0.0f, 1.0f);\n\n    // Draw...\n    zest_cmd_Draw(cmd, vertex_count, instance_count, 0, 0);\n}\n</code></pre>"},{"location":"concepts/pipelines/#compute-pipelines","title":"Compute Pipelines","text":"<pre><code>// Create compute shader\nzest_shader_handle comp = zest_CreateShaderFromFile(\n    device, \"compute.comp\", \"compute.spv\", zest_compute_shader, false);\n\n// Create compute handle\nzest_compute_handle compute = zest_CreateCompute(device, \"particle_sim\", comp);\n\n// Use in compute pass\nzest_compute compute_obj = zest_GetCompute(compute);\nzest_BeginComputePass(compute_obj, \"Simulate\"); {\n    zest_SetPassTask(ComputeCallback, app);\n    zest_EndPass();\n}\n</code></pre>"},{"location":"concepts/pipelines/#best-practices","title":"Best Practices","text":"<ol> <li>Create templates at startup - Not during rendering</li> <li>Use <code>zest_CopyPipelineTemplate</code> - For variants with minor differences</li> <li>Cache pipelines are automatic - <code>zest_GetPipeline</code> handles caching</li> <li>Match vertex input to shaders - Locations must align</li> </ol>"},{"location":"concepts/pipelines/#see-also","title":"See Also","text":"<ul> <li>Shaders Guide - Shader compilation details</li> <li>Pipeline API - Complete function reference</li> <li>Instancing Tutorial - Pipeline with instancing</li> </ul>"},{"location":"concepts/frame-graph/","title":"Frame Graph","text":"<p>The frame graph is Zest's core execution model. Instead of manually managing barriers, semaphores, and resource states, you declare a graph of render passes with their dependencies, and Zest handles the rest.</p>"},{"location":"concepts/frame-graph/#why-frame-graphs","title":"Why Frame Graphs?","text":"<p>Traditional Vulkan requires explicit synchronization:</p> <pre><code>// Manual barrier insertion\nvkCmdPipelineBarrier(cmd,\n    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,\n    0, 0, nullptr, 0, nullptr, 1, &amp;imageBarrier);\n\n// Explicit semaphore management\nVkSubmitInfo submit = {...};\nsubmit.waitSemaphoreCount = 1;\nsubmit.pWaitSemaphores = &amp;renderFinished;\n</code></pre> <p>This is error-prone and verbose. Frame graphs solve this by:</p> <ol> <li>Automatic barriers - Inserted based on resource usage</li> <li>Automatic synchronization - Semaphores between queues</li> <li>Pass culling - Unused passes are removed</li> <li>Resource aliasing - Transient resources can share memory</li> </ol>"},{"location":"concepts/frame-graph/#basic-structure","title":"Basic Structure","text":"<p>A frame graph is built by declaring resources and passes:</p> <pre><code>if (zest_BeginFrameGraph(context, \"My Graph\", &amp;cache_key)) {\n    // 1. Import external resources\n    zest_ImportSwapchainResource();\n\n    // 2. Create transient resources (optional)\n    zest_resource_node depth = zest_AddTransientImageResource(\"Depth\", &amp;depth_info);\n    zest_resource_node shadow_map = zest_AddTransientImageResource(\"Shadows\", &amp;shadow_info);\n\n    // 3. Define passes\n    zest_BeginRenderPass(\"Shadow Pass\"); {\n        zest_ConnectOutput(shadow_map);\n        zest_SetPassTask(RenderShadows, app);\n        zest_EndPass();\n    }\n\n    zest_BeginRenderPass(\"Main Pass\"); {\n        zest_ConnectInput(shadow_map);\n        zest_ConnectSwapChainOutput();\n        zest_ConnectOutput(depth);\n        zest_SetPassTask(RenderScene, app);\n        zest_EndPass();\n    }\n\n    // 4. Compile\n    frame_graph = zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"concepts/frame-graph/#pass-types","title":"Pass Types","text":"<p>Zest supports three types of passes:</p> Pass Type Function Use Case Render <code>zest_BeginRenderPass</code> Drawing with graphics pipelines Compute <code>zest_BeginComputePass</code> Compute shader dispatch Transfer <code>zest_BeginTransferPass</code> Data uploads and copies <p>See Passes for detailed documentation.</p>"},{"location":"concepts/frame-graph/#resource-types","title":"Resource Types","text":"<p>Resources flow through the graph as inputs and outputs:</p> Resource Type Description Swapchain The window's presentation surface Imported Existing images/buffers from outside the graph (only required to import if they require writing to or in an initial state that requires them to be transitioned with a barrier) Transient Frame-lifetime resources allocated by the graph <p>See Resources for detailed documentation.</p>"},{"location":"concepts/frame-graph/#topics","title":"Topics","text":"Page Description Passes Render, compute, and transfer passes Resources Importing, transient resources, and resource groups Execution Building, caching, and executing frame graphs Debugging Debug output and optimization flags"},{"location":"concepts/frame-graph/#example-deferred-renderer","title":"Example: Deferred Renderer","text":"<pre><code>if (zest_BeginFrameGraph(context, \"Deferred Renderer\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();\n\n    // Transient G-buffer\n    zest_resource_node albedo = zest_AddTransientImageResource(\"Albedo\", &amp;rgba_info);\n    zest_resource_node normal = zest_AddTransientImageResource(\"Normal\", &amp;rgba_info);\n    zest_resource_node depth = zest_AddTransientImageResource(\"Depth\", &amp;depth_info);\n\n    // Pass 1: G-Buffer\n    zest_BeginRenderPass(\"G-Buffer\"); {\n        zest_ConnectOutput(albedo);\n        zest_ConnectOutput(normal);\n        zest_ConnectOutput(depth);\n        zest_SetPassTask(RenderGBuffer, app);\n        zest_EndPass();\n    }\n\n    // Pass 2: Lighting\n    zest_BeginRenderPass(\"Lighting\"); {\n        zest_ConnectInput(albedo);\n        zest_ConnectInput(normal);\n        zest_ConnectInput(depth);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(RenderLighting, app);\n        zest_EndPass();\n    }\n\n    frame_graph = zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"concepts/frame-graph/#see-also","title":"See Also","text":"<ul> <li>First Application - Basic frame graph usage</li> <li>Multi-Pass Tutorial - Advanced frame graph patterns</li> <li>Frame Graph API - Complete function reference</li> </ul>"},{"location":"concepts/frame-graph/debugging/","title":"Debugging","text":"<p>This page covers tools for debugging and optimizing frame graphs.</p>"},{"location":"concepts/frame-graph/debugging/#printing-compiled-graphs","title":"Printing Compiled Graphs","text":"<p>Visualize the compiled frame graph structure:</p> <pre><code>zest_frame_graph graph = zest_EndFrameGraph();\nzest_PrintCompiledFrameGraph(graph);\n</code></pre> <p>Example output:</p> <pre><code>Swapchain Info\nImage Available Wait Semaphores:\n000002181325E9D0 *\n000002181325EA68\n\nRender Finished Signal Semaphores:\n000002181325EB00\n000002181325EB98 *\n000002181325EC30\n\n--- Frame graph Execution Plan, Current FIF: 0 ---\nResource List: Total Resources: 5\n\nBuffer: read particle buffer (0000021801EF0140) - Size: 8388608, Offset: 0\nSwapchain Image: Zest Window (000002181325D178)\nImage: Imgui Font (0000021801EDB578) - Size: 512 x 64\nBuffer: Viewport Vertex Buffer (0000000000000000) - Size: 5840, Offset: 0\nBuffer: Viewport Index Buffer (0000000000000000) - Size: 5840, Offset: 0\n\nGraph Wave Layout ([G]raphics, [C]ompute, [T]ransfer)\nWave Index      G       C       T       Pass Count\n0                       X       X       2\n1               X                       1\n\nNumber of Submission Batches: 2\n\nWave Submission Index 0:\n  Target Queue Family: Compute Queue - index: 1\n  Waits on the following Semaphores:\n     Timeline Semaphore: 0000021801EDB190, Value: 15307, Stages: COMPUTE_SHADER_BIT\n  Passes in this batch:\n    Pass [0] (QueueType: 2)\n       Compute Particles\n        Release Buffers:\n            read particle buffer (0000021801EF0140) |\n            Access: SHADER_WRITE_BIT -&gt; VERTEX_ATTRIBUTE_READ_BIT,\n            Pipeline Stage: COMPUTE_SHADER_BIT -&gt; BOTTOM_OF_PIPE_BIT,\n            QFI: 1 -&gt; 0, Size: 8388608\n  Signal Semaphores:\n  Timeline Semaphore: 00000218134146E0, Stage: BOTTOM_OF_PIPE_BIT, Value: 7654\n\n  Target Queue Family: Transfer Queue - index: 2\n  Waits on the following Semaphores:\n     Timeline Semaphore: 0000021801EDB190, Value: 15307, Stages: TRANSFER_BIT\n  Passes in this batch:\n    Pass [2] (QueueType: 4)\n       Upload ImGui Viewport\n        Release Buffers:\n            Viewport Vertex Buffer (0000000000000000) |\n            Access: TRANSFER_READ_BIT, TRANSFER_WRITE_BIT -&gt; VERTEX_ATTRIBUTE_READ_BIT,\n            Pipeline Stage: TRANSFER_BIT -&gt; BOTTOM_OF_PIPE_BIT,\n            QFI: 2 -&gt; 0, Size: 5840\n            Viewport Index Buffer (0000000000000000) |\n            Access: TRANSFER_READ_BIT, TRANSFER_WRITE_BIT -&gt; INDEX_READ_BIT, VERTEX_ATTRIBUTE_READ_BIT,\n            Pipeline Stage: TRANSFER_BIT -&gt; BOTTOM_OF_PIPE_BIT,\n            QFI: 2 -&gt; 0, Size: 5840\n  Signal Semaphores:\n  Timeline Semaphore: 0000021813414778, Stage: BOTTOM_OF_PIPE_BIT, Value: 7654\n\nWave Submission Index 1:\n  Target Queue Family: Graphics Queue - index: 0\n  Waits on the following Semaphores:\n     Timeline Semaphore: 00000218134146E0, Value: 7654, Stages: VERTEX_INPUT_BIT, COMPUTE_SHADER_BIT, TRANSFER_BIT\n     Timeline Semaphore: 0000021813414778, Value: 7654, Stages: VERTEX_INPUT_BIT, COMPUTE_SHADER_BIT, TRANSFER_BIT\n     Binary Semaphore:   000002181325EA68, Stages: TOP_OF_PIPE_BIT\n  Passes in this batch:\n    Pass [1] (QueueType: 1)\n       Graphics Pass\n       Dear ImGui Viewport Pass\n        Acquire Images:\n            Zest Window (000002181325D178), Layout: UNDEFINED -&gt; COLOR_ATTACHMENT_OPTIMAL,\n            Access: NONE -&gt; COLOR_ATTACHMENT_WRITE_BIT,\n            Pipeline Stage: TOP_OF_PIPE_BIT -&gt; COLOR_ATTACHMENT_OUTPUT_BIT,\n            QFI: 4294967295 -&gt; 4294967295\n        Acquire Buffers:\n            read particle buffer (0000021801EF0140) |\n            Access: SHADER_WRITE_BIT -&gt; VERTEX_ATTRIBUTE_READ_BIT,\n            Pipeline Stage: COMPUTE_SHADER_BIT -&gt; VERTEX_INPUT_BIT,\n            QFI: 1 -&gt; 0, Size: 8388608\n            Viewport Vertex Buffer (0000000000000000) |\n            Access: TRANSFER_READ_BIT, TRANSFER_WRITE_BIT -&gt; VERTEX_ATTRIBUTE_READ_BIT,\n            Pipeline Stage: TRANSFER_BIT -&gt; VERTEX_INPUT_BIT,\n            QFI: 2 -&gt; 0, Size: 5840\n            Viewport Index Buffer (0000000000000000) |\n            Access: TRANSFER_READ_BIT, TRANSFER_WRITE_BIT -&gt; INDEX_READ_BIT, VERTEX_ATTRIBUTE_READ_BIT,\n            Pipeline Stage: TRANSFER_BIT -&gt; VERTEX_INPUT_BIT, INDEX_INPUT_BIT,\n            QFI: 2 -&gt; 0, Size: 5840\n      RenderArea: (0,0)-(1280x768)\n  Signal Semaphores:\n  Binary Semaphore: 000002181325EB00 Stage: BOTTOM_OF_PIPE_BIT,\n  Timeline Semaphore: 0000021801EDB190, Stage: BOTTOM_OF_PIPE_BIT, Value: 15308\n\n--- End of Report ---```\n\n## Checking Compilation Results\n\nVerify frame graph compiled successfully:\n\n```cpp\nzest_frame_graph graph = zest_EndFrameGraph();\nzest_frame_graph_result result = zest_GetFrameGraphResult(graph);\n\nswitch (result) {\n    case zest_frame_graph_result_success:\n        // All good\n        break;\n    case zest_frame_graph_result_no_passes:\n        // Graph has no passes\n        break;\n    case zest_frame_graph_result_cycle_detected:\n        // Circular dependency found\n        break;\n    // ... other error cases\n}\n</code></pre>"},{"location":"concepts/frame-graph/debugging/#understanding-pass-culling","title":"Understanding Pass Culling","text":"<p>The frame graph compiler automatically removes unused passes. A pass is culled if:</p> <ol> <li>It produces no output, so in other words it does not use zest_ConnectOutput.</li> <li>It produces output but that ouput is not consumed and output to an essential target (like the swapchain or any resource you manually set as essential)</li> <li>It is not marked with <code>zest_DoNotCull()</code>. </li> </ol>"},{"location":"concepts/frame-graph/debugging/#preventing-culling","title":"Preventing Culling","text":"<p>For passes that should always execute (e.g., debug output, compute side effects):</p> <pre><code>zest_BeginRenderPass(\"Debug Overlay\"); {\n    zest_DoNotCull();  // Keep even without swapchain connection\n    zest_SetPassTask(DebugCallback, app);\n    zest_EndPass();\n}\n</code></pre>"},{"location":"concepts/frame-graph/debugging/#essential-resources","title":"Essential Resources","text":"<p>Mark resources whose production should never be culled:</p> <pre><code>zest_resource_node debug_buffer = zest_AddTransientBufferResource(\"Debug\", &amp;info);\nzest_FlagResourceAsEssential(debug_buffer);\n\n// Any pass that outputs to debug_buffer will not be culled\n</code></pre>"},{"location":"concepts/frame-graph/debugging/#common-issues","title":"Common Issues","text":""},{"location":"concepts/frame-graph/debugging/#pass-not-executing","title":"Pass Not Executing","text":"<p>Symptom: A pass callback is never called.</p> <p>Causes: 1. Pass was culled (no path to swapchain) 2. Missing <code>zest_ConnectOutput()</code> or <code>zest_ConnectInput()</code> calls 3. Resource connection creates no dependency chain to output</p> <p>Solution: <pre><code>// Option 1: Connect to something that reaches swapchain or other essential resource.\nzest_ConnectOutput(resource_used_by_later_pass);\n\n// Option 2: Force no culling\nzest_DoNotCull();\n\n// Option 3: Mark output as essential\nzest_FlagResourceAsEssential(output_resource);\n</code></pre></p>"},{"location":"concepts/frame-graph/debugging/#incorrect-barrier-timing","title":"Incorrect Barrier Timing","text":"<p>Symptom: Visual artifacts, validation errors about resource states.</p> <p>Causes: 1. Missing resource connection (input or output) 2. Resource used without declaring dependency</p> <p>Solution: Ensure all resource accesses are declared: <pre><code>// If you read a resource, connect it as input\nzest_ConnectInput(shadow_map);\n\n// If you write a resource, connect it as output\nzest_ConnectOutput(color_target);\n\n// If you read-modify-write, connect both\nzest_ConnectInput(particle_buffer);\nzest_ConnectOutput(particle_buffer);\n</code></pre></p>"},{"location":"concepts/frame-graph/debugging/#cache-frame-graphs","title":"Cache Frame Graphs","text":"<p>Avoid recompiling every frame:</p> <pre><code>// BAD: Rebuilds every frame\nif (zest_BeginFrameGraph(context, \"Graph\", NULL)) {\n    // ...\n    graph = zest_EndFrameGraph();\n}\n\n// GOOD: Caches and reuses\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, NULL, 0);\ngraph = zest_GetCachedFrameGraph(context, &amp;key);\nif (!graph) {\n    if (zest_BeginFrameGraph(context, \"Graph\", &amp;key)) {\n        // ...\n        graph = zest_EndFrameGraph();\n    }\n}\n</code></pre>"},{"location":"concepts/frame-graph/debugging/#use-transient-resources","title":"Use Transient Resources","text":"<p>Transient resources benefit from memory aliasing:</p> <pre><code>// Transient: memory can be shared with non-overlapping resources\nzest_resource_node temp = zest_AddTransientImageResource(\"Temp\", &amp;info);\n\n// vs. Imported: dedicated memory allocation\nzest_resource_node persistent = zest_ImportImageResource(\"Depth\", image, provider);\n</code></pre>"},{"location":"concepts/frame-graph/debugging/#validation-layers","title":"Validation Layers","text":"<p>Enable Vulkan validation layers during development:</p> <pre><code>zest_device_builder device_builder = zest_BeginVulkanDeviceBuilder();\n// Add your required extensions\nzest_AddDeviceBuilderExtensions(device_builder, extensions, count);\nzest_AddDeviceBuilderValidation(device_builder);\nzest_DeviceBuilderLogToConsole(device_builder);\nzest_device device = zest_EndDeviceBuilder(device_builder);\n</code></pre> <p>Or using the helper functions:</p> <pre><code>zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, true);\n</code></pre> <p>Validation layers catch: - Incorrect resource states - Missing synchronization - Invalid API usage</p>"},{"location":"concepts/frame-graph/debugging/#best-practices","title":"Best Practices","text":"<ol> <li>Print during development - Use <code>zest_PrintCompiledFrameGraph()</code> to verify structure</li> <li>Check compilation results - Handle errors gracefully</li> <li>Enable validation - Catch synchronization issues early</li> <li>Name everything - Pass and resource names appear in debug output</li> <li>Understand culling - Know why passes are removed</li> </ol> <p>If anything seems amiss please raise an issue, it could be a bug or missing feature in Zest!</p>"},{"location":"concepts/frame-graph/debugging/#see-also","title":"See Also","text":"<ul> <li>Passes - Pass types and culling options</li> <li>Resources - Essential resource flags</li> <li>Execution - Building and caching</li> <li>Frame Graph API - Function reference</li> </ul>"},{"location":"concepts/frame-graph/execution/","title":"Execution","text":"<p>This page covers building, caching, and executing frame graphs.</p>"},{"location":"concepts/frame-graph/execution/#building-frame-graphs","title":"Building Frame Graphs","text":""},{"location":"concepts/frame-graph/execution/#basic-flow","title":"Basic Flow","text":"<pre><code>//1. Acquire a swapchain image\nif(zest_BeginFrame(context) {\n    // 2. Begin building\n    if (zest_BeginFrameGraph(context, \"My Graph\", &amp;cache_key)) {\n        // 3. Import/create resources\n        zest_ImportSwapchainResource();\n\n        // 4. Define passes\n        zest_BeginRenderPass(\"Main\"); {\n            zest_ConnectSwapChainOutput();\n            zest_SetPassTask(RenderCallback, app);\n            zest_EndPass();\n        }\n\n        // 5. Compile\n        frame_graph = zest_EndFrameGraph();\n    }\n\n    // 6. Execute the frame graph and present to the screen\n    zest_EndFrame(context, frame_graph);\n}\n</code></pre>"},{"location":"concepts/frame-graph/execution/#zest_beginframegraph","title":"zest_BeginFrameGraph","text":"<p>Starts frame graph construction:</p> <pre><code>zest_bool zest_BeginFrameGraph(\n    zest_context context,      // The context to build for\n    const char *name,          // Debug name for the graph\n    zest_frame_graph_cache_key_t *cache_key  // Optional cache key\n);\n</code></pre> <p>Returns <code>zest_true</code> if the frame graph successfully initialised. If there's any problems then it will assert here.</p>"},{"location":"concepts/frame-graph/execution/#zest_endframegraph","title":"zest_EndFrameGraph","text":"<p>Compiles the frame graph:</p> <pre><code>zest_frame_graph zest_EndFrameGraph();\n</code></pre> <p>The compiler: - Determines pass execution order - Inserts memory barriers - Allocates transient resources - Culls unused passes</p>"},{"location":"concepts/frame-graph/execution/#zest_endframegraphandexecute","title":"zest_EndFrameGraphAndExecute","text":"<p>Shorthand for compile and immediate execution:</p> <pre><code>zest_EndFrameGraphAndExecute();\n</code></pre> <p>You can use this to perform a compute dispatch or render something to an image as part of an initialisation process. An alternative would be to use zest_imm_* commands which do something similar, but the advantage of using a frame graph is that it automatically take care of barriers and resource transitions if required.</p>"},{"location":"concepts/frame-graph/execution/#frame-graph-caching","title":"Frame Graph Caching","text":"<p>Compiling frame graphs has CPU overhead. Cache them whenever possible to increase performance.</p>"},{"location":"concepts/frame-graph/execution/#creating-cache-keys","title":"Creating Cache Keys","text":"<pre><code>// Simple cache key (context + swapchain state)\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, NULL, 0);\n\n// Cache key with custom data (for multiple configurations)\nstruct { int render_mode; zest_bool shadows_enabled; } config = {1, zest_true};\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(\n    context, &amp;config, sizeof(config));\n</code></pre> <p>The cache key incorporates: - Context state (swapchain format, size) - Optional user-provided data</p>"},{"location":"concepts/frame-graph/execution/#using-cached-graphs","title":"Using Cached Graphs","text":"<pre><code>zest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, NULL, 0);\n\n// Try to get cached graph\nzest_frame_graph graph = zest_GetCachedFrameGraph(context, &amp;key);\n\nif (!graph) {\n    // Build new graph (only happens once)\n    if (zest_BeginFrameGraph(context, \"Graph\", &amp;key)) {\n        // ... define passes ...\n        graph = zest_EndFrameGraph();\n    }\n}\n\n// Graph is automatically executed during zest_EndFrame()\n</code></pre>"},{"location":"concepts/frame-graph/execution/#cache-invalidation","title":"Cache Invalidation","text":"<p>Clear all cached graphs when the render configuration changes:</p> <pre><code>// On window resize or major state change\nzest_FlushCachedFrameGraphs(context);\n</code></pre>"},{"location":"concepts/frame-graph/execution/#execution_1","title":"Execution","text":"<p>Frame graphs are automatically executed when you call <code>zest_EndFrame()</code>. The compiled graph from <code>zest_EndFrameGraph()</code> is submitted to the GPU, and its final output is presented to the swapchain.</p>"},{"location":"concepts/frame-graph/execution/#synchronization","title":"Synchronization","text":"<p>Wait for a frame graph timeline signal:</p> <pre><code>zest_semaphore_status status = zest_WaitForSignal(timeline, timeout_microseconds);\n</code></pre> <p>Returns: - <code>zest_semaphore_status_success</code> - Signal received - <code>zest_semaphore_status_timeout</code> - Timeout elapsed - <code>zest_semaphore_status_error</code> - Error occurred</p> <p>You can use this to signal a timeline in a frame graph and then wait on the signal outside to ensure that it's finished.</p> <pre><code>zest_BeginFrameGraph(...);\n...\nzest_SignalTimeline(timeline)\nzest_EndFrameGraphAndExecute();\n\nzest_semaphore_status status = zest_WaitForSignal(timeline, timeout_microseconds);\n</code></pre>"},{"location":"concepts/frame-graph/execution/#execution-flow","title":"Execution Flow","text":"<p>The typical frame loop:</p> <pre><code>while (running) {\n    zest_UpdateDevice(device);\n\n    // Start frame\n    zest_BeginFrame(context);\n\n    // Build or retrieve cached graph\n    zest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, NULL, 0);\n    zest_frame_graph graph = zest_GetCachedFrameGraph(context, &amp;key);\n\n    if (!graph) {\n        if (zest_BeginFrameGraph(context, \"Main\", &amp;key)) {\n            // Setup resources and define passes...\n            graph = zest_EndFrameGraph();\n        }\n    }\n\n    // End frame (executes the graph, presents to swapchain)\n    zest_EndFrame(context);\n}\n</code></pre>"},{"location":"concepts/frame-graph/execution/#caching-patterns","title":"Caching Patterns","text":""},{"location":"concepts/frame-graph/execution/#static-graph","title":"Static Graph","text":"<p>For applications with fixed rendering structure:</p> <pre><code>// Initialize once\nstatic zest_frame_graph cached_graph = NULL;\nstatic zest_frame_graph_cache_key_t cache_key;\n\nif (!cached_graph) {\n    cache_key = zest_InitialiseCacheKey(context, NULL, 0);\n    if (zest_BeginFrameGraph(context, \"Static\", &amp;cache_key)) {\n        // Define passes...\n        cached_graph = zest_EndFrameGraph();\n    }\n}\n\n// Graph executes automatically during zest_EndFrame()\n</code></pre>"},{"location":"concepts/frame-graph/execution/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>For applications with multiple render modes:</p> <pre><code>typedef enum {\n    RENDER_MODE_FORWARD,\n    RENDER_MODE_DEFERRED,\n    RENDER_MODE_COUNT\n} render_mode;\n\n// Cache key includes render mode\nstruct { render_mode mode; } config = { current_mode };\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, &amp;config, sizeof(config));\n\nzest_frame_graph graph = zest_GetCachedFrameGraph(context, &amp;key);\nif (!graph) {\n    if (zest_BeginFrameGraph(context, \"Dynamic\", &amp;key)) {\n        if (current_mode == RENDER_MODE_FORWARD) {\n            // Forward rendering passes...\n        } else {\n            // Deferred rendering passes...\n        }\n        graph = zest_EndFrameGraph();\n    }\n}\n</code></pre>"},{"location":"concepts/frame-graph/execution/#state-changes","title":"State changes","text":"<p>For any major state changes in your application you can flush the whole cache with</p> <pre><code>zest_FlushCachedFrameGraphs(context);\n// Graphs will be rebuilt on next frame\n}\n</code></pre>"},{"location":"concepts/frame-graph/execution/#best-practices","title":"Best Practices","text":"<ol> <li>Cache whenever possible - Static graphs should always be cached</li> <li>Use cache keys for variants - Different render modes get different cache keys</li> <li>Flush on major changes - Window resize, render mode switch</li> <li>Check compilation results - During development, verify graph builds correctly</li> </ol>"},{"location":"concepts/frame-graph/execution/#see-also","title":"See Also","text":"<ul> <li>Passes - Pass types and callbacks</li> <li>Resources - Resource management</li> <li>Debugging - Debug output and optimization</li> <li>Frame Graph API - Function reference</li> </ul>"},{"location":"concepts/frame-graph/passes/","title":"Passes","text":"<p>Passes are the building blocks of a frame graph. Each pass represents a unit of GPU work with defined inputs and outputs.</p>"},{"location":"concepts/frame-graph/passes/#pass-types","title":"Pass Types","text":""},{"location":"concepts/frame-graph/passes/#render-pass","title":"Render Pass","text":"<p>For graphics pipeline operations (drawing geometry):</p> <pre><code>zest_BeginRenderPass(\"Draw Scene\"); {\n    zest_ConnectOutput(color_target);\n    zest_ConnectOutput(depth_target);\n    zest_SetPassTask(DrawCallback, user_data);\n    zest_EndPass();\n}\n</code></pre> <p>Render passes use the graphics queue and support: - Vertex/index buffer binding - Graphics pipeline binding - Draw commands</p>"},{"location":"concepts/frame-graph/passes/#compute-pass","title":"Compute Pass","text":"<p>For compute shader dispatch:</p> <pre><code>zest_compute compute = zest_GetCompute(compute_handle);\nzest_BeginComputePass(compute, \"Particle Sim\"); {\n    zest_ConnectInput(particle_positions);\n    zest_ConnectOutput(particle_positions);  // Read-modify-write\n    zest_SetPassTask(ComputeCallback, user_data);\n    zest_EndPass();\n}\n</code></pre> <p>Compute passes: - Require a <code>zest_compute</code> object (contains the compute pipeline) - Can run on compute or graphics queue - Support storage buffer/image operations</p>"},{"location":"concepts/frame-graph/passes/#transfer-pass","title":"Transfer Pass","text":"<p>For data uploads and copies:</p> <pre><code>zest_BeginTransferPass(\"Upload\"); {\n    zest_ConnectOutput(instance_buffer);\n    zest_SetPassTask(UploadCallback, layer);\n    zest_EndPass();\n}\n</code></pre> <p>Transfer passes: - Handle CPU-to-GPU data transfers - Can run on dedicated transfer queue if available - Used for staging buffer uploads</p>"},{"location":"concepts/frame-graph/passes/#resource-connections","title":"Resource Connections","text":""},{"location":"concepts/frame-graph/passes/#inputs-and-outputs","title":"Inputs and Outputs","text":"<pre><code>zest_ConnectInput(resource);   // Pass reads from this resource\nzest_ConnectOutput(resource);  // Pass writes to this resource\n</code></pre> <p>The frame graph compiler uses these connections to: - Determine execution order - Insert memory barriers - Track resource state transitions</p>"},{"location":"concepts/frame-graph/passes/#swapchain-output","title":"Swapchain Output","text":"<p>To write to the swapchain (final presentation):</p> <pre><code>zest_ConnectSwapChainOutput();\n</code></pre> <p>This marks the pass as contributing to the final image. Passes without a path to the swapchain may be culled.</p>"},{"location":"concepts/frame-graph/passes/#inputoutput-groups","title":"Input/Output Groups","text":"<p>For multiple related resources:</p> <pre><code>zest_resource_group group = zest_CreateResourceGroup();\nzest_AddResourceToGroup(group, albedo);\nzest_AddResourceToGroup(group, normal);\nzest_AddResourceToGroup(group, depth);\n\nzest_BeginRenderPass(\"G-Buffer\"); {\n    zest_ConnectOutputGroup(group);\n    zest_SetPassTask(GBufferCallback, app);\n    zest_EndPass();\n}\n</code></pre>"},{"location":"concepts/frame-graph/passes/#pass-tasks-callbacks","title":"Pass Tasks (Callbacks)","text":"<p>Each pass requires a callback function that executes the actual GPU commands:</p> <pre><code>void MyRenderCallback(const zest_command_list cmd, void* user_data) {\n    app_t* app = (app_t*)user_data;\n\n    // Bind pipeline\n    zest_pipeline pipeline = zest_GetPipeline(app-&gt;pipeline, cmd);\n    zest_cmd_BindPipeline(cmd, pipeline);\n\n    // Set viewport/scissor\n    zest_cmd_SetScreenSizedViewport(cmd, 0.0f, 1.0f);\n\n    // Bind vertex buffer\n    zest_cmd_BindVertexBuffer(cmd, 0, 1, buffer);\n\n    // Draw\n    zest_cmd_Draw(cmd, vertex_count, 1, 0, 0);\n}\n\n// In frame graph\nzest_SetPassTask(MyRenderCallback, app);\n</code></pre>"},{"location":"concepts/frame-graph/passes/#callback-parameters","title":"Callback Parameters","text":"Parameter Type Description <code>cmd</code> <code>zest_command_list</code> Command buffer for recording commands <code>user_data</code> <code>void*</code> User data passed to <code>zest_SetPassTask</code>"},{"location":"concepts/frame-graph/passes/#utility-callbacks","title":"Utility Callbacks","text":"<p>For passes that need no commands (e.g., just clears):</p> <pre><code>zest_BeginRenderPass(\"Clear Pass\"); {\n    zest_ConnectOutput(color_target);\n    zest_SetResourceClearColor(color_target, 0.0f, 0.0f, 0.0f, 1.0f);\n    zest_SetPassTask(zest_EmptyRenderPass, NULL);\n    zest_EndPass();\n}\n</code></pre> <p><code>zest_EmptyRenderPass</code> is a built-in callback that records no commands.</p>"},{"location":"concepts/frame-graph/passes/#pass-options","title":"Pass Options","text":""},{"location":"concepts/frame-graph/passes/#preventing-pass-culling","title":"Preventing Pass Culling","text":"<p>By default, passes without connections to the swapchain are culled:</p> <pre><code>zest_BeginRenderPass(\"Debug Pass\"); {\n    zest_DoNotCull();  // Keep this pass even if unused\n    zest_SetPassTask(DebugCallback, app);\n    zest_EndPass();\n}\n</code></pre>"},{"location":"concepts/frame-graph/passes/#custom-descriptor-sets","title":"Custom Descriptor Sets","text":"<p>Pass additional descriptor sets to a pass:</p> <pre><code>zest_descriptor_set sets[] = {my_custom_set};\nzest_SetDescriptorSets(pipeline_layout, sets, 1);\n</code></pre> <p>This is useful when you need descriptor sets beyond the global bindless set.</p>"},{"location":"concepts/frame-graph/passes/#accessing-resources-in-callbacks","title":"Accessing Resources in Callbacks","text":"<p>Within a pass callback, retrieve connected resources:</p> <pre><code>void MyCallback(const zest_command_list cmd, void* user_data) {\n    // Get input resource by name\n    zest_resource_node input = zest_GetPassInputResource(cmd, \"ShadowMap\");\n\n    // Get output resource by name\n    zest_resource_node output = zest_GetPassOutputResource(cmd, \"ColorTarget\");\n\n    // Get buffer directly\n    zest_buffer buf = zest_GetPassInputBuffer(cmd, \"InstanceData\");\n    zest_buffer out_buf = zest_GetPassOutputBuffer(cmd, \"Results\");\n\n    // Use resources...\n}\n</code></pre>"},{"location":"concepts/frame-graph/passes/#complete-example","title":"Complete Example","text":"<pre><code>void RenderScene(const zest_command_list cmd, void* user_data) {\n    app_t* app = (app_t*)user_data;\n\n    // Get pipeline variant for current render state\n    zest_pipeline pipeline = zest_GetPipeline(app-&gt;mesh_pipeline, cmd);\n    zest_cmd_BindPipeline(cmd, pipeline);\n\n    // Set viewport\n    zest_cmd_SetScreenSizedViewport(cmd, 0.0f, 1.0f);\n\n    // Bind vertex/index buffers\n    zest_cmd_BindVertexBuffer(cmd, 0, 1, app-&gt;vertex_buffer);\n    zest_cmd_BindIndexBuffer(cmd, app-&gt;index_buffer);\n\n    // Push constants\n    push_constants_t pc = {\n        .mvp = app-&gt;camera_mvp,\n        .texture_index = app-&gt;texture_index\n    };\n    zest_cmd_SendPushConstants(cmd, &amp;pc, sizeof(pc));\n\n    // Draw indexed\n    zest_cmd_DrawIndexed(cmd, app-&gt;index_count, 1, 0, 0, 0);\n}\n\n// In frame graph setup\nzest_BeginRenderPass(\"Scene\"); {\n    zest_ConnectOutput(color_target);\n    zest_ConnectOutput(depth_target);\n    zest_SetPassTask(RenderScene, app);\n    zest_EndPass();\n}\n</code></pre>"},{"location":"concepts/frame-graph/passes/#best-practices","title":"Best Practices","text":"<ol> <li>Name passes descriptively - Names appear in debug output and profilers</li> <li>Minimize pass count - Combine passes when logical to reduce overhead</li> <li>Declare all resource dependencies - Missing connections cause undefined behavior</li> <li>Use groups for Multi Render Target (MRT) - Resource groups simplify multiple render target setups</li> <li>Let culling work - Avoid <code>zest_DoNotCull</code> unless necessary</li> </ol>"},{"location":"concepts/frame-graph/passes/#see-also","title":"See Also","text":"<ul> <li>Resources - Resource types and management</li> <li>Execution - Building and executing frame graphs</li> <li>Frame Graph API - Function reference</li> </ul>"},{"location":"concepts/frame-graph/resources/","title":"Resources","text":"<p>Resources are the data that flows through a frame graph. This page covers importing external resources, creating transient resources, and managing resource properties.</p>"},{"location":"concepts/frame-graph/resources/#resource-types","title":"Resource Types","text":"Type Lifetime Memory Use Case Swapchain Per-frame Managed by presentation engine Final output Imported Application-controlled Persistent Textures, meshes, external buffers Transient Single frame Pooled/aliased Intermediate render targets"},{"location":"concepts/frame-graph/resources/#importing-external-resources","title":"Importing External Resources","text":""},{"location":"concepts/frame-graph/resources/#swapchain","title":"Swapchain","text":"<p>The swapchain is always imported first:</p> <pre><code>zest_ImportSwapchainResource();\n</code></pre> <p>This returns the current frame's swapchain image as a resource node (otional, you don't need to do anything with the returned resource as it's registered in the frame graph internally).</p>"},{"location":"concepts/frame-graph/resources/#images","title":"Images","text":"<p>Import existing images (textures, render targets):</p> <pre><code>zest_image image = zest_GetImage(image_handle);\nzest_resource_node tex = zest_ImportImageResource(\"Texture\", image, zest_texture_2d_binding);\n</code></pre> <p>You only need to import images that either require a layout transition before reading from or intend on writing to the image. It's recommended that if you only want to sample from an image and it's already in layout shader read only optimal then there's no need to import. You can just simply pass on it's descriptor array index in a push constant or uniform buffer and sample from it in a shader.</p> <p>The <code>provider</code> parameter specifies a callback that get's the correct image view to use specifically when the frame graph is cached. For example the swapchain uses a provider to get the correct image frame that was acquired. In most cases you can just pass NULL or 0 as the image will just have it's one default view.</p>"},{"location":"concepts/frame-graph/resources/#buffers","title":"Buffers","text":"<p>Import existing buffers:</p> <pre><code>zest_buffer buffer = zest_GetBuffer(buffer_handle);\nzest_resource_node buf = zest_ImportBufferResource(\"Instances\", buffer, provider);\n</code></pre> <p>**You only need to import buffers that you might write to and be a part of dependency chains in the graph. If your buffers will only be read from in the graph then there's no need to import, you can just access them in shaders via their descriptor array index.</p> <p>The <code>provider</code> parameter specifies a callback so that a cached frame graph can get the relevent resource - for example the correct frame in flight buffer.</p>"},{"location":"concepts/frame-graph/resources/#transient-resources","title":"Transient Resources","text":"<p>Transient resources exist only for a single frame. They are allocated from a pool and can share memory with non-overlapping resources.</p>"},{"location":"concepts/frame-graph/resources/#transient-images","title":"Transient Images","text":"<pre><code>zest_image_resource_info_t info = {\n    .format = zest_format_r16g16b16a16_sfloat,\n    .usage_hint = zest_resource_usage_hint_copyable,\n    .width = 1920,\n    .height = 1080,\n    .mip_levels = 1\n};\nzest_resource_node hdr_target = zest_AddTransientImageResource(\"HDR\", &amp;info);\n</code></pre> <p>Image Resource Info Fields:</p> Field Description <code>format</code> Image format (e.g., <code>zest_format_r8g8b8a8_unorm</code>) <code>usage_hint</code> How the image will be used to give the frame graph hint to set the correct usage flags <code>width</code>, <code>height</code> Dimensions in pixels <code>mip_levels</code> Number of mip levels (1 = no mipmaps)"},{"location":"concepts/frame-graph/resources/#transient-buffers","title":"Transient Buffers","text":"<pre><code>zest_buffer_resource_info_t info = {\n    .size = sizeof(particle_t) * MAX_PARTICLES,\n    .usage_hint = zest_resource_usage_hint_vertex_storage\n};\nzest_resource_node particles = zest_AddTransientBufferResource(\"Particles\", &amp;info);\n</code></pre> <p>Buffer Resource Info Fields:</p> Field Description <code>size</code> Buffer size in bytes <code>usage_hint</code> How the buffer will be used"},{"location":"concepts/frame-graph/resources/#transient-layers","title":"Transient Layers","text":"<p>For layer-based rendering with previous frame access:</p> <pre><code>zest_resource_node layer_node = zest_AddTransientLayerResource(\"Sprites\", sprite_layer, zest_false);\n</code></pre> <p>For advanced use: the <code>prev_fif</code> parameter controls which frame-in-flight's buffer is used: - <code>zest_false</code> - Current frame's buffer - <code>zest_true</code> - Previous frame's buffer (for temporal effects)</p>"},{"location":"concepts/frame-graph/resources/#resource-properties","title":"Resource Properties","text":"<p>It can be useful to access resource properties inside pass callback functions.</p>"},{"location":"concepts/frame-graph/resources/#dimensions-and-format","title":"Dimensions and Format","text":"<p>Query resource dimensions:</p> <pre><code>zest_uint width = zest_GetResourceWidth(resource);\nzest_uint height = zest_GetResourceHeight(resource);\nzest_uint mips = zest_GetResourceMipLevels(resource);\n</code></pre> <p>Get full image description:</p> <pre><code>zest_image_info_t info = zest_GetResourceImageDescription(resource);\n</code></pre> <p>The info struct contains the following data:</p> Field Description <code>extent</code> The image dimensions, width, height and depth <code>mip_levels</code> The number of mip levels in the image <code>layer_count</code> The number of image array layers if the image is a texture array <code>format</code> The image format (zest_format) <code>aspect_flags</code> The aspect flag (color, depth or stencil) <code>sample_count</code> The sample count <code>flags</code> The flags that describe how the image is used <code>layout</code> The image layout (general, readonly, attachment etc.)"},{"location":"concepts/frame-graph/resources/#resource-type","title":"Resource Type","text":"<pre><code>zest_resource_type type = zest_GetResourceType(resource);\n// Returns: zest_resource_type_image, zest_resource_type_buffer, etc.\n</code></pre>"},{"location":"concepts/frame-graph/resources/#clear-color","title":"Clear Color","text":"<p>Set the clear color for render target resources:</p> <pre><code>zest_SetResourceClearColor(color_target, 0.1f, 0.1f, 0.1f, 1.0f);\n</code></pre>"},{"location":"concepts/frame-graph/resources/#buffer-size","title":"Buffer Size","text":"<p>Dynamically resize a buffer resource. This can be called inside a resource buffer provider function before the transient buffer is created if won't know the size until frame execution.</p> <pre><code>zest_SetResourceBufferSize(buffer_resource, new_size);\n</code></pre>"},{"location":"concepts/frame-graph/resources/#user-data","title":"User Data","text":"<p>Attach custom data to resources that you can retrieve inside a pass callback function.</p> <pre><code>// Store\nzest_SetResourceUserData(resource, my_data);\n\n// Retrieve\nvoid* data = zest_GetResourceUserData(resource);\n</code></pre>"},{"location":"concepts/frame-graph/resources/#providers","title":"Providers","text":"<p>Change how a resource is accessed:</p> <pre><code>// Change image binding type\nzest_SetResourceImageProvider(resource, callback);\n\n// Change buffer binding type\nzest_SetResourceBufferProvider(resource, callback);\n</code></pre>"},{"location":"concepts/frame-graph/resources/#getting-the-underlying-image","title":"Getting the Underlying Image","text":"<pre><code>zest_image image = zest_GetResourceImage(resource);\n</code></pre>"},{"location":"concepts/frame-graph/resources/#accessing-resources-in-passes","title":"Accessing Resources in Passes","text":"<p>Within a pass callback, retrieve resources by name:</p> <pre><code>void MyCallback(const zest_command_list cmd, void* user_data) {\n    // Get resource nodes\n    zest_resource_node input = zest_GetPassInputResource(cmd, \"ShadowMap\");\n    zest_resource_node output = zest_GetPassOutputResource(cmd, \"HDR\");\n\n    // Get buffers directly\n    zest_buffer in_buf = zest_GetPassInputBuffer(cmd, \"Particles\");\n    zest_buffer out_buf = zest_GetPassOutputBuffer(cmd, \"Results\");\n}\n</code></pre>"},{"location":"concepts/frame-graph/resources/#resource-groups","title":"Resource Groups","text":"<p>Group multiple resources for convenience:</p> <pre><code>// Create group\nzest_resource_group gbuffer = zest_CreateResourceGroup();\nzest_resource_group scene_output = zest_CreateResourceGroup();\n\n// Add resources\nzest_AddResourceToGroup(gbuffer, albedo);\nzest_AddResourceToGroup(gbuffer, normal);\nzest_AddResourceToGroup(gbuffer, depth);\n\n// Add swapchain to a group\nzest_AddSwapchainToGroup(scene_output);\nzest_AddResourceToGroup(scene_output, depth);\n\n// Use in passese\nzest_BeginRenderPass(\"G-Buffer\"); {\n    zest_ConnectOutputGroup(gbuffer);\n    zest_SetPassTask(RenderGBuffer, app);\n    zest_EndPass();\n}\n\nzest_BeginRenderPass(\"Scene\"); {\n    zest_ConnectInputGroup(gbuffer);\n    zest_ConnectOuputGroup(scene_output);\n    zest_SetPassTask(RenderScene, app);\n    zest_EndPass();\n}\n</code></pre>"},{"location":"concepts/frame-graph/resources/#bindless-descriptor-access","title":"Bindless Descriptor Access","text":"<p>Get bindless descriptor indices for transient resources:</p> <p>Note: transient descriptor array indexes are automatically released after use.</p>"},{"location":"concepts/frame-graph/resources/#sampled-images","title":"Sampled Images","text":"<pre><code>void MyCallback(const zest_command_list cmd, void* user_data) {\n    // Get single bindless index\n    zest_uint index = zest_GetTransientSampledImageBindlessIndex(\n        cmd, resource, binding_number);\n\n    // Get indices for all mip levels\n    zest_uint* mip_indices = zest_GetTransientSampledMipBindlessIndexes(\n        cmd, resource, binding_number);\n}\n</code></pre>"},{"location":"concepts/frame-graph/resources/#storage-buffers","title":"Storage Buffers","text":"<pre><code>void MyCallback(const zest_command_list cmd, void* user_data) {\n    zest_uint index = zest_GetTransientBufferBindlessIndex(cmd, resource);\n\n    // Use index in push constants for shader access\n    push_constants.buffer_index = index;\n}\n</code></pre>"},{"location":"concepts/frame-graph/resources/#essential-resources","title":"Essential Resources","text":"<p>Mark resources that should prevent pass culling:</p> <pre><code>zest_FlagResourceAsEssential(debug_output);\n</code></pre> <p>Essential resources ensure their producing passes are not culled, even without a path to the swapchain.</p>"},{"location":"concepts/frame-graph/resources/#complete-example-g-buffer-setup","title":"Complete Example: G-Buffer Setup","text":"<pre><code>if (zest_BeginFrameGraph(context, \"Deferred\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();\n\n    // Transient G-buffer images\n    zest_image_resource_info_t color_info = {\n        .format = zest_format_r8g8b8a8_unorm,\n        .width = width, .height = height, .mip_levels = 1\n    };\n    zest_image_resource_info_t depth_info = {\n        .format = zest_format_d32_sfloat,\n        .width = width, .height = height, .mip_levels = 1\n    };\n\n    zest_resource_node albedo = zest_AddTransientImageResource(\"Albedo\", &amp;color_info);\n    zest_resource_node normal = zest_AddTransientImageResource(\"Normal\", &amp;color_info);\n    zest_resource_node depth = zest_AddTransientImageResource(\"Depth\", &amp;depth_info);\n\n    // Group for convenience\n    zest_resource_group gbuffer = zest_CreateResourceGroup();\n    zest_AddResourceToGroup(gbuffer, albedo);\n    zest_AddResourceToGroup(gbuffer, normal);\n    zest_AddResourceToGroup(gbuffer, depth);\n\n    // G-buffer pass\n    zest_BeginRenderPass(\"G-Buffer\"); {\n        zest_ConnectOutputGroup(gbuffer);\n        zest_SetPassTask(RenderGBuffer, app);\n        zest_EndPass();\n    }\n\n    // Lighting pass reads G-buffer\n    zest_BeginRenderPass(\"Lighting\"); {\n        zest_ConnectInput(albedo);\n        zest_ConnectInput(normal);\n        zest_ConnectInput(depth);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(DeferredLighting, app);\n        zest_EndPass();\n    }\n\n    frame_graph = zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"concepts/frame-graph/resources/#best-practices","title":"Best Practices","text":"<ol> <li>Use transient resources for intermediates - They benefit from memory aliasing</li> <li>Import persistent resources only if used as output - Textures, meshes, and long-lived data that you need to write too or transition.</li> <li>Group related resources - Simplifies MRT and G-buffer setups</li> <li>Set clear colors explicitly - Avoids undefined initial values</li> <li>Use bindless helpers - Simplifies shader resource access</li> </ol>"},{"location":"concepts/frame-graph/resources/#see-also","title":"See Also","text":"<ul> <li>Passes - Pass types and callbacks</li> <li>Execution - Building and executing frame graphs</li> <li>Bindless Descriptors - Global descriptor system</li> <li>Frame Graph API - Function reference</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Working examples demonstrating Zest features. All examples can be built with CMake.</p>"},{"location":"examples/#building-examples","title":"Building Examples","text":"<pre><code>cmake -B build -G \"Visual Studio 17 2022\"\ncmake --build build --config Release\n</code></pre> <p>Executables are in <code>build/examples/SDL2/Release/</code> (Windows) or <code>build/examples/SDL2/</code> (Linux/macOS).</p>"},{"location":"examples/#examples_1","title":"Examples","text":""},{"location":"examples/#basic-setup","title":"Basic Setup","text":""},{"location":"examples/#minimal-template","title":"zest-minimal-template","text":"<p>The simplest Zest application. Blank screen with basic frame graph.</p> <ul> <li>Device and context creation</li> <li>Frame graph caching</li> <li>Minimal render pass</li> </ul> <p>Source: <code>examples/SDL2/zest-minimal-template/</code></p>"},{"location":"examples/#imgui-template","title":"zest-imgui-template","text":"<p>ImGui integration with docking support.</p> <ul> <li>ImGui setup and rendering</li> <li>Custom fonts</li> <li>Docking workspace</li> </ul> <p>Source: <code>examples/SDL2/zest-imgui-template/</code></p>"},{"location":"examples/#rendering-techniques","title":"Rendering Techniques","text":""},{"location":"examples/#instancing","title":"zest-instancing","text":"<p>GPU instancing with 3D models.</p> <ul> <li>Instance mesh layers</li> <li>GLTF model loading</li> <li>Per-instance data</li> <li>Efficient batched drawing</li> </ul> <p>Source: <code>examples/SDL2/zest-instancing/</code></p>"},{"location":"examples/#pbr-forward","title":"zest-pbr-forward","text":"<p>Physical-based rendering (forward shading).</p> <ul> <li>PBR materials</li> <li>Image-based lighting (IBL)</li> <li>Environment cubemaps</li> <li>BRDF lookup tables</li> </ul> <p>Source: <code>examples/SDL2/zest-pbr-forward/</code></p>"},{"location":"examples/#pbr-deferred","title":"zest-pbr-deferred","text":"<p>PBR with deferred shading.</p> <ul> <li>G-buffer rendering</li> <li>Deferred lighting pass</li> <li>Multiple render targets</li> </ul> <p>Source: <code>examples/SDL2/zest-pbr-deferred/</code></p>"},{"location":"examples/#pbr-texture","title":"zest-pbr-texture","text":"<p>PBR with texture mapping.</p> <ul> <li>Albedo, normal, roughness, metallic maps</li> <li>KTX texture loading</li> <li>Bindless texture arrays</li> </ul> <p>Source: <code>examples/SDL2/zest-pbr-texture/</code></p>"},{"location":"examples/#shadow-mapping","title":"zest-shadow-mapping","text":"<p>Basic shadow mapping.</p> <ul> <li>Depth-only render pass</li> <li>Shadow map sampling</li> <li>Bias and PCF basics</li> </ul> <p>Source: <code>examples/SDL2/zest-shadow-mapping/</code></p>"},{"location":"examples/#cascading-shadows","title":"zest-cascading-shadows","text":"<p>Cascaded shadow maps (CSM).</p> <ul> <li>Multiple shadow cascades</li> <li>Cascade selection</li> <li>Large scene shadows</li> </ul> <p>Source: <code>examples/SDL2/zest-cascading-shadows/</code></p>"},{"location":"examples/#render-targets","title":"zest-render-targets","text":"<p>Multi-pass rendering with bloom.</p> <ul> <li>Transient render targets</li> <li>Compute-based post-processing</li> <li>HDR pipeline</li> </ul> <p>Source: <code>examples/SDL2/zest-render-targets/</code></p>"},{"location":"examples/#compute-shaders","title":"Compute Shaders","text":""},{"location":"examples/#compute-example","title":"zest-compute-example","text":"<p>GPU compute shader particle simulation.</p> <ul> <li>Compute pipelines</li> <li>Storage buffers</li> <li>Frame graph compute passes</li> <li>Slang shader support</li> </ul> <p>Source: <code>examples/SDL2/zest-compute-example/</code></p>"},{"location":"examples/#special-effects","title":"Special Effects","text":""},{"location":"examples/#fonts","title":"zest-fonts","text":"<p>MSDF font rendering.</p> <ul> <li>MSDF font generation</li> <li>High-quality text at any scale</li> <li>Font layers</li> </ul> <p>Source: <code>examples/SDL2/zest-fonts/</code></p>"},{"location":"examples/#ribbons","title":"zest-ribbons","text":"<p>Ribbon/trail effects.</p> <ul> <li>Dynamic geometry</li> <li>Trail rendering</li> <li>Smooth curves</li> </ul> <p>Source: <code>examples/SDL2/zest-ribbons/</code></p>"},{"location":"examples/#integrations","title":"Integrations","text":""},{"location":"examples/#timelinefx","title":"zest-timelinefx","text":"<p>TimelineFX particle system integration.</p> <ul> <li>Particle effect loading</li> <li>Effect playback</li> <li>Shape loaders</li> </ul> <p>Source: <code>examples/SDL2/zest-timelinefx/</code></p>"},{"location":"examples/#implot","title":"zest-implot","text":"<p>ImPlot data visualization.</p> <ul> <li>Real-time plotting</li> <li>Multiple chart types</li> <li>ImGui integration</li> </ul> <p>Source: <code>examples/SDL2/zest-implot/</code></p>"},{"location":"examples/#games","title":"Games","text":""},{"location":"examples/#vaders","title":"zest-vaders","text":"<p>Space Invaders-style game demo.</p> <ul> <li>Complete game loop</li> <li>Sprite rendering</li> <li>Game state management</li> <li>TimelineFX effects</li> </ul> <p>Source: <code>examples/SDL2/zest-vaders/</code></p>"},{"location":"examples/#testing","title":"Testing","text":""},{"location":"examples/#tests","title":"zest-tests","text":"<p>Comprehensive test suite.</p> <ul> <li>Frame graph compilation tests</li> <li>Pipeline state tests</li> <li>Resource management tests</li> <li>36+ unit tests</li> </ul> <p>Source: <code>examples/SDL2/zest-tests/</code></p>"},{"location":"examples/#example-structure","title":"Example Structure","text":"<p>All examples follow this pattern:</p> <pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;zest.h&gt;\n\nstruct app_t {\n    zest_device device;\n    zest_context context;\n    // ... example-specific state\n};\n\nvoid MainLoop(app_t* app) {\n    while (running) {\n        zest_UpdateDevice(app-&gt;device);\n        if (zest_BeginFrame(app-&gt;context)) {\n            // Build/get frame graph\n            // Execute\n            zest_EndFrame(app-&gt;context);\n        }\n    }\n}\n\nint main() {\n    // Setup device, window, context\n    // Initialize resources\n    MainLoop(&amp;app);\n    // Cleanup\n}\n</code></pre>"},{"location":"examples/#running-from-source-directory","title":"Running from Source Directory","text":"<p>Examples expect to be run from the repository root (for asset paths):</p> <pre><code>cd /path/to/zest\n./build/examples/SDL2/Release/zest-pbr-forward.exe\n</code></pre> <p>Or set the working directory in your IDE to the repository root.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Zest! This section will help you get up and running with Zest quickly.</p>"},{"location":"getting-started/#what-is-zest","title":"What is Zest?","text":"<p>Zest is a lightweight rendering library designed to simplify GPU programming while maintaining full control over the rendering pipeline. Unlike heavy game engines, Zest provides just enough abstraction to be productive without hiding important details.</p>"},{"location":"getting-started/#core-philosophy","title":"Core Philosophy","text":"<ul> <li>Simplicity - Single header file, minimal dependencies</li> <li>Transparency - You always know what's happening under the hood</li> <li>Efficiency - Frame graph compilation, resource pooling, bindless descriptors</li> <li>Flexibility - Use as much or as little of the library as you need and implement your own features as you need them.</li> </ul>"},{"location":"getting-started/#in-this-section","title":"In This Section","text":"<ol> <li>Installation - Build Zest and run the examples</li> <li>First Application - Create your first Zest application step by step</li> <li>Architecture Overview - Understand Device, Context, and Frame Graph</li> </ol>"},{"location":"getting-started/#recommended-reading-order","title":"Recommended Reading Order","text":"<p>If you're new to Zest:</p> <ol> <li>Start with Installation to get the examples building</li> <li>Follow First Application to understand the basic structure</li> <li>Read Architecture Overview to grasp the core concepts</li> <li>Then explore Concepts for deeper understanding</li> <li>Follow Tutorials to build practical knowledge</li> </ol>"},{"location":"getting-started/architecture/","title":"Architecture Overview","text":"<p>Zest is built around two core objects and one execution model. Understanding these is key to using the library effectively.</p>"},{"location":"getting-started/architecture/#the-two-core-objects","title":"The Two Core Objects","text":""},{"location":"getting-started/architecture/#device-zest_device","title":"Device (<code>zest_device</code>)","text":"<p>The device is a singleton that represents your GPU and manages global resources:</p> <pre><code>// Currently using the Vulkan backend with SDL2\nzest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, false);\n</code></pre> <p>What it owns:</p> <ul> <li>Graphics API instance and physical device</li> <li>Shader library (compiled shaders)</li> <li>Pipeline template cache</li> <li>Bindless descriptor sets</li> <li>GPU memory pools (buffers, images)</li> <li>Sampler cache</li> </ul> <p>Lifecycle: Create once at startup, destroy at shutdown. All contexts share the same device.</p>"},{"location":"getting-started/architecture/#context-zest_context","title":"Context (<code>zest_context</code>)","text":"<p>The context represents a render target (window) and manages per-frame resources:</p> <pre><code>zest_create_context_info_t create_info = zest_CreateContextInfo();\nzest_context context = zest_CreateContext(device, &amp;window_data, &amp;create_info);\n</code></pre> <p>What it owns:</p> <ul> <li>Swapchain and presentation</li> <li>Frame synchronization primitives</li> <li>Command buffer pools</li> <li>Frame graph cache</li> <li>Linear allocators for frame-lifetime data</li> </ul> <p>Lifecycle: One per window. Can have multiple contexts sharing one device.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Device                       \u2502\n\u2502  - Graphics API instance                        \u2502\n\u2502  - Shader library                               \u2502\n\u2502  - Bindless descriptors                         \u2502\n\u2502  - Memory pools                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         \u2502                       \u2502               \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510          \u2502\n\u2502    \u2502 Context \u2502             \u2502 Context \u2502          \u2502\n\u2502    \u2502 (Win 1) \u2502             \u2502 (Win 2) \u2502          \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/architecture/#the-frame-graph","title":"The Frame Graph","text":"<p>The frame graph is Zest's execution model. Instead of manually managing barriers, semaphores, and resource states, you declare what resources each pass reads and writes.</p>"},{"location":"getting-started/architecture/#why-frame-graphs","title":"Why Frame Graphs?","text":"<p>Traditional low-level graphics APIs (Vulkan, D3D12, Metal) require:</p> <ul> <li>Manual barrier/synchronization insertion</li> <li>Explicit resource state tracking</li> <li>Render pass management</li> <li>Cross-queue synchronization</li> </ul> <p>Frame graphs handle all of this automatically by analyzing resource dependencies.</p>"},{"location":"getting-started/architecture/#building-a-frame-graph","title":"Building a Frame Graph","text":"<pre><code>if (zest_BeginFrameGraph(context, \"My Graph\", &amp;cache_key)) {\n    // 1. Import external resources\n    zest_ImportSwapchainResource();\n\n    // 2. Define passes\n    zest_BeginRenderPass(\"Pass Name\"); {\n        zest_ConnectSwapChainOutput();       // Output to swapchain\n        zest_SetPassTask(MyCallback, data);  // Render callback\n        zest_EndPass();\n    }\n\n    // 3. Compile\n    frame_graph = zest_EndFrameGraph();\n}\n\n// For custom resources, use:\n// zest_ConnectInput(some_resource);    // Read from resource\n// zest_ConnectOutput(other_resource);  // Write to resource\n</code></pre>"},{"location":"getting-started/architecture/#what-happens-at-compile-time","title":"What Happens at Compile Time","text":"<p>When you call <code>zest_EndFrameGraph()</code>, the compiler:</p> <ol> <li>Builds the dependency graph - Analyzes which passes depend on which resources</li> <li>Inserts barriers - Adds synchronization barriers for resource transitions</li> <li>Culls unused passes - Removes passes that don't contribute to final output</li> <li>Handles synchronization - Manages synchronization between queues</li> <li>Creates transient resources - Allocates temporary images/buffers</li> </ol>"},{"location":"getting-started/architecture/#pass-types","title":"Pass Types","text":"Pass Type Purpose Example Render Pass Graphics pipeline, drawing Scene rendering, UI Compute Pass Compute shaders Particle simulation, post-processing Transfer Pass Data uploads Staging buffer copies <pre><code>zest_BeginRenderPass(\"Draw Scene\");   // Graphics\nzest_BeginComputePass(compute, \"Sim\"); // Compute\nzest_BeginTransferPass(\"Upload\");      // Transfer\n</code></pre>"},{"location":"getting-started/architecture/#frame-graph-caching","title":"Frame Graph Caching","text":"<p>Compiling frame graphs has CPU cost. Cache them when the structure doesn't change:</p> <pre><code>// Generate cache key (can include custom data)\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, custom_data, size);\n\n// Try to get cached graph\nzest_frame_graph graph = zest_GetCachedFrameGraph(context, &amp;key);\n\n// Only build if not cached\nif (!graph) {\n    if (zest_BeginFrameGraph(context, \"Graph\", &amp;key)) {\n        // ... build graph ...\n        graph = zest_EndFrameGraph();\n    }\n}\n</code></pre>"},{"location":"getting-started/architecture/#bindless-descriptors","title":"Bindless Descriptors","text":"<p>Zest uses a bindless descriptor model. Instead of creating and binding descriptor sets per object, all resources are indexed into global arrays.</p> <pre><code>// Acquire an index when creating a texture\nzest_uint tex_index = zest_AcquireSampledImageIndex(device, image, zest_texture_2d_binding);\n\n// Pass the index to shaders via push constants (inside a render callback)\npush_data.texture_index = tex_index;\nzest_cmd_SendPushConstants(command_list, &amp;push_data, sizeof(push_data));\n</code></pre> <p>In shaders:</p> <pre><code>layout(set = 0, binding = 0) uniform sampler2D textures[];\n\nvoid main() {\n    vec4 color = texture(textures[push.texture_index], uv);\n}\n</code></pre> <p>Benefits:</p> <ul> <li>Bind descriptor sets once per frame</li> <li>No descriptor set management per object</li> <li>Unlimited textures (within GPU limits)</li> <li>Simpler shader code</li> </ul>"},{"location":"getting-started/architecture/#memory-management","title":"Memory Management","text":"<p>Zest uses a TLSF allocator for both CPU and GPU memory:</p> <ul> <li>Minimal fragmentation - Two-level segregated fit algorithm</li> <li>O(1) allocation - Constant time allocate and free</li> <li>Auto-expanding pools - Pools grow when needed</li> </ul>"},{"location":"getting-started/architecture/#pool-types","title":"Pool Types","text":"Pool Purpose Typical Size Device Buffer Pool GPU-only buffers 64 MB Staging Buffer Pool CPU-visible uploads 32 MB Image Memory Pool Textures 256 MB <pre><code>// Configure pool sizes after creating device\nzest_SetStagingBufferPoolSize(device, zloc__KILOBYTE(256), zloc__MEGABYTE(128));\nzest_SetGPUBufferPoolSize(device, zloc__KILOBYTE(256), zloc__MEGABYTE(64));\n</code></pre>"},{"location":"getting-started/architecture/#typical-frame-structure","title":"Typical Frame Structure","text":"<pre><code>while (running) {\n    zest_UpdateDevice(device);          // 1. Update device state\n    HandleInput();                       // 2. Process input\n\n    if (zest_BeginFrame(context)) {      // 3. Begin frame\n        // Update uniforms, instance data, etc.\n        UpdateGameState();\n\n        // Get or build frame graph\n        zest_frame_graph graph = GetOrBuildFrameGraph();\n\n        // Execute graph and present\n        zest_EndFrame(context, graph);   // 4. Execute &amp; present\n    }\n}\n</code></pre>"},{"location":"getting-started/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Frame Graph Concept - Deep dive into frame graphs</li> <li>Device &amp; Context Concept - Detailed API reference</li> <li>Minimal Template Tutorial - Annotated walkthrough</li> </ul>"},{"location":"getting-started/first-application/","title":"First Application","text":"<p>Let's build your first Zest application step by step. We'll create a minimal app that displays a blank screen - the simplest possible frame graph.</p>"},{"location":"getting-started/first-application/#complete-code","title":"Complete Code","text":"<p>Here's the full example (from <code>zest-minimal-template</code>):</p> <pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;SDL.h&gt;\n#include &lt;zest.h&gt;\n\nstruct minimal_app_t {\n    zest_device device;\n    zest_context context;\n};\n\nvoid BlankScreen(const zest_command_list command_list, void *user_data) {\n    // Render commands go here\n}\n\nvoid MainLoop(minimal_app_t *app) {\n    int running = 1;\n    SDL_Event event;\n\n    while (running) {\n        while (SDL_PollEvent(&amp;event)) {\n            if (event.type == SDL_QUIT) running = 0;\n        }\n\n        zest_UpdateDevice(app-&gt;device);\n\n        zest_frame_graph_cache_key_t cache_key = zest_InitialiseCacheKey(app-&gt;context, 0, 0);\n        if (zest_BeginFrame(app-&gt;context)) {\n            zest_frame_graph frame_graph = zest_GetCachedFrameGraph(app-&gt;context, &amp;cache_key);\n            if (!frame_graph) {\n                if (zest_BeginFrameGraph(app-&gt;context, \"Render Graph\", &amp;cache_key)) {\n                    zest_ImportSwapchainResource();\n                    zest_BeginRenderPass(\"Draw Nothing\"); {\n                        zest_ConnectSwapChainOutput();\n                        zest_SetPassTask(BlankScreen, 0);\n                        zest_EndPass();\n                    }\n                    frame_graph = zest_EndFrameGraph();\n                }\n            }\n            zest_EndFrame(app-&gt;context, frame_graph);\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    minimal_app_t app = {};\n\n    zest_window_data_t window = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"Minimal Example\");\n    app.device = zest_implsdl2_CreateVulkanDevice(&amp;window, false);\n\n    zest_create_context_info_t create_info = zest_CreateContextInfo();\n    app.context = zest_CreateContext(app.device, &amp;window, &amp;create_info);\n\n    MainLoop(&amp;app);\n    zest_DestroyDevice(app.device);\n\n    return 0;\n}\n</code></pre>"},{"location":"getting-started/first-application/#step-by-step-breakdown","title":"Step-by-Step Breakdown","text":""},{"location":"getting-started/first-application/#1-include-headers-and-define-implementation","title":"1. Include Headers and Define Implementation","text":"<pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;SDL.h&gt;\n#include &lt;zest.h&gt;\n</code></pre> <p>The <code>ZEST_IMPLEMENTATION</code> macros tell Zest to include the actual implementation, not just declarations. Do this in one file only.</p>"},{"location":"getting-started/first-application/#2-create-the-device","title":"2. Create the Device","text":"<pre><code>zest_window_data_t window = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"Minimal Example\");\napp.device = zest_implsdl2_CreateVulkanDevice(&amp;window, false);\n</code></pre> <p>The device is a singleton that manages:</p> <ul> <li>Vulkan instance and physical device selection</li> <li>Shader library</li> <li>Bindless descriptor sets</li> <li>Memory pools</li> </ul> <p>The <code>false</code> parameter disables validation layers (use <code>true</code> during development).</p>"},{"location":"getting-started/first-application/#3-create-the-context","title":"3. Create the Context","text":"<pre><code>zest_create_context_info_t create_info = zest_CreateContextInfo();\napp.context = zest_CreateContext(app.device, &amp;window, &amp;create_info);\n</code></pre> <p>The context is tied to a window/swapchain and manages:</p> <ul> <li>Frame resources (command buffers, synchronization)</li> <li>Frame graph compilation and execution</li> <li>Linear allocators for temporary data</li> </ul> <p>One device can serve multiple contexts (multiple windows).</p>"},{"location":"getting-started/first-application/#4-the-main-loop","title":"4. The Main Loop","text":"<pre><code>while (running) {\n    while (SDL_PollEvent(&amp;event)) {          // Handle window events\n        if (event.type == SDL_QUIT) running = 0;\n    }\n\n    zest_UpdateDevice(app.device);           // Update device state\n\n    if (zest_BeginFrame(app.context)) {\n        // Build or get cached frame graph...\n        zest_EndFrame(app.context, frame_graph);  // Execute and present\n    }\n}\n</code></pre> <p>Every frame:</p> <ol> <li><code>zest_UpdateDevice()</code> - Updates device-level state</li> <li><code>zest_BeginFrame()</code> - Acquires swapchain image, returns false if window minimized</li> <li>Build or get cached frame graph</li> <li><code>zest_EndFrame(context, frame_graph)</code> - Executes the graph and presents the frame</li> </ol>"},{"location":"getting-started/first-application/#5-frame-graph-caching","title":"5. Frame Graph Caching","text":"<pre><code>zest_frame_graph_cache_key_t cache_key = zest_InitialiseCacheKey(app-&gt;context, 0, 0);\nzest_frame_graph frame_graph = zest_GetCachedFrameGraph(app-&gt;context, &amp;cache_key);\n</code></pre> <p>Frame graphs can be cached to avoid recompilation every frame. The cache key identifies a specific frame graph configuration.</p>"},{"location":"getting-started/first-application/#6-building-the-frame-graph","title":"6. Building the Frame Graph","text":"<pre><code>if (zest_BeginFrameGraph(app-&gt;context, \"Render Graph\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();\n    zest_BeginRenderPass(\"Draw Nothing\"); {\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(BlankScreen, 0);\n        zest_EndPass();\n    }\n    frame_graph = zest_EndFrameGraph();\n}\n</code></pre> <p>When building a frame graph:</p> <ol> <li>Import resources - <code>zest_ImportSwapchainResource()</code> makes the swapchain available</li> <li>Define passes - Each pass has inputs, outputs, and a task callback</li> <li>Connect resources - <code>zest_ConnectSwapChainOutput()</code> declares this pass writes to the swapchain</li> <li>Set the task - The callback function that records GPU commands</li> <li>End and compile - <code>zest_EndFrameGraph()</code> compiles barriers and returns the graph</li> </ol>"},{"location":"getting-started/first-application/#7-execute-the-frame-graph","title":"7. Execute the Frame Graph","text":"<pre><code>zest_EndFrame(app-&gt;context, frame_graph);\n</code></pre> <p>This executes the frame graph and presents the result to the window. The frame graph is passed directly to <code>zest_EndFrame()</code> which handles execution and presentation.</p>"},{"location":"getting-started/first-application/#8-the-render-callback","title":"8. The Render Callback","text":"<pre><code>void BlankScreen(const zest_command_list command_list, void *user_data) {\n    // Usually you'd have commands like:\n    // zest_cmd_BindPipeline(command_list, pipeline);\n    // zest_cmd_Draw(command_list, vertex_count, 1, 0, 0);\n}\n</code></pre> <p>This callback receives a command list for recording GPU commands. The <code>user_data</code> parameter lets you pass your application state.</p>"},{"location":"getting-started/first-application/#whats-next","title":"What's Next?","text":"<p>Now that you understand the basic structure:</p> <ul> <li>Architecture Overview - Deeper explanation of Device, Context, and Frame Graph</li> <li>Adding ImGui Tutorial - Add a UI to your application</li> <li>Frame Graph Concept - Full details on the frame graph system</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers building Zest from source and running the examples.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Vulkan SDK - Although Zest has a separate platform layer, only Vulkan is implemented currently. Download from LunarG</li> <li>CMake 3.8+ - Build system (if you want to create projects for the examples)</li> <li>C++17 compiler (for the examples, C11 for the library only) - MSVC 2019+, GCC 9+, or Clang 10+</li> <li>SDL2 - For convenience although you can use anything else if you want (including GLFW). Windowing library (included as submodule)</li> </ul>"},{"location":"getting-started/installation/#linux-specific-prerequisites","title":"Linux-Specific Prerequisites","text":"<p>On Linux, you'll need to install the following packages:</p> Ubuntu/DebianFedoraArch Linux <pre><code>sudo apt install libsdl2-dev libshaderc-dev vulkan-tools\n</code></pre> <pre><code>sudo dnf install SDL2-devel shaderc vulkan-tools\n</code></pre> <pre><code>sudo pacman -S sdl2 shaderc vulkan-tools\n</code></pre> <p>Vulkan SDK on Linux</p> <p>While you can install the Vulkan SDK manually from LunarG, many Linux distributions provide sufficient Vulkan development packages. If you need Slang support, you should install the full Vulkan SDK and source the setup script: <pre><code>source ~/path/to/vulkansdk/setup-env.sh\n</code></pre></p>"},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone --recursive https://github.com/peterigz/zest.git\ncd zest\n</code></pre> <p>Submodules</p> <p>The <code>--recursive</code> flag is important - Zest uses submodules for SDL2, ImGui, and other dependencies used by the examples.</p>"},{"location":"getting-started/installation/#build-with-cmake","title":"Build with CMake","text":"Windows (Visual Studio)Linux/macOS <pre><code>cmake -B build -G \"Visual Studio 17 2022\"\ncmake --build build --config Release\n</code></pre> <pre><code>cmake -B build\ncmake --build build --config Release\n</code></pre>"},{"location":"getting-started/installation/#run-the-examples","title":"Run the Examples","text":"<p>After building, you'll find the executables in the build directory:</p> WindowsLinux/macOS <pre><code>build\\examples\\SDL2\\Release\\zest-minimal-template.exe\nbuild\\examples\\SDL2\\Release\\zest-imgui-template.exe\n</code></pre> <pre><code>./build/examples/SDL2/zest-minimal-template\n./build/examples/SDL2/zest-imgui-template\n./build/examples/SDL2/zest-vaders\n</code></pre> <p>Working Directory</p> <p>Run examples from the repository root directory so they can find the <code>examples/assets/</code> folder.</p>"},{"location":"getting-started/installation/#optional-enable-slang-shader-compiler","title":"Optional: Enable Slang Shader Compiler","text":"<p>If you want to use the Slang shader compiler for runtime shader compilation:</p> <pre><code>cmake -B build -DZEST_ENABLE_SLANG=ON\n</code></pre> <p>This enables the <code>zest-compute-example</code> which demonstrates Slang integration with compute shaders.</p> <p>Slang Requirement</p> <p>The <code>VULKAN_SDK</code> environment variable must be set when using Slang. On Linux, source the Vulkan SDK setup script before running CMake: <pre><code>source ~/path/to/vulkansdk/setup-env.sh\ncmake -B build -DZEST_ENABLE_SLANG=ON\n</code></pre></p>"},{"location":"getting-started/installation/#run-the-test-suite","title":"Run the Test Suite","text":"WindowsLinux/macOS <pre><code>build\\examples\\SDL2\\Release\\zest-tests.exe\n</code></pre> <pre><code>./build/examples/SDL2/zest-tests\n</code></pre> <p>The test suite includes 68 tests covering frame graph compilation, memory management, pipeline states, and image formats.</p>"},{"location":"getting-started/installation/#using-zest-in-your-project","title":"Using Zest in Your Project","text":""},{"location":"getting-started/installation/#option-1-copy-headers","title":"Option 1: Copy Headers","text":"<p>Copy these files to your project:</p> <ul> <li><code>zest.h</code> - Main API header</li> <li><code>zest_vulkan.h</code> - Vulkan implementation</li> <li><code>zest_utilities.h</code> (optional) - image loading, mesh primitives, basic gltf loading, fonts</li> </ul>"},{"location":"getting-started/installation/#option-2-add-as-subdirectory","title":"Option 2: Add as Subdirectory","text":"<pre><code>add_subdirectory(path/to/zest)\ntarget_link_libraries(your_app zest-interface)\n</code></pre>"},{"location":"getting-started/installation/#implementation-defines","title":"Implementation Defines","text":"<p>In exactly one <code>.cpp</code> file, define the implementation macros before including:</p> <pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;zest.h&gt;\n</code></pre> <p>All other files just include the header normally:</p> <pre><code>#include &lt;zest.h&gt;\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#vulkan-validation-errors","title":"Vulkan Validation Errors","text":"<p>Enable validation layers during development:</p> <pre><code>zest_window_data_t window_data = zest_implsdl2_CreateWindow(50, 50, 1280, 768, 0, \"My App\");\nzest_device device = zest_implsdl2_CreateVulkanDevice(&amp;window_data, true);  // true = enable validation\n</code></pre>"},{"location":"getting-started/installation/#missing-submodules","title":"Missing Submodules","text":"<p>If you cloned without <code>--recursive</code>:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"getting-started/installation/#gpu-not-supported","title":"GPU Not Supported","text":"<p>Zest requires Vulkan 1.2+ with bindless descriptor support. Most discrete GPUs from 2016+ are supported. Some integrated GPUs may not have full bindless support.</p>"},{"location":"getting-started/installation/#linux-shaderc-not-found","title":"Linux: shaderc Not Found","text":"<p>If you get a warning about shaderc not being found, install the shaderc development package for your distribution (see Linux-Specific Prerequisites above). shaderc is required for runtime shader compilation.</p>"},{"location":"getting-started/installation/#linux-sdl2-not-found","title":"Linux: SDL2 Not Found","text":"<p>If CMake reports SDL2 not found:</p> <ol> <li>Install the SDL2 development package (see Linux-Specific Prerequisites above)</li> <li>If using the Vulkan SDK's SDL2, ensure <code>VULKAN_SDK</code> is set before running CMake</li> </ol>"},{"location":"getting-started/installation/#linux-slang-library-not-found","title":"Linux: Slang Library Not Found","text":"<p>If Slang is enabled but not found:</p> <ol> <li>Ensure the Vulkan SDK is installed (not just system packages)</li> <li>Source the SDK setup script: <code>source ~/vulkansdk/x.x.x.x/setup-env.sh</code></li> <li>Verify <code>VULKAN_SDK</code> is set: <code>echo $VULKAN_SDK</code></li> <li>Re-run CMake after sourcing the setup script</li> </ol>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides to build practical knowledge with Zest. Each tutorial builds on previous concepts and references working examples.</p>"},{"location":"tutorials/#tutorial-path","title":"Tutorial Path","text":"# Tutorial Example What You'll Learn 1 Minimal Template zest-minimal-template Basic setup, frame graph, render pass 2 Adding ImGui zest-imgui-template UI integration, fonts, docking 3 GPU Instancing zest-instancing Instance layers, 3D models, GLTF 4 Loading Textures zest-pbr-texture Images, KTX, bindless textures 5 Compute Shaders zest-compute-example Compute passes, storage buffers 6 Multi-Pass Rendering zest-render-targets Transient resources, bloom 7 Shadow Mapping zest-shadow-mapping Depth rendering, shadow techniques"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting the tutorials:</p> <ol> <li>Complete Installation</li> <li>Build and run the examples</li> <li>Read Architecture Overview</li> </ol>"},{"location":"tutorials/#how-to-use-these-tutorials","title":"How to Use These Tutorials","text":"<p>Each tutorial:</p> <ul> <li>Explains the concepts being demonstrated</li> <li>Shows key code snippets with explanations</li> <li>Links to the full example source code</li> <li>Suggests exercises to extend your learning</li> </ul> <p>Start with Tutorial 1 and progress in order, or jump to specific topics if you have prior experience.</p>"},{"location":"tutorials/#quick-reference","title":"Quick Reference","text":"<p>Need specific information? Check these:</p> <ul> <li>Concepts - Deep dives on specific systems</li> <li>API Reference - Function documentation</li> <li>Examples - All working examples</li> </ul>"},{"location":"tutorials/01-minimal-template/","title":"Tutorial 1: Minimal Template","text":"<p>This tutorial walks through the simplest possible Zest application - displaying a blank screen using a frame graph.</p> <p>For all the tutorials we use SDL2 as the windowing library.</p> <p>Example: <code>examples/SDL2/zest-minimal-template</code></p>"},{"location":"tutorials/01-minimal-template/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Creating a device and context</li> <li>Building a frame graph</li> <li>Defining a render pass</li> <li>Frame graph caching</li> </ul>"},{"location":"tutorials/01-minimal-template/#the-application-structure","title":"The Application Structure","text":"<p>Every Zest application follows this pattern:</p> <pre><code>struct app_t {\n    zest_device device;    // GPU resources (one per app)\n    zest_context context;  // Window/swapchain (one per window)\n};\n</code></pre>"},{"location":"tutorials/01-minimal-template/#step-1-include-headers","title":"Step 1: Include Headers","text":"<pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;SDL.h&gt;\n#include &lt;zest.h&gt;\n</code></pre> <p>Important</p> <p>The <code>ZEST_IMPLEMENTATION</code> defines must be in exactly one <code>.cpp</code> or <code>c</code> file.</p>"},{"location":"tutorials/01-minimal-template/#step-2-initialize-device-and-context","title":"Step 2: Initialize Device and Context","text":"<pre><code>int main(int argc, char *argv[]) {\n    app_t app = {};\n\n    // Create window\n    zest_window_data_t window = zest_implsdl2_CreateWindow(\n        50, 50,       // Position\n        1280, 768,    // Size\n        0,            // Maximised\n        \"Minimal Example\"\n    );\n\n    // Create device (Vulkan instance, GPU selection, resource pools)\n    app.device = zest_implsdl2_CreateVulkanDevice(&amp;window, false);\n\n    // Configure context options\n    zest_create_context_info_t create_info = zest_CreateContextInfo();\n    // Create context (swapchain, command pools, frame resources)\n    app.context = zest_CreateContext(app.device, &amp;window, &amp;create_info);\n\n    // Run main loop\n    MainLoop(&amp;app);\n\n    // Cleanup\n    zest_DestroyDevice(app.device);\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/01-minimal-template/#step-3-the-main-loop","title":"Step 3: The Main Loop","text":"<pre><code>void MainLoop(app_t *app) {\n    int running = 1;\n    SDL_Event event;\n\n    while (running) {\n        // Process window events\n        while (SDL_PollEvent(&amp;event)) {\n            if (event.type == SDL_QUIT) running = 0;\n        }\n\n        // Update device state (deferred cleanup, etc.)\n        zest_UpdateDevice(app-&gt;device);\n\n        // Generate cache key for frame graph\n        zest_frame_graph_cache_key_t cache_key = zest_InitialiseCacheKey(app-&gt;context, 0, 0);\n\n        // Begin frame (acquires swapchain image)\n        if (zest_BeginFrame(app-&gt;context)) {\n            // Try to get cached frame graph\n            zest_frame_graph frame_graph = zest_GetCachedFrameGraph(app-&gt;context, &amp;cache_key);\n\n            if (!frame_graph) {\n                // Build new frame graph\n                frame_graph = BuildFrameGraph(app, &amp;cache_key);\n            }\n\n            // End frame (executes frame graph, submits commands, presents)\n            zest_EndFrame(app-&gt;context, frame_graph);\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/01-minimal-template/#key-points","title":"Key Points","text":"<ul> <li><code>zest_UpdateDevice()</code> must be called every frame</li> <li><code>zest_BeginFrame()</code> returns <code>false</code> if window is minimized or the window changes size which results in the swapchain being recreated.</li> <li>Frame graphs are cached to avoid recompilation</li> </ul>"},{"location":"tutorials/01-minimal-template/#step-4-building-the-frame-graph","title":"Step 4: Building the Frame Graph","text":"<pre><code>zest_frame_graph BuildFrameGraph(app_t *app, zest_frame_graph_cache_key_t *cache_key) {\n    if (zest_BeginFrameGraph(app-&gt;context, \"Render Graph\", cache_key)) {\n        // Import the swapchain as a resource\n        zest_ImportSwapchainResource();\n\n        // Create a render pass\n        zest_BeginRenderPass(\"Draw Nothing\"); {\n            // Declare output to swapchain\n            zest_ConnectSwapChainOutput();\n\n            // Set the render callback\n            zest_SetPassTask(BlankScreen, 0);\n\n            // End pass definition\n            zest_EndPass();\n        }\n\n        // Compile and return\n        return zest_EndFrameGraph();\n    }\n    return 0;\n}\n</code></pre>"},{"location":"tutorials/01-minimal-template/#what-happens-here","title":"What Happens Here","text":"<ol> <li>Import swapchain - Makes it available for output</li> <li>Begin render pass - Starts pass definition</li> <li>Connect output - Declares this pass writes to swapchain</li> <li>Set task - Assigns the render callback</li> <li>End frame graph - Compiles barriers and synchronization</li> </ol>"},{"location":"tutorials/01-minimal-template/#step-5-the-render-callback","title":"Step 5: The Render Callback","text":"<pre><code>void BlankScreen(const zest_command_list command_list, void *user_data) {\n    // This is where rendering commands go\n    // With nothing here, we get a blank screen (cleared to the clear color)\n}\n</code></pre> <p>The callback receives:</p> <ul> <li><code>command_list</code> - For recording GPU commands</li> <li><code>user_data</code> - Whatever you passed to <code>zest_SetPassTask()</code></li> </ul>"},{"location":"tutorials/01-minimal-template/#understanding-frame-graph-caching","title":"Understanding Frame Graph Caching","text":"<pre><code>// Cache key includes context state + optional custom data\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, custom_data, data_size);\n\n// First frame: cache miss, build graph\nzest_frame_graph graph = zest_GetCachedFrameGraph(context, &amp;key);\n// graph == NULL\n\n// Build and cache\ngraph = BuildFrameGraph(...);\n\n// Next frame: cache hit, skip building\ngraph = zest_GetCachedFrameGraph(context, &amp;key);\n// graph == valid cached graph\n</code></pre> <p>Use custom data in the cache key for different configurations:</p> <pre><code>struct config_t { int render_mode; };\nconfig_t config = { .render_mode = 1 };\nzest_frame_graph_cache_key_t key = zest_InitialiseCacheKey(context, &amp;config, sizeof(config));\n</code></pre>"},{"location":"tutorials/01-minimal-template/#complete-code","title":"Complete Code","text":"<p>See the full source at <code>examples/SDL2/zest-minimal-template/zest-minimal-template.cpp</code>.</p>"},{"location":"tutorials/01-minimal-template/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 2: Adding ImGui - Add a user interface</li> <li>Frame Graph Concept - Deep dive on frame graphs</li> </ul>"},{"location":"tutorials/02-imgui/","title":"Tutorial 2: Adding ImGui","text":"<p>This tutorial shows how to integrate Dear ImGui with Zest for immediate-mode UI rendering.</p> <p>Example: <code>examples/SDL2/zest-imgui-template</code></p>"},{"location":"tutorials/02-imgui/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Setting up ImGui with Zest</li> <li>Custom fonts</li> <li>ImGui render pass integration</li> <li>Docking support</li> </ul>"},{"location":"tutorials/02-imgui/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Tutorial 1</li> <li>ImGui submodule (included with Zest)</li> </ul>"},{"location":"tutorials/02-imgui/#additional-includes","title":"Additional Includes","text":"<pre><code>#define ZEST_IMPLEMENTATION\n#define ZEST_VULKAN_IMPLEMENTATION\n#include &lt;SDL.h&gt;\n#include &lt;zest.h&gt;\n\n// ImGui implementation\n#include &lt;imgui.h&gt;\n#include &lt;impl_imgui.h&gt;\n#include &lt;imgui_impl_sdl2.h&gt;\n</code></pre>"},{"location":"tutorials/02-imgui/#application-structure","title":"Application Structure","text":"<pre><code>struct app_t {\n    zest_device device;\n    zest_context context;\n    zest_imgui_t imgui;         // ImGui state\n    zest_timer_t timer;         // For fixed timestep\n};\n</code></pre>"},{"location":"tutorials/02-imgui/#step-1-initialize-imgui","title":"Step 1: Initialize ImGui","text":"<pre><code>void InitImGui(app_t *app) {\n    // Initialize Zest's ImGui integration\n    zest_imgui_Initialise(app-&gt;context, &amp;app-&gt;imgui, zest_implsdl2_DestroyWindow);\n\n    // Initialize ImGui for SDL2\n    ImGui_ImplSDL2_InitForVulkan((SDL_Window*)zest_Window(app-&gt;context));\n\n    // Apply dark style, you can copy this function and setup your own colors\n    zest_imgui_DarkStyle(&amp;app-&gt;imgui);\n}\n</code></pre>"},{"location":"tutorials/02-imgui/#step-2-custom-fonts-optional","title":"Step 2: Custom Fonts (Optional)","text":"<pre><code>void SetupFonts(app_t *app) {\n    ImGuiIO&amp; io = ImGui::GetIO();\n    io.Fonts-&gt;Clear();\n\n    // Load custom font\n    io.Fonts-&gt;AddFontFromFileTTF(\"assets/fonts/Roboto-Regular.ttf\", 16.0f);\n\n    // Build font atlas\n    unsigned char* font_data;\n    int tex_width, tex_height;\n    io.Fonts-&gt;GetTexDataAsRGBA32(&amp;font_data, &amp;tex_width, &amp;tex_height);\n\n    // Upload to GPU\n    zest_imgui_RebuildFontTexture(&amp;app-&gt;imgui, tex_width, tex_height, font_data);\n}\n</code></pre>"},{"location":"tutorials/02-imgui/#step-3-imgui-in-the-main-loop","title":"Step 3: ImGui in the Main Loop","text":"<pre><code>void MainLoop(app_t *app) {\n    int running = 1;\n    SDL_Event event;\n\n    while (running) {\n        while (SDL_PollEvent(&amp;event)) {\n            ImGui_ImplSDL2_ProcessEvent(&amp;event);\n            if (event.type == SDL_QUIT) running = 0;\n        }\n\n        zest_UpdateDevice(app-&gt;device);\n\n        // Fixed timestep loop for game logic\n    // This is optional and just shows that you can use a timer to only update imgui a maximum number of times per second\n        zest_StartTimerLoop(app-&gt;timer) {\n            // Start ImGui frame\n            ImGui_ImplSDL2_NewFrame();\n            ImGui::NewFrame();\n\n            // Your UI code\n            DrawUI(app);\n\n            // Finalize ImGui frame\n            ImGui::Render();\n        } zest_EndTimerLoop(app-&gt;timer);\n\n        // Render\n        if (zest_BeginFrame(app-&gt;context)) {\n            // ... build/get frame graph ...\n            zest_EndFrame(app-&gt;context, frame_graph);\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/02-imgui/#step-4-building-the-frame-graph-with-imgui","title":"Step 4: Building the Frame Graph with ImGui","text":"<pre><code>zest_frame_graph BuildFrameGraph(app_t *app, zest_frame_graph_cache_key_t *cache_key) {\n    if (zest_BeginFrameGraph(app-&gt;context, \"ImGui Graph\", cache_key)) {\n        zest_ImportSwapchainResource();\n\n        // Your render passes first...\n        zest_BeginRenderPass(\"Scene\"); {\n            zest_ConnectSwapChainOutput();\n            zest_SetPassTask(RenderScene, app);\n            zest_EndPass();\n        }\n\n        // ImGui pass last (renders on top)\n        zest_pass_node imgui_pass = zest_imgui_BeginPass(&amp;app-&gt;imgui, app-&gt;imgui.main_viewport);\n        if (imgui_pass) {\n            zest_ConnectSwapChainOutput();\n            zest_EndPass();\n        }\n\n        return zest_EndFrameGraph();\n    }\n    return 0;\n}\n</code></pre> <p>Note</p> <p><code>zest_imgui_BeginPass</code> handles pass setup and callback assignment internally.</p>"},{"location":"tutorials/02-imgui/#step-5-drawing-ui","title":"Step 5: Drawing UI","text":"<pre><code>void DrawUI(app_t *app) {\n    // Main menu bar\n    if (ImGui::BeginMainMenuBar()) {\n        if (ImGui::BeginMenu(\"File\")) {\n            if (ImGui::MenuItem(\"Exit\")) {\n                // Handle exit\n            }\n            ImGui::EndMenu();\n        }\n        ImGui::EndMainMenuBar();\n    }\n\n    // Debug window\n    ImGui::Begin(\"Debug\");\n    ImGui::Text(\"Frame time: %.3f ms\", zest_TimerDeltaTime(&amp;app-&gt;timer) * 1000.0f);\n    ImGui::Text(\"FPS: %.1f\", 1.0f / zest_TimerDeltaTime(&amp;app-&gt;timer));\n\n    if (ImGui::Button(\"Reset\")) {\n        // Handle reset\n    }\n\n    ImGui::End();\n}\n</code></pre>"},{"location":"tutorials/02-imgui/#docking-support","title":"Docking Support","text":"<p>Enable docking for advanced layouts:</p> <pre><code>void InitImGui(app_t *app) {\n    zest_imgui_Initialise(app-&gt;context, &amp;app-&gt;imgui, zest_implsdl2_DestroyWindow);\n    ImGui_ImplSDL2_InitForVulkan((SDL_Window*)zest_Window(app-&gt;context));\n\n    // Enable docking\n    ImGuiIO&amp; io = ImGui::GetIO();\n    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;\n}\n\nvoid DrawUI(app_t *app) {\n    // Create dockspace over entire window\n    ImGui::DockSpaceOverViewport(ImGui::GetMainViewport()-&gt;ID, ImGui::GetMainViewport(), ImGuiDockNodeFlags_PassthruCentralNode);\n\n    // Now windows can be docked\n    ImGui::Begin(\"Panel 1\");\n    ImGui::Text(\"Dockable panel\");\n    ImGui::End();\n\n    ImGui::Begin(\"Panel 2\");\n    ImGui::Text(\"Another panel\");\n    ImGui::End();\n}\n</code></pre>"},{"location":"tutorials/02-imgui/#handling-input","title":"Handling Input","text":"<p>ImGui automatically captures input via <code>ImGui_ImplSDL2_InitForVulkan</code>. Check if ImGui wants input:</p> <pre><code>void HandleInput(app_t *app) {\n    ImGuiIO&amp; io = ImGui::GetIO();\n\n    // Don't process game input if ImGui wants it\n    if (io.WantCaptureMouse) {\n        return;\n    }\n\n    // Your game input handling using SDL2\n    int mouse_x, mouse_y;\n    Uint32 buttons = SDL_GetMouseState(&amp;mouse_x, &amp;mouse_y);\n    if (buttons &amp; SDL_BUTTON(SDL_BUTTON_LEFT)) {\n        // Handle click\n    }\n}\n</code></pre>"},{"location":"tutorials/02-imgui/#complete-example","title":"Complete Example","text":"<p>See the full source at <code>examples/SDL2/zest-imgui-template/zest-imgui-template.cpp</code>.</p>"},{"location":"tutorials/02-imgui/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 3: GPU Instancing - Render many objects efficiently</li> <li>ImGui Documentation - Official ImGui docs</li> </ul>"},{"location":"tutorials/03-instancing/","title":"Tutorial 3: GPU 3D Instancing","text":"<p>Learn to render thousands of objects efficiently using Zest's layer system.</p> <p>Example: <code>examples/SDL2/zest-instancing</code></p>"},{"location":"tutorials/03-instancing/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Instance mesh layers</li> <li>Loading 3D models (GLTF)</li> <li>Per-instance data</li> <li>Efficient batched drawing</li> </ul>"},{"location":"tutorials/03-instancing/#overview","title":"Overview","text":"<p>GPU instancing renders multiple copies of geometry in a single draw call. Each instance can have unique properties (position, rotation, color, texture).</p> <pre><code>Traditional: 1000 objects = 1000 draw calls\nInstancing:  1000 objects = 1 draw call\n</code></pre>"},{"location":"tutorials/03-instancing/#instance-data-structure","title":"Instance Data Structure","text":"<pre><code>struct mesh_instance_t {\n    zest_vec3 pos;\n    zest_vec3 rotation;\n    zest_vec3 scale;\n    zest_uint texture_layer_index;\n};\n</code></pre>"},{"location":"tutorials/03-instancing/#creating-an-instance-mesh-layer","title":"Creating an Instance Mesh Layer","text":"<pre><code>zest_layer_handle layer = zest_CreateInstanceMeshLayer(\n    context,\n    \"3d_objects\",\n    sizeof(mesh_instance_t),\n    MAX_VERTICES,\n    MAX_INDICES\n);\n</code></pre>"},{"location":"tutorials/03-instancing/#loading-meshes","title":"Loading Meshes","text":"<pre><code>// Load GLTF using the loader in zest_utilities.h (requires ZEST_ALL_UTILITIES_IMPLEMENTATION)\nzest_mesh mesh = LoadGLTFScene(context, \"model.gltf\", 1.0f);\n\n// Add to layer\nzest_layer layer_obj = zest_GetLayer(layer);\nzest_uint mesh_id = zest_AddMeshToLayer(layer_obj, mesh, 0);\n\n// Free mesh CPU data after adding to layer\nzest_FreeMesh(mesh);\n</code></pre>"},{"location":"tutorials/03-instancing/#preparing-instance-data","title":"Preparing Instance Data","text":"<p>Instance data is uploaded to a GPU buffer separately from the mesh layer:</p> <pre><code>// Allocate and fill instance data on CPU\nzest_size instance_data_size = INSTANCE_COUNT * sizeof(mesh_instance_t);\nmesh_instance_t* instance_data = (mesh_instance_t*)malloc(instance_data_size);\n\nfor (int i = 0; i &lt; INSTANCE_COUNT; i++) {\n    instance_data[i].pos = objects[i].pos;\n    instance_data[i].rotation = objects[i].rot;\n    instance_data[i].scale = {1, 1, 1};\n    instance_data[i].texture_layer_index = objects[i].tex_id;\n}\n\n// Create GPU buffer for instances\nzest_buffer_info_t buffer_info = zest_CreateBufferInfo(zest_buffer_type_vertex, zest_memory_usage_gpu_only);\nzest_buffer instance_buffer = zest_CreateBuffer(device, instance_data_size, &amp;buffer_info);\n\n// Upload via staging buffer\nzest_buffer staging = zest_CreateStagingBuffer(device, instance_data_size, instance_data);\nzest_queue queue = zest_imm_BeginCommandBuffer(device, zest_queue_transfer);\nzest_imm_CopyBuffer(queue, staging, instance_buffer, instance_data_size);\nzest_imm_EndCommandBuffer(queue);\n\n// Cleanup\nzest_FreeBuffer(staging);\nfree(instance_data);\n</code></pre>"},{"location":"tutorials/03-instancing/#pipeline-setup","title":"Pipeline Setup","text":"<pre><code>// Vertex input for per-vertex data (binding 0) using zest_vertex_t\nzest_AddVertexInputBindingDescription(pipeline, 0, sizeof(zest_vertex_t), zest_input_rate_vertex);\nzest_AddVertexAttribute(pipeline, 0, 0, zest_format_r32g32b32_sfloat, 0);                                   // Position\nzest_AddVertexAttribute(pipeline, 0, 1, zest_format_r8g8b8a8_unorm, offsetof(zest_vertex_t, color));        // Color\nzest_AddVertexAttribute(pipeline, 0, 2, zest_format_r32g32b32_sfloat, offsetof(zest_vertex_t, normal));     // Normal\nzest_AddVertexAttribute(pipeline, 0, 3, zest_format_r32g32_sfloat, offsetof(zest_vertex_t, uv));            // UV\n\n// Instance data (binding 1)\nzest_AddVertexInputBindingDescription(pipeline, 1, sizeof(mesh_instance_t), zest_input_rate_instance);\nzest_AddVertexAttribute(pipeline, 1, 4, zest_format_r32g32b32_sfloat, 0);                                   // Position\nzest_AddVertexAttribute(pipeline, 1, 5, zest_format_r32g32b32_sfloat, offsetof(mesh_instance_t, rotation)); // Rotation\nzest_AddVertexAttribute(pipeline, 1, 6, zest_format_r32g32b32_sfloat, offsetof(mesh_instance_t, scale));    // Scale\nzest_AddVertexAttribute(pipeline, 1, 7, zest_format_r32_uint, offsetof(mesh_instance_t, texture_layer_index)); // Texture\n</code></pre>"},{"location":"tutorials/03-instancing/#drawing","title":"Drawing","text":"<pre><code>void RenderCallback(zest_command_list command_list, void* user_data) {\n    app_t* app = (app_t*)user_data;\n    zest_layer layer = zest_GetLayer(app-&gt;instance_layer);\n\n    // Bind mesh vertex and index buffers from layer\n    zest_cmd_BindMeshVertexBuffer(command_list, layer);\n    zest_cmd_BindMeshIndexBuffer(command_list, layer);\n\n    // Bind instance buffer to binding slot 1\n    zest_cmd_BindVertexBuffer(command_list, 1, 1, app-&gt;instance_buffer);\n\n    // Bind pipeline\n    zest_pipeline pipeline = zest_GetPipeline(app-&gt;pipeline_template, command_list);\n    if (pipeline) {\n        zest_cmd_BindPipeline(command_list, pipeline);\n\n        // Get mesh offsets for indexed drawing\n        const zest_mesh_offset_data_t* offsets = zest_GetLayerMeshOffsets(layer, app-&gt;mesh_id);\n\n        // Set viewport\n        zest_cmd_SetScreenSizedViewport(command_list, 0.f, 1.f);\n\n        // Draw all instances\n        zest_cmd_DrawIndexed(command_list,\n            offsets-&gt;index_count,\n            INSTANCE_COUNT,\n            offsets-&gt;index_offset,\n            offsets-&gt;vertex_offset,\n            0\n        );\n    }\n}\n</code></pre>"},{"location":"tutorials/03-instancing/#full-example","title":"Full Example","text":"<p>See <code>examples/SDL2/zest-instancing/zest-instancing.cpp</code> for the complete implementation.</p>"},{"location":"tutorials/03-instancing/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 4: Loading Textures</li> <li>Layers Concept - Deep dive on layer types</li> </ul>"},{"location":"tutorials/04-textures/","title":"Tutorial 4: Loading Textures","text":"<p>Learn to load and use textures with Zest's bindless descriptor system.</p> <p>Example: <code>examples/SDL2/zest-pbr-texture</code></p>"},{"location":"tutorials/04-textures/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Loading images (PNG, KTX)</li> <li>Creating samplers</li> <li>Bindless texture access</li> <li>Texture arrays</li> </ul>"},{"location":"tutorials/04-textures/#loading-a-texture","title":"Loading a Texture","text":"<p>This example shows loading an image with stb_image but you can use any other image loader that suits you.</p> <pre><code>// Load pixels\nint width, height, channels;\nunsigned char* pixels = stbi_load(\"texture.png\", &amp;width, &amp;height, &amp;channels, 4);\n\n// Create image info\nzest_image_info_t info = zest_CreateImageInfo(width, height);\ninfo.format = zest_format_r8g8b8a8_unorm;\ninfo.flags = zest_image_preset_texture_mipmaps;\n\n// Create image\nzest_image_handle handle = zest_CreateImageWithPixels(device, pixels, width * height * 4, &amp;info);\nstbi_image_free(pixels);\n</code></pre>"},{"location":"tutorials/04-textures/#loading-ktx","title":"Loading KTX","text":"<pre><code>#include &lt;zest_utilities.h&gt;\n\nzest_image_handle texture = zest_LoadKTX(device, \"my_texture\", \"assets/texture.ktx\");\n</code></pre>"},{"location":"tutorials/04-textures/#creating-a-sampler","title":"Creating a Sampler","text":"<pre><code>zest_sampler_info_t sampler_info = zest_CreateSamplerInfo();\nsampler_info.min_filter = zest_filter_linear;\nsampler_info.mag_filter = zest_filter_linear;\nsampler_info.address_mode_u = zest_sampler_address_mode_repeat;\nsampler_info.address_mode_v = zest_sampler_address_mode_repeat;\n\nzest_sampler_handle sampler = zest_CreateSampler(device, &amp;sampler_info);\n</code></pre>"},{"location":"tutorials/04-textures/#acquiring-bindless-indices","title":"Acquiring Bindless Indices","text":"<pre><code>zest_image image = zest_GetImage(texture_handle);\nzest_sampler sampler_obj = zest_GetSampler(sampler);\n\nzest_uint tex_index = zest_AcquireSampledImageIndex(device, image, zest_texture_2d_binding);\nzest_uint sampler_index = zest_AcquireSamplerIndex(device, sampler_obj);\n</code></pre>"},{"location":"tutorials/04-textures/#using-in-shaders","title":"Using in Shaders","text":"<pre><code>layout(set = 0, binding = 0) uniform sampler samplers[];\nlayout(set = 0, binding = 1) uniform texture2D textures[];\n\nlayout(push_constant) uniform Push {\n    uint tex_index;\n    uint sampler_index;\n} push;\n\nvoid main() {\n    vec4 color = texture(\n        sampler2D(textures[push.tex_index], samplers[push.sampler_index]),\n        uv\n    );\n}\n</code></pre>"},{"location":"tutorials/04-textures/#full-example","title":"Full Example","text":"<p>See <code>examples/SDL2/zest-pbr-texture/zest-pbr-texture.cpp</code> for complete implementation with PBR textures.</p>"},{"location":"tutorials/04-textures/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 5: Compute Shaders</li> <li>Images Concept - Deep dive on image types</li> <li>Bindless Concept - Descriptor system details</li> </ul>"},{"location":"tutorials/05-compute/","title":"Tutorial 5: Compute Shaders","text":"<p>Learn to use compute shaders for GPU-accelerated processing.</p> <p>Example: <code>examples/SDL2/zest-compute-example</code></p>"},{"location":"tutorials/05-compute/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Creating compute pipelines</li> <li>Storage buffers</li> <li>Compute passes in frame graphs</li> <li>GPU particle simulation</li> </ul>"},{"location":"tutorials/05-compute/#creating-a-compute-shader","title":"Creating a Compute Shader","text":"<pre><code>zest_shader_handle comp = zest_CreateShaderFromFile(\n    device,\n    \"shaders/particles.comp\",\n    \"particles.spv\",\n    zest_compute_shader,\n    true  // Don't cache the shader, useful if you need to make changes and recompile\n);\n</code></pre>"},{"location":"tutorials/05-compute/#creating-a-compute-pipeline","title":"Creating a Compute Pipeline","text":"<pre><code>zest_compute_handle compute = zest_CreateCompute(device, \"particle_sim\", comp, user_data);\n</code></pre>"},{"location":"tutorials/05-compute/#storage-buffers","title":"Storage Buffers","text":"<pre><code>zest_buffer_info_t info = zest_CreateBufferInfo(\n    zest_buffer_type_storage,\n    zest_memory_usage_gpu_only\n);\nzest_buffer particles = zest_CreateBuffer(device, sizeof(particle_t) * MAX_PARTICLES, &amp;info);\n</code></pre>"},{"location":"tutorials/05-compute/#frame-graph-with-compute-pass","title":"Frame Graph with Compute Pass","text":"<pre><code>if (zest_BeginFrameGraph(context, \"Compute Graph\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();\n    zest_resource_node particle_resource = zest_ImportBufferResource(\"Particles\", particles);\n\n    // Compute pass\n    zest_compute compute_obj = zest_GetCompute(compute_handle);\n    zest_BeginComputePass(compute_obj, \"Simulate\"); {\n        zest_ConnectInput(particle_resource);\n        zest_ConnectOutput(particle_resource);  // Read-modify-write\n        zest_SetPassTask(ComputeCallback, app);\n        zest_EndPass();\n    }\n\n    // Render pass\n    zest_BeginRenderPass(\"Draw Particles\"); {\n        zest_ConnectInput(particle_resource);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(RenderCallback, app);\n        zest_EndPass();\n    }\n\n    return zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"tutorials/05-compute/#compute-callback","title":"Compute Callback","text":"<pre><code>void ComputeCallback(zest_command_list cmd, void* data) {\n    app_t* app = (app_t*)data;\n\n    zest_compute compute = zest_GetCompute(app-&gt;compute_handle);\n    zest_cmd_BindComputePipeline(cmd, compute);\n\n    // Push constants\n    compute_push_t push = { .delta_time = app-&gt;dt };\n    zest_cmd_SendPushConstants(cmd, &amp;push, sizeof(push));\n\n    // Dispatch\n    zest_cmd_DispatchCompute(cmd, (MAX_PARTICLES + 255) / 256, 1, 1);\n}\n</code></pre>"},{"location":"tutorials/05-compute/#compute-shader-glsl","title":"Compute Shader (GLSL)","text":"<pre><code>#version 450\n\nlayout(local_size_x = 256) in;\n\nlayout(set = 0, binding = 5) buffer Particles {\n    vec4 positions[];\n};\n\nlayout(push_constant) uniform Push {\n    float delta_time;\n} push;\n\nvoid main() {\n    uint id = gl_GlobalInvocationID.x;\n    vec4 pos = positions[id];\n\n    // Update particle\n    pos.y += pos.w * push.delta_time;  // w = velocity\n\n    positions[id] = pos;\n}\n</code></pre>"},{"location":"tutorials/05-compute/#full-example","title":"Full Example","text":"<p>See <code>examples/SDL2/zest-compute-example/zest-compute-example.cpp</code> for complete particle simulation.</p>"},{"location":"tutorials/05-compute/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 6: Multi-Pass Rendering</li> <li>Frame Graph Concept - Compute pass details</li> </ul>"},{"location":"tutorials/06-multipass/","title":"Tutorial 6: Multi-Pass Rendering","text":"<p>Learn to create complex rendering pipelines with multiple passes and transient resources.</p> <p>Example: <code>examples/SDL2/zest-render-targets</code></p>"},{"location":"tutorials/06-multipass/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Transient render targets</li> <li>Multi-pass frame graphs</li> <li>Bloom effect implementation</li> <li>Compute-based post-processing</li> </ul>"},{"location":"tutorials/06-multipass/#transient-resources","title":"Transient Resources","text":"<p>Resources that exist only during frame graph execution:</p> <pre><code>zest_image_resource_info_t hdr_info = {\n    .format = zest_format_r16g16b16a16_sfloat,\n    .usage_hint = zest_resource_usage_hint_render_target,\n    .width = screen_width,\n    .height = screen_height,\n    .mip_levels = 1\n};\nzest_resource_node hdr_target = zest_AddTransientImageResource(\"HDR\", &amp;hdr_info);\n</code></pre>"},{"location":"tutorials/06-multipass/#multi-pass-frame-graph","title":"Multi-Pass Frame Graph","text":"<pre><code>if (zest_BeginFrameGraph(context, \"Bloom Pipeline\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();\n\n    // Transient targets\n    zest_resource_node scene = zest_AddTransientImageResource(\"Scene\", &amp;hdr_info);\n    zest_resource_node bright = zest_AddTransientImageResource(\"Bright\", &amp;hdr_info);\n    zest_resource_node blur_h = zest_AddTransientImageResource(\"BlurH\", &amp;hdr_info);\n    zest_resource_node blur_v = zest_AddTransientImageResource(\"BlurV\", &amp;hdr_info);\n\n    // Pass 1: Render scene to HDR\n    zest_BeginRenderPass(\"Scene\"); {\n        zest_ConnectOutput(scene);\n        zest_SetPassTask(RenderScene, app);\n        zest_EndPass();\n    }\n\n    // Pass 2: Extract bright pixels\n    zest_BeginComputePass(extract_compute, \"Extract Bright\"); {\n        zest_ConnectInput(scene);\n        zest_ConnectOutput(bright);\n        zest_SetPassTask(ExtractBright, app);\n        zest_EndPass();\n    }\n\n    // Pass 3: Horizontal blur\n    zest_BeginComputePass(blur_compute, \"Blur H\"); {\n        zest_ConnectInput(bright);\n        zest_ConnectOutput(blur_h);\n        zest_SetPassTask(BlurHorizontal, app);\n        zest_EndPass();\n    }\n\n    // Pass 4: Vertical blur\n    zest_BeginComputePass(blur_compute, \"Blur V\"); {\n        zest_ConnectInput(blur_h);\n        zest_ConnectOutput(blur_v);\n        zest_SetPassTask(BlurVertical, app);\n        zest_EndPass();\n    }\n\n    // Pass 5: Composite\n    zest_BeginRenderPass(\"Composite\"); {\n        zest_ConnectInput(scene);\n        zest_ConnectInput(blur_v);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(Composite, app);\n        zest_EndPass();\n    }\n\n    return zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"tutorials/06-multipass/#benefits-of-transient-resources","title":"Benefits of Transient Resources","text":"<ul> <li>Memory aliasing - Non-overlapping resources share memory</li> <li>Automatic barriers - Frame graph handles transitions</li> <li>No manual cleanup - Freed after execution</li> </ul>"},{"location":"tutorials/06-multipass/#full-example","title":"Full Example","text":"<p>See <code>examples/SDL2/zest-render-targets/zest-render-targets.cpp</code> for complete bloom implementation.</p>"},{"location":"tutorials/06-multipass/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 7: Shadow Mapping</li> <li>Memory Concept - Transient resource memory</li> </ul>"},{"location":"tutorials/07-shadows/","title":"Tutorial 7: Shadow Mapping","text":"<p>Learn to implement shadow mapping with depth render targets.</p> <p>Example: <code>examples/SDL2/zest-shadow-mapping</code></p>"},{"location":"tutorials/07-shadows/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Depth-only render passes</li> <li>Shadow map generation</li> <li>Sampling depth textures</li> <li>PCF filtering basics</li> </ul>"},{"location":"tutorials/07-shadows/#creating-a-shadow-map","title":"Creating a Shadow Map","text":"<pre><code>zest_image_info_t shadow_info = zest_CreateImageInfo(SHADOW_MAP_SIZE, SHADOW_MAP_SIZE);\nshadow_info.format = zest_format_d32_sfloat;\nshadow_info.flags = zest_image_preset_depth;\n\nzest_image_handle shadow_map = zest_CreateImage(device, &amp;shadow_info);\n</code></pre>"},{"location":"tutorials/07-shadows/#frame-graph-with-shadow-pass","title":"Frame Graph with Shadow Pass","text":"<pre><code>if (zest_BeginFrameGraph(context, \"Shadow Mapping\", &amp;cache_key)) {\n    zest_ImportSwapchainResource();\n    zest_resource_node shadow = zest_ImportImageResource(\"Shadow\", shadow_image, zest_texture_2d_binding);\n\n    // Pass 1: Render shadow map\n    zest_BeginRenderPass(\"Shadow Pass\"); {\n        zest_ConnectOutput(shadow);\n        zest_SetPassTask(RenderShadowMap, app);\n        zest_EndPass();\n    }\n\n    // Pass 2: Render scene with shadows\n    zest_BeginRenderPass(\"Scene\"); {\n        zest_ConnectInput(shadow);\n        zest_ConnectSwapChainOutput();\n        zest_SetPassTask(RenderScene, app);\n        zest_EndPass();\n    }\n\n    return zest_EndFrameGraph();\n}\n</code></pre>"},{"location":"tutorials/07-shadows/#shadow-pass-pipeline","title":"Shadow Pass Pipeline","text":"<pre><code>// Depth-only pipeline (no fragment shader output)\nzest_pipeline_template_handle shadow_pipeline = zest_BeginPipelineTemplate(device, \"shadow\");\nzest_SetPipelineVertShader(shadow_pipeline, shadow_vert);\n// No fragment shader needed for depth-only\nzest_SetPipelineDepthTest(shadow_pipeline, true, true);\nzest_SetPipelineCullMode(shadow_pipeline, zest_cull_mode_front);  // Reduce peter-panning\n</code></pre>"},{"location":"tutorials/07-shadows/#shadow-map-shader","title":"Shadow Map Shader","text":"<pre><code>// Vertex shader - output light-space position\nlayout(push_constant) uniform Push {\n    mat4 light_space_matrix;\n} push;\n\nvoid main() {\n    gl_Position = push.light_space_matrix * model * vec4(position, 1.0);\n}\n</code></pre>"},{"location":"tutorials/07-shadows/#sampling-shadows","title":"Sampling Shadows","text":"<pre><code>float ShadowCalculation(vec4 light_space_pos) {\n    vec3 proj = light_space_pos.xyz / light_space_pos.w;\n    proj = proj * 0.5 + 0.5;  // Transform to [0,1]\n\n    float current_depth = proj.z;\n    float shadow_depth = texture(sampler2D(shadow_map, shadow_sampler), proj.xy).r;\n\n    float bias = 0.005;\n    return current_depth - bias &gt; shadow_depth ? 0.5 : 1.0;\n}\n</code></pre>"},{"location":"tutorials/07-shadows/#full-example","title":"Full Example","text":"<p>See <code>examples/SDL2/zest-shadow-mapping/zest-shadow-mapping.cpp</code> for complete implementation.</p> <p>Also check <code>examples/SDL2/zest-cascading-shadows/</code> for cascaded shadow maps.</p>"},{"location":"tutorials/07-shadows/#next-steps","title":"Next Steps","text":"<ul> <li>Examples Gallery - All working examples</li> <li>Frame Graph Concept - Multi-pass details</li> </ul>"}]}